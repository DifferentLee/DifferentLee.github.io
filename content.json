{"meta":{"title":"下水道灵魂画手","subtitle":"","description":"一次编译，到处运行","author":"DifferentLee","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"CN五大城市PM2.5数据分析","slug":"PM2.5_five_cities","date":"2022-12-01T07:42:10.000Z","updated":"2022-12-05T13:41:08.962Z","comments":true,"path":"2022/12/01/PM2.5_five_cities/","link":"","permalink":"http://example.com/2022/12/01/PM2.5_five_cities/","excerpt":"","text":"中国农业大学 Python 程序设计实验报告 [toc] CSV文件数据预处理(pursue_mean.py) 导入CSV文件 1234567import pandas as pddf_bj = pd.read_csv(&quot;./data/BeijingPM20100101_20151231.csv&quot;)df_sh = pd.read_csv(&quot;./data/ShanghaiPM20100101_20151231.csv&quot;)df_cd = pd.read_csv(&quot;./data/ChengduPM20100101_20151231.csv&quot;)df_gz = pd.read_csv(&quot;./data/GuangzhouPM20100101_20151231.csv&quot;)df_sy = pd.read_csv(&quot;./data/ShenyangPM20100101_20151231.csv&quot;) 北京的数据信息 如何衡量污染状态 根据 《中华人民共和国生态环境部 环境空气质量指数（AQI）技术规定（试行）》 做一个不是很合理的假设–PM2.5是首要污染物，即令 AQI = IAQI(PM2.5) 即用PM2.5的数据粗略地去估计污染指数 如何划分污染等级 同样地，根据《中华人民共和国生态环境部 环境空气质量指数（AQI）技术规定（试行）》 我们取100为区分污染和优良的分界点 求PM2.5均值 求中国的测点和美国测点PM2.5的平均值: 12345df_bj[&#x27;PM_mean&#x27;] = df_bj.loc[:, [&#x27;PM_Dongsi&#x27;, &#x27;PM_Dongsihuan&#x27;, &#x27;PM_Nongzhanguan&#x27;, &#x27;PM_US Post&#x27;]].mean(axis=1)df_sh[&#x27;PM_mean&#x27;] = df_sh.loc[:, [&#x27;PM_Jingan&#x27;, &#x27;PM_US Post&#x27;, &#x27;PM_Xuhui&#x27;]].mean(axis=1)df_cd[&#x27;PM_mean&#x27;] = df_cd.loc[:, [&#x27;PM_Caotangsi&#x27;, &#x27;PM_Shahepu&#x27;, &#x27;PM_US Post&#x27;]].mean(axis=1)df_gz[&#x27;PM_mean&#x27;] = df_gz.loc[:, [&#x27;PM_City Station&#x27;, &#x27;PM_5th Middle School&#x27;, &#x27;PM_US Post&#x27;]].mean(axis=1)df_sy[&#x27;PM_mean&#x27;] = df_sy.loc[:, [&#x27;PM_Taiyuanjie&#x27;, &#x27;PM_US Post&#x27;, &#x27;PM_Xiaoheyan&#x27;]].mean(axis=1) 求求中国的测点PM2.5的平均值: 12345df_bj[&#x27;PM_mean_CN&#x27;] = df_bj.loc[:, [&#x27;PM_Dongsi&#x27;, &#x27;PM_Dongsihuan&#x27;, &#x27;PM_Nongzhanguan&#x27;]].mean(axis=1)df_sh[&#x27;PM_mean_CN&#x27;] = df_sh.loc[:, [&#x27;PM_Jingan&#x27;, &#x27;PM_Xuhui&#x27;]].mean(axis=1)df_cd[&#x27;PM_mean_CN&#x27;] = df_cd.loc[:, [&#x27;PM_Caotangsi&#x27;, &#x27;PM_Shahepu&#x27;]].mean(axis=1)df_gz[&#x27;PM_mean_CN&#x27;] = df_gz.loc[:, [&#x27;PM_City Station&#x27;, &#x27;PM_5th Middle School&#x27;]].mean(axis=1)df_sy[&#x27;PM_mean_CN&#x27;] = df_sy.loc[:, [&#x27;PM_Taiyuanjie&#x27;, &#x27;PM_Xiaoheyan&#x27;]].mean(axis=1) 绘制5个城市6年PM2.5均值的地理分布图(geo_map.py) 删除每个城市中国的测点和美国测点PM2.5的平均值中的 Nan 值 12345bj_PM_mean = pursue_mean.df_bj.loc[pursue_mean.df_bj[&#x27;PM_mean&#x27;].notnull(), [&#x27;PM_mean&#x27;]].mean()sh_PM_mean = pursue_mean.df_sh.loc[pursue_mean.df_sh[&#x27;PM_mean&#x27;].notnull(), [&#x27;PM_mean&#x27;]].mean()cd_PM_mean = pursue_mean.df_cd.loc[pursue_mean.df_cd[&#x27;PM_mean&#x27;].notnull(), [&#x27;PM_mean&#x27;]].mean()gz_PM_mean = pursue_mean.df_gz.loc[pursue_mean.df_gz[&#x27;PM_mean&#x27;].notnull(), [&#x27;PM_mean&#x27;]].mean()sy_PM_mean = pursue_mean.df_sy.loc[pursue_mean.df_sy[&#x27;PM_mean&#x27;].notnull(), [&#x27;PM_mean&#x27;]].mean() 创建地理分布图 1234567891011# 创建地理分布图districts = [&#x27;北京&#x27;, &#x27;上海&#x27;, &#x27;成都&#x27;, &#x27;广州&#x27;, &#x27;沈阳&#x27;]geo = Geo()geo.add_schema(maptype=&#x27;china&#x27;)geo.add(&#x27;五大城市PM2.5均值&#x27;, [(&#x27;北京&#x27;, bj_PM_mean.PM_mean), (&#x27;上海&#x27;, sh_PM_mean.PM_mean), (&#x27;成都&#x27;, cd_PM_mean.PM_mean), (&#x27;广州&#x27;, gz_PM_mean.PM_mean), (&#x27;沈阳&#x27;, sy_PM_mean.PM_mean)], type_=&quot;effectScatter&quot;, is_selected=True)geo.set_series_opts(label_opts=opts.LabelOpts(is_show=False))geo.set_global_opts(visualmap_opts=opts.VisualMapOpts(is_piecewise=True), title_opts=opts.TitleOpts(&#x27;五个城市PM2.5均值&#x27;))geo.render(&#x27;./picture/PM2.5map.html&#x27;) 得到下图 可以看出，偏北方的城市空气质量有待提高 绘制5个城市逐年PM2.5平均值折线图(per_year_PM2.5.py) 按照年分组 &amp;&amp; 排除缺失数据 1234567891011121314bj_year_PM_mean = pursue_mean.df_bj.loc[pursue_mean.df_bj[&#x27;PM_mean&#x27;].notnull(), [&#x27;PM_mean&#x27;]]. \\ groupby(pursue_mean.df_bj[&#x27;year&#x27;]).mean()sh_year_PM_mean = pursue_mean.df_sh.loc[pursue_mean.df_sh[&#x27;PM_mean&#x27;].notnull(), [&#x27;PM_mean&#x27;]]. \\ groupby(pursue_mean.df_sh[&#x27;year&#x27;]).mean()cd_year_PM_mean = pursue_mean.df_cd.loc[pursue_mean.df_cd[&#x27;PM_mean&#x27;].notnull(), [&#x27;PM_mean&#x27;]]. \\ groupby(pursue_mean.df_cd[&#x27;year&#x27;]).mean()gz_year_PM_mean = pursue_mean.df_gz.loc[pursue_mean.df_gz[&#x27;PM_mean&#x27;].notnull(), [&#x27;PM_mean&#x27;]]. \\ groupby(pursue_mean.df_gz[&#x27;year&#x27;]).mean()sy_year_PM_mean = pursue_mean.df_sy.loc[pursue_mean.df_sy[&#x27;PM_mean&#x27;].notnull(), [&#x27;PM_mean&#x27;]]. \\ groupby(pursue_mean.df_sy[&#x27;year&#x27;]).mean() 绘制5大城市逐年PM2.5均值折线图 1234567891011121314151617181920212223242526272829303132333435363738394041424344plt.rcParams[&#x27;font.sans-serif&#x27;] = [&#x27;SimHei&#x27;] # 如果要显示中文字体,则在此处设为：SimHeiplt.rcParams[&#x27;axes.unicode_minus&#x27;] = False # 显示负号x = np.array([i for i in range(2010, 2016)])BeiJing = np.array(bj_year_PM_mean.values)ShangHai = np.array(np.insert(sh_year_PM_mean.values, 0, [np.nan]))ChengDu= np.array(np.insert(cd_year_PM_mean.values, 0, [np.nan, np.nan]))GuangZhou = np.array(np.insert(gz_year_PM_mean.values, 0, [np.nan]))ShenYang = np.array(np.insert(sy_year_PM_mean.values, 0, [np.nan, np.nan, np.nan]))# label在图示(legend)中显示。若为数学公式,则最好在字符串前后添加&quot;$&quot;符号# color：b:blue、g:green、r:red、c:cyan、m:magenta、y:yellow、k:black、w:white、、、# 线型：- -- -. : ,# marker：. , o v &lt; * + 1plt.figure(figsize=(10, 5))plt.grid(linestyle=&quot;--&quot;) # 设置背景网格线为虚线ax = plt.gca()ax.spines[&#x27;top&#x27;].set_visible(False) # 去掉上边框ax.spines[&#x27;right&#x27;].set_visible(False) # 去掉右边框plt.plot(x, BeiJing, marker=&#x27;o&#x27;, color=&quot;blue&quot;, label=&quot;北京&quot;, linewidth=1.5)plt.plot(x, ShangHai, marker=&#x27;o&#x27;, color=&quot;green&quot;, label=&quot;上海&quot;, linewidth=1.5)plt.plot(x, ChengDu, marker=&#x27;o&#x27;, color=&quot;red&quot;, label=&quot;成都&quot;, linewidth=1.5)plt.plot(x, GuangZhou, marker=&#x27;o&#x27;, color=&quot;magenta&quot;, label=&quot;广州&quot;, linewidth=1.5)plt.plot(x, ShenYang, marker=&#x27;o&#x27;, color=&quot;black&quot;, label=&quot;沈阳&quot;, linewidth=1.5)group_labels = [&#x27;2010年&#x27;, &#x27;2011年&#x27;, &#x27;2012年&#x27;, &#x27;2013年&#x27;, &#x27;2014年&#x27;, &#x27;2015年&#x27;] # x轴刻度的标识plt.xticks(x, group_labels, fontsize=12, fontweight=&#x27;bold&#x27;) # 默认字体大小为10plt.yticks(fontsize=12, fontweight=&#x27;bold&#x27;)plt.title(&quot;五大城市PM2.5均值逐年变化&quot;, fontsize=12, fontweight=&#x27;bold&#x27;) # 默认字体大小为12plt.xlabel(&quot;年份&quot;, fontsize=13, fontweight=&#x27;bold&#x27;)plt.ylabel(&quot;PM2.5均值&quot;, fontsize=13, fontweight=&#x27;bold&#x27;)plt.xlim(2009, 2016) # 设置x轴的范围plt.ylim(30, 120)# plt.legend() #显示各曲线的图例plt.legend(loc=0, numpoints=1)leg = plt.gca().get_legend()ltext = leg.get_texts()plt.setp(ltext, fontsize=12, fontweight=&#x27;bold&#x27;) # 设置图例字体的大小和粗细plt.savefig(&#x27;./picture/year_line_graph.jpg&#x27;) # 建议保存为svg格式,再用inkscape转为矢量图emf后插入word中plt.show() 可以看出北京的空气质量持续偏高，广州和上海较低，但总体是下降趋势， 北京的检测数量最全，6年数据全都有，沈阳仅有2年的数据 PM2.5随季节变化的折线图(season_PM25_line.py) 按照季节分组 &amp;&amp; 排除缺失数据 123456789101112131415161718import pursue_meanimport matplotlib.pyplot as pltimport numpy as npbj_season_PM_mean = pursue_mean.df_bj.loc[pursue_mean.df_bj[&#x27;PM_mean&#x27;].notnull(), [&#x27;PM_mean&#x27;]]. \\ groupby(pursue_mean.df_bj[&#x27;season&#x27;]).mean()sh_season_PM_mean = pursue_mean.df_sh.loc[pursue_mean.df_sh[&#x27;PM_mean&#x27;].notnull(), [&#x27;PM_mean&#x27;]]. \\ groupby(pursue_mean.df_sh[&#x27;season&#x27;]).mean()cd_season_PM_mean = pursue_mean.df_cd.loc[pursue_mean.df_cd[&#x27;PM_mean&#x27;].notnull(), [&#x27;PM_mean&#x27;]]. \\ groupby(pursue_mean.df_cd[&#x27;season&#x27;]).mean()gz_season_PM_mean = pursue_mean.df_gz.loc[pursue_mean.df_gz[&#x27;PM_mean&#x27;].notnull(), [&#x27;PM_mean&#x27;]]. \\ groupby(pursue_mean.df_gz[&#x27;season&#x27;]).mean()sy_season_PM_mean = pursue_mean.df_sy.loc[pursue_mean.df_sy[&#x27;PM_mean&#x27;].notnull(), [&#x27;PM_mean&#x27;]]. \\ groupby(pursue_mean.df_sy[&#x27;season&#x27;]).mean() 绘制季节折线图 1234567891011121314151617181920212223242526272829303132333435363738394041424344plt.rcParams[&#x27;font.sans-serif&#x27;] = [&#x27;SimHei&#x27;] # 如果要显示中文字体,则在此处设为：SimHeiplt.rcParams[&#x27;axes.unicode_minus&#x27;] = False # 显示负号x = np.array([i for i in range(1, 5)])BeiJing = np.array(bj_season_PM_mean.values)ShangHai = np.array(sh_season_PM_mean.values)ChengDu= np.array(cd_season_PM_mean.values)GuangZhou = np.array(gz_season_PM_mean.values)ShenYang = np.array(sy_season_PM_mean.values)# label在图示(legend)中显示。若为数学公式,则最好在字符串前后添加&quot;$&quot;符号# color：b:blue、g:green、r:red、c:cyan、m:magenta、y:yellow、k:black、w:white、、、# 线型：- -- -. : ,# marker：. , o v &lt; * + 1plt.figure(figsize=(10, 5))plt.grid(linestyle=&quot;--&quot;) # 设置背景网格线为虚线ax = plt.gca()ax.spines[&#x27;top&#x27;].set_visible(False) # 去掉上边框ax.spines[&#x27;right&#x27;].set_visible(False) # 去掉右边框plt.plot(x, BeiJing, marker=&#x27;o&#x27;, color=&quot;blue&quot;, label=&quot;北京&quot;, linewidth=1.5)plt.plot(x, ShangHai, marker=&#x27;o&#x27;, color=&quot;green&quot;, label=&quot;上海&quot;, linewidth=1.5)plt.plot(x, ChengDu, marker=&#x27;o&#x27;, color=&quot;red&quot;, label=&quot;成都&quot;, linewidth=1.5)plt.plot(x, GuangZhou, marker=&#x27;o&#x27;, color=&quot;magenta&quot;, label=&quot;广州&quot;, linewidth=1.5)plt.plot(x, ShenYang, marker=&#x27;o&#x27;, color=&quot;black&quot;, label=&quot;沈阳&quot;, linewidth=1.5)group_labels = [&#x27;第1季度&#x27;, &#x27;第2季度&#x27;, &#x27;第3季度&#x27;, &#x27;第4季度&#x27;] # x轴刻度的标识plt.xticks(x, group_labels, fontsize=12, fontweight=&#x27;bold&#x27;) # 默认字体大小为10plt.yticks(fontsize=12, fontweight=&#x27;bold&#x27;)plt.title(&quot;五大城市PM2.5均值逐季度变化&quot;, fontsize=12, fontweight=&#x27;bold&#x27;) # 默认字体大小为12plt.xlabel(&quot;季度&quot;, fontsize=13, fontweight=&#x27;bold&#x27;)plt.ylabel(&quot;PM2.5均值&quot;, fontsize=13, fontweight=&#x27;bold&#x27;)plt.xlim(0, 6) # 设置x轴的范围plt.ylim(20, 140)# plt.legend() #显示各曲线的图例plt.legend(loc=0, numpoints=1)leg = plt.gca().get_legend()ltext = leg.get_texts()plt.setp(ltext, fontsize=12, fontweight=&#x27;bold&#x27;) # 设置图例字体的大小和粗细plt.savefig(&#x27;./picture/season_line_graph.jpg&#x27;) # 建议保存为svg格式,再用inkscape转为矢量图emf后插入word中plt.show() 从图中可以看出，第2季度也就是夏季的空气质量最好，第4季度也就是冬季空气质量最差。 该结论对5个城市具有普适性 PM2.5随季节变化的柱状图(season_PM25_bar.py) 可以直接借助绘制PM2.5随季节变化的折线图的数据绘制柱状图 绘制柱状图 123456789101112131415161718192021222324from pyecharts import options as optsfrom pyecharts.charts import Barfrom pyecharts.globals import ThemeTypefrom itertools import chainfrom season_PM25_line import bj_season_PM_mean, sh_season_PM_mean, cd_season_PM_mean, gz_season_PM_mean, \\ sy_season_PM_meanc = ( Bar(&#123;&quot;theme&quot;: ThemeType.MACARONS&#125;) .add_xaxis([&#x27;第1季度&#x27;, &#x27;第2季度&#x27;, &#x27;第3季度&#x27;, &#x27;第4季度&#x27;]) .add_yaxis(series_name=&#x27;北京&#x27;, y_axis=[int(i) for i in list(chain.from_iterable(bj_season_PM_mean.values.tolist()))]) .add_yaxis(series_name=&#x27;上海&#x27;, y_axis=[int(i) for i in list(chain.from_iterable(sh_season_PM_mean.values.tolist()))]) .add_yaxis(series_name=&#x27;成都&#x27;, y_axis=[int(i) for i in list(chain.from_iterable(cd_season_PM_mean.values.tolist()))]) .add_yaxis(series_name=&#x27;广州&#x27;, y_axis=[int(i) for i in list(chain.from_iterable(gz_season_PM_mean.values.tolist()))]) .add_yaxis(series_name=&#x27;沈阳&#x27;, y_axis=[int(i) for i in list(chain.from_iterable(sy_season_PM_mean.values.tolist()))]) .set_series_opts(label_opts=opts.LabelOpts(is_show=True)) .set_global_opts( title_opts=opts.TitleOpts(title=&quot;季节对PM2.5的影响&quot;), xaxis_opts=opts.AxisOpts(name=&#x27;季节&#x27;, name_location=&#x27;middle&#x27;, name_gap=30), yaxis_opts=opts.AxisOpts(name=&#x27;PM2.5&#x27;, name_location=&#x27;middle&#x27;, name_gap=30), toolbox_opts=opts.ToolboxOpts() ) .render(&#x27;./picture/season_bar_graph.html&#x27;)) 累计风速对PM2.5的影响散点图(lws_scatter.py) 先将风速按顺序排序 12345bj_lws = pursue_mean.df_bj[&#x27;Iws&#x27;].sort_values()sh_lws = pursue_mean.df_sh[&#x27;Iws&#x27;].sort_values()cd_lws = pursue_mean.df_cd[&#x27;Iws&#x27;].sort_values()gz_lws = pursue_mean.df_gz[&#x27;Iws&#x27;].sort_values()sy_lws = pursue_mean.df_sy[&#x27;Iws&#x27;].sort_values() 再按照风速排序索引出PM2.5均值 12345bj_PM = pursue_mean.df_bj.loc[bj_lws.index, &#x27;PM_mean&#x27;]sh_PM = pursue_mean.df_sh.loc[sh_lws.index, &#x27;PM_mean&#x27;]cd_PM = pursue_mean.df_cd.loc[cd_lws.index, &#x27;PM_mean&#x27;]gz_PM = pursue_mean.df_gz.loc[gz_lws.index, &#x27;PM_mean&#x27;]sy_PM = pursue_mean.df_sy.loc[sy_lws.index, &#x27;PM_mean&#x27;] 作散点图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155# ToDO BeiJing Scatter Graphbj_scatter = ( Scatter() .add_xaxis(xaxis_data=bj_lws.values) .add_yaxis( series_name=&#x27;PM2.5&#x27;, y_axis=bj_PM.values, symbol_size=5, label_opts=opts.LabelOpts(is_show=False) ) .set_series_opts() .set_global_opts( title_opts=opts.TitleOpts(title=&quot;合成风速对PM2.5的影响&quot;), xaxis_opts=opts.AxisOpts( name=&#x27;合成风速(m/s)&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&quot;value&quot;, splitline_opts=opts.SplitLineOpts(is_show=True) ), yaxis_opts=opts.AxisOpts( name=&#x27;PM2.5&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&#x27;value&#x27;, axistick_opts=opts.AxisTickOpts(is_show=True), splitline_opts=opts.SplitLineOpts(is_show=True) ), tooltip_opts=opts.ToolboxOpts(), visualmap_opts=opts.VisualMapOpts( type_=&quot;color&quot;, max_=800, min_=5, dimension=1 ) ))# ToDO ShangHai Scatter Graphsh_scatter = ( Scatter() .add_xaxis(xaxis_data=sh_lws.values) .add_yaxis( series_name=&#x27;PM2.5&#x27;, y_axis=sh_PM.values, symbol_size=5, label_opts=opts.LabelOpts(is_show=False) ) .set_series_opts() .set_global_opts( title_opts=opts.TitleOpts(title=&quot;合成风速对PM2.5的影响&quot;), xaxis_opts=opts.AxisOpts( name=&#x27;合成风速(m/s)&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&quot;value&quot;, splitline_opts=opts.SplitLineOpts(is_show=True) ), yaxis_opts=opts.AxisOpts( name=&#x27;PM2.5&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&#x27;value&#x27;, axistick_opts=opts.AxisTickOpts(is_show=True), splitline_opts=opts.SplitLineOpts(is_show=True) ), tooltip_opts=opts.ToolboxOpts(), visualmap_opts=opts.VisualMapOpts( type_=&quot;color&quot;, max_=800, min_=5, dimension=1 ) ))# ToDO ChengDu Scatter Graphcd_scatter = ( Scatter() .add_xaxis(xaxis_data=cd_lws.values) .add_yaxis( series_name=&#x27;PM2.5&#x27;, y_axis=cd_PM.values, symbol_size=5, label_opts=opts.LabelOpts(is_show=False) ) .set_series_opts() .set_global_opts( title_opts=opts.TitleOpts(title=&quot;合成风速对PM2.5的影响&quot;), xaxis_opts=opts.AxisOpts( name=&#x27;合成风速(m/s)&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&quot;value&quot;, splitline_opts=opts.SplitLineOpts(is_show=True) ), yaxis_opts=opts.AxisOpts( name=&#x27;PM2.5&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&#x27;value&#x27;, axistick_opts=opts.AxisTickOpts(is_show=True), splitline_opts=opts.SplitLineOpts(is_show=True) ), tooltip_opts=opts.ToolboxOpts(), visualmap_opts=opts.VisualMapOpts( type_=&quot;color&quot;, max_=800, min_=5, dimension=1 ) ))# ToDO GuangZhou Scatter Graphgz_scatter = ( Scatter() .add_xaxis(xaxis_data=gz_lws.values) .add_yaxis( series_name=&#x27;PM2.5&#x27;, y_axis=gz_PM.values, symbol_size=5, label_opts=opts.LabelOpts(is_show=False) ) .set_series_opts() .set_global_opts( title_opts=opts.TitleOpts(title=&quot;合成风速对PM2.5的影响&quot;), xaxis_opts=opts.AxisOpts( name=&#x27;合成风速(m/s)&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&quot;value&quot;, splitline_opts=opts.SplitLineOpts(is_show=True) ), yaxis_opts=opts.AxisOpts( name=&#x27;PM2.5&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&#x27;value&#x27;, axistick_opts=opts.AxisTickOpts(is_show=True), splitline_opts=opts.SplitLineOpts(is_show=True) ), tooltip_opts=opts.ToolboxOpts(), visualmap_opts=opts.VisualMapOpts( type_=&quot;color&quot;, max_=800, min_=5, dimension=1 ) ))# ToDO ShenYang Scatter Graphsy_scatter = ( Scatter() .add_xaxis(xaxis_data=sy_lws.values) .add_yaxis( series_name=&#x27;PM2.5&#x27;, y_axis=sy_PM.values, symbol_size=5, label_opts=opts.LabelOpts(is_show=False) ) .set_series_opts() .set_global_opts( title_opts=opts.TitleOpts(title=&quot;合成风速对PM2.5的影响&quot;), xaxis_opts=opts.AxisOpts( name=&#x27;合成风速(m/s)&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&quot;value&quot;, splitline_opts=opts.SplitLineOpts(is_show=True) ), yaxis_opts=opts.AxisOpts( name=&#x27;PM2.5&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&#x27;value&#x27;, axistick_opts=opts.AxisTickOpts(is_show=True), splitline_opts=opts.SplitLineOpts(is_show=True) ), tooltip_opts=opts.ToolboxOpts(), visualmap_opts=opts.VisualMapOpts( type_=&quot;color&quot;, max_=800, min_=5, dimension=1 ) ))bj_scatter.render(&#x27;./picture/wind_speed_scatter/BeiJing.html&#x27;)sh_scatter.render(&#x27;./picture/wind_speed_scatter/ShangHai.html&#x27;)cd_scatter.render(&#x27;./picture/wind_speed_scatter/ChengDu.html&#x27;)gz_scatter.render(&#x27;./picture/wind_speed_scatter/GuangZhou.html&#x27;)sy_scatter.render(&#x27;./picture/wind_speed_scatter/ShenYang.html&#x27;) 北京 成都 广州 上海 沈阳 相对湿度对PM2.5的影响散点图(humidity_scatter.py) 先将湿度按顺序排序 123456789101112import pursue_meanfrom pyecharts.charts import Scatterfrom pyecharts import options as opts# pursue_mean.df_bj.info()bj_humid = pursue_mean.df_bj[&#x27;HUMI&#x27;].sort_values()sh_humid = pursue_mean.df_sh[&#x27;HUMI&#x27;].sort_values()cd_humid = pursue_mean.df_cd[&#x27;HUMI&#x27;].sort_values()gz_humid = pursue_mean.df_gz[&#x27;HUMI&#x27;].sort_values()# gz_humid = pursue_mean.df_gz.loc[pursue_mean.df_gz[&#x27;HUMI&#x27;].notnull(), [&#x27;HUMI&#x27;]].sort_values(&#x27;HUMI&#x27;)sy_humid = pursue_mean.df_sy[&#x27;HUMI&#x27;].sort_values() 再按照湿度排序索引出PM2.5均值 12345bj_PM_humid = pursue_mean.df_bj.loc[bj_humid.index, &#x27;PM_mean&#x27;]sh_PM_humid = pursue_mean.df_sh.loc[sh_humid.index, &#x27;PM_mean&#x27;]cd_PM_humid = pursue_mean.df_cd.loc[cd_humid.index, &#x27;PM_mean&#x27;]gz_PM_humid = pursue_mean.df_gz.loc[gz_humid.index, &#x27;PM_mean&#x27;]sy_PM_humid = pursue_mean.df_sy.loc[sy_humid.index, &#x27;PM_mean&#x27;] 作散点图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157# ToDO BeiJing Scatter Graphbj_humid_scatter = ( Scatter() .add_xaxis(xaxis_data=bj_humid.values) .add_yaxis( series_name=&#x27;PM2.5&#x27;, y_axis=bj_PM_humid.values, symbol_size=5, label_opts=opts.LabelOpts(is_show=False) ) .set_series_opts() .set_global_opts( title_opts=opts.TitleOpts(title=&quot;湿度对PM2.5的影响&quot;), xaxis_opts=opts.AxisOpts( name=&#x27;湿度(%)&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&quot;value&quot;, splitline_opts=opts.SplitLineOpts(is_show=True) ), yaxis_opts=opts.AxisOpts( name=&#x27;PM2.5&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&#x27;value&#x27;, axistick_opts=opts.AxisTickOpts(is_show=True), splitline_opts=opts.SplitLineOpts(is_show=True) ), tooltip_opts=opts.ToolboxOpts(), visualmap_opts=opts.VisualMapOpts( type_=&quot;color&quot;, max_=800, min_=5, dimension=1 ) ))# ToDO ShangHai Scatter Graphsh_humid_scatter = ( Scatter() .add_xaxis(xaxis_data=sh_humid.values) .add_yaxis( series_name=&#x27;PM2.5&#x27;, y_axis=sh_PM_humid.values, symbol_size=5, label_opts=opts.LabelOpts(is_show=False) ) .set_series_opts() .set_global_opts( title_opts=opts.TitleOpts(title=&quot;湿度对PM2.5的影响&quot;), xaxis_opts=opts.AxisOpts( name=&#x27;湿度(%)&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&quot;value&quot;, splitline_opts=opts.SplitLineOpts(is_show=True) ), yaxis_opts=opts.AxisOpts( name=&#x27;PM2.5&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&#x27;value&#x27;, axistick_opts=opts.AxisTickOpts(is_show=True), splitline_opts=opts.SplitLineOpts(is_show=True) ), tooltip_opts=opts.ToolboxOpts(), visualmap_opts=opts.VisualMapOpts( type_=&quot;color&quot;, max_=800, min_=5, dimension=1 ) ))# ToDO ChengDu Scatter Graphcd_humid_scatter = ( Scatter() .add_xaxis(xaxis_data=cd_humid.values) .add_yaxis( series_name=&#x27;PM2.5&#x27;, y_axis=cd_PM_humid.values, symbol_size=5, label_opts=opts.LabelOpts(is_show=False) ) .set_series_opts() .set_global_opts( title_opts=opts.TitleOpts(title=&quot;湿度对PM2.5的影响&quot;), xaxis_opts=opts.AxisOpts( name=&#x27;湿度(%)&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&quot;value&quot;, splitline_opts=opts.SplitLineOpts(is_show=True) ), yaxis_opts=opts.AxisOpts( name=&#x27;PM2.5&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&#x27;value&#x27;, axistick_opts=opts.AxisTickOpts(is_show=True), splitline_opts=opts.SplitLineOpts(is_show=True) ), tooltip_opts=opts.ToolboxOpts(), visualmap_opts=opts.VisualMapOpts( type_=&quot;color&quot;, max_=800, min_=5, dimension=1 ) ))# ToDO GuangZhou Scatter Graphgz_humid_scatter = ( Scatter() .add_xaxis(xaxis_data=gz_humid.values) .add_yaxis( series_name=&#x27;PM2.5&#x27;, y_axis=gz_PM_humid.values, symbol_size=5, label_opts=opts.LabelOpts(is_show=False) ) .set_series_opts() .set_global_opts( title_opts=opts.TitleOpts(title=&quot;湿度对PM2.5的影响&quot;), xaxis_opts=opts.AxisOpts( name=&#x27;湿度(%)&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&quot;value&quot;, splitline_opts=opts.SplitLineOpts(is_show=True), min_=0, max_=100 ), yaxis_opts=opts.AxisOpts( name=&#x27;PM2.5&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&#x27;value&#x27;, axistick_opts=opts.AxisTickOpts(is_show=True), splitline_opts=opts.SplitLineOpts(is_show=True) ), tooltip_opts=opts.ToolboxOpts(), visualmap_opts=opts.VisualMapOpts( type_=&quot;color&quot;, max_=800, min_=5, dimension=1 ) ))# ToDO ShenYang Scatter Graphsy_humid_scatter = ( Scatter() .add_xaxis(xaxis_data=sy_humid.values) .add_yaxis( series_name=&#x27;PM2.5&#x27;, y_axis=sy_PM_humid.values, symbol_size=5, label_opts=opts.LabelOpts(is_show=False) ) .set_series_opts() .set_global_opts( title_opts=opts.TitleOpts(title=&quot;湿度对PM2.5的影响&quot;), xaxis_opts=opts.AxisOpts( name=&#x27;湿度(%)&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&quot;value&quot;, splitline_opts=opts.SplitLineOpts(is_show=True) ), yaxis_opts=opts.AxisOpts( name=&#x27;PM2.5&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&#x27;value&#x27;, axistick_opts=opts.AxisTickOpts(is_show=True), splitline_opts=opts.SplitLineOpts(is_show=True) ), tooltip_opts=opts.ToolboxOpts(), visualmap_opts=opts.VisualMapOpts( type_=&quot;color&quot;, max_=800, min_=5, dimension=1 ) ))bj_humid_scatter.render(&#x27;./picture/humidity_scatter/humid_BeiJing.html&#x27;)sh_humid_scatter.render(&#x27;./picture/humidity_scatter/humid_ShangHai.html&#x27;)cd_humid_scatter.render(&#x27;./picture/humidity_scatter/humid_ChengDu.html&#x27;)gz_humid_scatter.render(&#x27;./picture/humidity_scatter/humid_GuangZhou.html&#x27;)sy_humid_scatter.render(&#x27;./picture/humidity_scatter/humid_ShenYang.html&#x27;) 北京 成都 广州 上海 沈阳 气压对PM2.5的影响散点图(pressure_scatter.py) 先将气压按顺序排序 123456789import pursue_meanfrom pyecharts.charts import Scatterfrom pyecharts import options as optsbj_pres = pursue_mean.df_bj[&#x27;PRES&#x27;].sort_values()sh_pres = pursue_mean.df_sh[&#x27;PRES&#x27;].sort_values()cd_pres = pursue_mean.df_cd[&#x27;PRES&#x27;].sort_values()gz_pres = pursue_mean.df_gz[&#x27;PRES&#x27;].sort_values()sy_pres = pursue_mean.df_sy[&#x27;PRES&#x27;].sort_values() 再按照气压排序索引出PM2.5均值 12345bj_PM_pres = pursue_mean.df_bj.loc[bj_pres.index, &#x27;PM_mean&#x27;]sh_PM_pres = pursue_mean.df_sh.loc[sh_pres.index, &#x27;PM_mean&#x27;]cd_PM_pres = pursue_mean.df_cd.loc[cd_pres.index, &#x27;PM_mean&#x27;]gz_PM_pres = pursue_mean.df_gz.loc[gz_pres.index, &#x27;PM_mean&#x27;]sy_PM_pres = pursue_mean.df_sy.loc[sy_pres.index, &#x27;PM_mean&#x27;] 作散点图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162# ToDO BeiJing Scatter Graphbj_pressure_scatter = ( Scatter() .add_xaxis(xaxis_data=bj_pres.values) .add_yaxis( series_name=&#x27;PM2.5&#x27;, y_axis=bj_PM_pres.values, symbol_size=5, label_opts=opts.LabelOpts(is_show=False) ) .set_series_opts() .set_global_opts( title_opts=opts.TitleOpts(title=&quot;气压对PM2.5的影响&quot;), xaxis_opts=opts.AxisOpts( name=&#x27;气压(hpa)&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&quot;value&quot;, splitline_opts=opts.SplitLineOpts(is_show=True), min_=990 ), yaxis_opts=opts.AxisOpts( name=&#x27;PM2.5&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&#x27;value&#x27;, axistick_opts=opts.AxisTickOpts(is_show=True), splitline_opts=opts.SplitLineOpts(is_show=True) ), tooltip_opts=opts.ToolboxOpts(), visualmap_opts=opts.VisualMapOpts( type_=&quot;color&quot;, max_=800, min_=5, dimension=1 ) ))# ToDO ShangHai Scatter Graphsh_pressure_scatter = ( Scatter() .add_xaxis(xaxis_data=sh_pres.values) .add_yaxis( series_name=&#x27;PM2.5&#x27;, y_axis=sh_PM_pres.values, symbol_size=5, label_opts=opts.LabelOpts(is_show=False) ) .set_series_opts() .set_global_opts( title_opts=opts.TitleOpts(title=&quot;气压对PM2.5的影响&quot;), xaxis_opts=opts.AxisOpts( name=&#x27;气压(hpa)&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&quot;value&quot;, splitline_opts=opts.SplitLineOpts(is_show=True), min_=987, max_=1042 ), yaxis_opts=opts.AxisOpts( name=&#x27;PM2.5&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&#x27;value&#x27;, axistick_opts=opts.AxisTickOpts(is_show=True), splitline_opts=opts.SplitLineOpts(is_show=True) ), tooltip_opts=opts.ToolboxOpts(), visualmap_opts=opts.VisualMapOpts( type_=&quot;color&quot;, max_=800, min_=5, dimension=1 ) ))# ToDO ChengDu Scatter Graphcd_pressure_scatter = ( Scatter() .add_xaxis(xaxis_data=cd_pres.values) .add_yaxis( series_name=&#x27;PM2.5&#x27;, y_axis=cd_PM_pres.values, symbol_size=5, label_opts=opts.LabelOpts(is_show=False) ) .set_series_opts() .set_global_opts( title_opts=opts.TitleOpts(title=&quot;气压对PM2.5的影响&quot;), xaxis_opts=opts.AxisOpts( name=&#x27;气压(hpa)&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&quot;value&quot;, splitline_opts=opts.SplitLineOpts(is_show=True), min_=990 ), yaxis_opts=opts.AxisOpts( name=&#x27;PM2.5&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&#x27;value&#x27;, axistick_opts=opts.AxisTickOpts(is_show=True), splitline_opts=opts.SplitLineOpts(is_show=True) ), tooltip_opts=opts.ToolboxOpts(), visualmap_opts=opts.VisualMapOpts( type_=&quot;color&quot;, max_=800, min_=5, dimension=1 ) ))# ToDO GuangZhou Scatter Graphgz_pressure_scatter = ( Scatter() .add_xaxis(xaxis_data=gz_pres.values) .add_yaxis( series_name=&#x27;PM2.5&#x27;, y_axis=gz_PM_pres.values, symbol_size=5, label_opts=opts.LabelOpts(is_show=False) ) .set_series_opts() .set_global_opts( title_opts=opts.TitleOpts(title=&quot;气压对PM2.5的影响&quot;), xaxis_opts=opts.AxisOpts( name=&#x27;气压(hpa)&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&quot;value&quot;, splitline_opts=opts.SplitLineOpts(is_show=True), min_=974 ), yaxis_opts=opts.AxisOpts( name=&#x27;PM2.5&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&#x27;value&#x27;, axistick_opts=opts.AxisTickOpts(is_show=True), splitline_opts=opts.SplitLineOpts(is_show=True) ), tooltip_opts=opts.ToolboxOpts(), visualmap_opts=opts.VisualMapOpts( type_=&quot;color&quot;, max_=800, min_=5, dimension=1 ) ))# ToDO ShenYang Scatter Graphsy_pressure_scatter = ( Scatter() .add_xaxis(xaxis_data=sy_pres.values) .add_yaxis( series_name=&#x27;PM2.5&#x27;, y_axis=sy_PM_pres.values, symbol_size=5, label_opts=opts.LabelOpts(is_show=False) ) .set_series_opts() .set_global_opts( title_opts=opts.TitleOpts(title=&quot;气压对PM2.5的影响&quot;), xaxis_opts=opts.AxisOpts( name=&#x27;气压(hpa)&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&quot;value&quot;, splitline_opts=opts.SplitLineOpts(is_show=True), min_=985, max_=1045 ), yaxis_opts=opts.AxisOpts( name=&#x27;PM2.5&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&#x27;value&#x27;, axistick_opts=opts.AxisTickOpts(is_show=True), splitline_opts=opts.SplitLineOpts(is_show=True) ), tooltip_opts=opts.ToolboxOpts(), visualmap_opts=opts.VisualMapOpts( type_=&quot;color&quot;, max_=800, min_=5, dimension=1 ) ))bj_pressure_scatter.render(&#x27;./picture/pressure_scatter/pressure_BeiJing.html&#x27;)sh_pressure_scatter.render(&#x27;./picture/pressure_scatter/pressure_ShangHai.html&#x27;)cd_pressure_scatter.render(&#x27;./picture/pressure_scatter/pressure_ChengDu.html&#x27;)gz_pressure_scatter.render(&#x27;./picture/pressure_scatter/pressure_GuangZhou.html&#x27;)sy_pressure_scatter.render(&#x27;./picture/pressure_scatter/pressure_ShenYang.html&#x27;) 北京 成都 广州 上海 沈阳 温度对PM2.5的影响散点图(temperature_scatter.py) 先将温度按顺序排序 123456789import pursue_meanfrom pyecharts.charts import Scatterfrom pyecharts import options as optsbj_temp = pursue_mean.df_bj[&#x27;TEMP&#x27;].sort_values()sh_temp = pursue_mean.df_sh[&#x27;TEMP&#x27;].sort_values()cd_temp = pursue_mean.df_cd[&#x27;TEMP&#x27;].sort_values()gz_temp = pursue_mean.df_gz[&#x27;TEMP&#x27;].sort_values()sy_temp = pursue_mean.df_sy[&#x27;TEMP&#x27;].sort_values() 再按照温度排序索引出PM2.5均值 12345bj_PM_temp = pursue_mean.df_bj.loc[bj_temp.index, &#x27;PM_mean&#x27;]sh_PM_temp = pursue_mean.df_sh.loc[sh_temp.index, &#x27;PM_mean&#x27;]cd_PM_temp = pursue_mean.df_cd.loc[cd_temp.index, &#x27;PM_mean&#x27;]gz_PM_temp = pursue_mean.df_gz.loc[gz_temp.index, &#x27;PM_mean&#x27;]sy_PM_temp = pursue_mean.df_sy.loc[sy_temp.index, &#x27;PM_mean&#x27;] 作散点图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155# TODO BeiJing Scatter Graphbj_temp_scatter = ( Scatter() .add_xaxis(xaxis_data=bj_temp.values) .add_yaxis( series_name=&#x27;PM2.5&#x27;, y_axis=bj_PM_temp.values, symbol_size=5, label_opts=opts.LabelOpts(is_show=False) ) .set_series_opts() .set_global_opts( title_opts=opts.TitleOpts(title=&quot;温度对PM2.5的影响&quot;), xaxis_opts=opts.AxisOpts( name=&#x27;温度(℃)&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&quot;value&quot;, splitline_opts=opts.SplitLineOpts(is_show=True) ), yaxis_opts=opts.AxisOpts( name=&#x27;PM2.5&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&#x27;value&#x27;, axistick_opts=opts.AxisTickOpts(is_show=True), splitline_opts=opts.SplitLineOpts(is_show=True) ), tooltip_opts=opts.ToolboxOpts(), visualmap_opts=opts.VisualMapOpts( type_=&quot;color&quot;, max_=800, min_=5, dimension=1 ) ))# ToDO ShangHai Scatter Graphsh_temp_scatter = ( Scatter() .add_xaxis(xaxis_data=sh_temp.values) .add_yaxis( series_name=&#x27;PM2.5&#x27;, y_axis=sh_PM_temp.values, symbol_size=5, label_opts=opts.LabelOpts(is_show=False) ) .set_series_opts() .set_global_opts( title_opts=opts.TitleOpts(title=&quot;温度对PM2.5的影响&quot;), xaxis_opts=opts.AxisOpts( name=&#x27;温度(℃)&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&quot;value&quot;, splitline_opts=opts.SplitLineOpts(is_show=True) ), yaxis_opts=opts.AxisOpts( name=&#x27;PM2.5&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&#x27;value&#x27;, axistick_opts=opts.AxisTickOpts(is_show=True), splitline_opts=opts.SplitLineOpts(is_show=True) ), tooltip_opts=opts.ToolboxOpts(), visualmap_opts=opts.VisualMapOpts( type_=&quot;color&quot;, max_=800, min_=5, dimension=1 ) ))# ToDO ChengDu Scatter Graphcd_temp_scatter = ( Scatter() .add_xaxis(xaxis_data=cd_temp.values) .add_yaxis( series_name=&#x27;PM2.5&#x27;, y_axis=cd_PM_temp.values, symbol_size=5, label_opts=opts.LabelOpts(is_show=False) ) .set_series_opts() .set_global_opts( title_opts=opts.TitleOpts(title=&quot;温度对PM2.5的影响&quot;), xaxis_opts=opts.AxisOpts( name=&#x27;温度(℃)&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&quot;value&quot;, splitline_opts=opts.SplitLineOpts(is_show=True) ), yaxis_opts=opts.AxisOpts( name=&#x27;PM2.5&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&#x27;value&#x27;, axistick_opts=opts.AxisTickOpts(is_show=True), splitline_opts=opts.SplitLineOpts(is_show=True) ), tooltip_opts=opts.ToolboxOpts(), visualmap_opts=opts.VisualMapOpts( type_=&quot;color&quot;, max_=800, min_=5, dimension=1 ) ))# ToDO GuangZhou Scatter Graphgz_temp_scatter = ( Scatter() .add_xaxis(xaxis_data=gz_temp.values) .add_yaxis( series_name=&#x27;PM2.5&#x27;, y_axis=gz_PM_temp.values, symbol_size=5, label_opts=opts.LabelOpts(is_show=False) ) .set_series_opts() .set_global_opts( title_opts=opts.TitleOpts(title=&quot;温度对PM2.5的影响&quot;), xaxis_opts=opts.AxisOpts( name=&#x27;温度(℃)&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&quot;value&quot;, splitline_opts=opts.SplitLineOpts(is_show=True) ), yaxis_opts=opts.AxisOpts( name=&#x27;PM2.5&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&#x27;value&#x27;, axistick_opts=opts.AxisTickOpts(is_show=True), splitline_opts=opts.SplitLineOpts(is_show=True) ), tooltip_opts=opts.ToolboxOpts(), visualmap_opts=opts.VisualMapOpts( type_=&quot;color&quot;, max_=800, min_=5, dimension=1 ) ))# ToDO ShenYang Scatter Graphsy_temp_scatter = ( Scatter() .add_xaxis(xaxis_data=sy_temp.values) .add_yaxis( series_name=&#x27;PM2.5&#x27;, y_axis=sy_PM_temp.values, symbol_size=5, label_opts=opts.LabelOpts(is_show=False) ) .set_series_opts() .set_global_opts( title_opts=opts.TitleOpts(title=&quot;温度对PM2.5的影响&quot;), xaxis_opts=opts.AxisOpts( name=&#x27;温度(℃)&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&quot;value&quot;, splitline_opts=opts.SplitLineOpts(is_show=True) ), yaxis_opts=opts.AxisOpts( name=&#x27;PM2.5&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&#x27;value&#x27;, axistick_opts=opts.AxisTickOpts(is_show=True), splitline_opts=opts.SplitLineOpts(is_show=True) ), tooltip_opts=opts.ToolboxOpts(), visualmap_opts=opts.VisualMapOpts( type_=&quot;color&quot;, max_=800, min_=5, dimension=1 ) ))bj_temp_scatter.render(&#x27;./picture/temperature_scatter/temperature_BeiJing.html&#x27;)sh_temp_scatter.render(&#x27;./picture/temperature_scatter/temperature_ShangHai.html&#x27;)cd_temp_scatter.render(&#x27;./picture/temperature_scatter/temperature_ChengDu.html&#x27;)gz_temp_scatter.render(&#x27;./picture/temperature_scatter/temperature_GuangZhou.html&#x27;)sy_temp_scatter.render(&#x27;./picture/temperature_scatter/temperature_ShenYang.html&#x27;) 北京 成都 广州 上海 沈阳 降水量对PM2.5的影响散点图(accum_precipitation_scatter.py) 先将降水量按顺序排序 123456789import pursue_meanfrom pyecharts.charts import Scatterfrom pyecharts import options as optsbj_precipitation = pursue_mean.df_bj[&#x27;Iprec&#x27;].sort_values()sh_precipitation = pursue_mean.df_sh[&#x27;Iprec&#x27;].sort_values()cd_precipitation = pursue_mean.df_cd[&#x27;Iprec&#x27;].sort_values()gz_precipitation = pursue_mean.df_gz[&#x27;Iprec&#x27;].sort_values()sy_precipitation = pursue_mean.df_sy[&#x27;Iprec&#x27;].sort_values() 再按照降水量排序索引出PM2.5均值 12345bj_PM_precipitation = pursue_mean.df_bj.loc[bj_precipitation.index, &#x27;PM_mean&#x27;]sh_PM_precipitation = pursue_mean.df_sh.loc[sh_precipitation.index, &#x27;PM_mean&#x27;]cd_PM_precipitation = pursue_mean.df_cd.loc[cd_precipitation.index, &#x27;PM_mean&#x27;]gz_PM_precipitation = pursue_mean.df_gz.loc[gz_precipitation.index, &#x27;PM_mean&#x27;]sy_PM_precipitation = pursue_mean.df_sy.loc[sy_precipitation.index, &#x27;PM_mean&#x27;] 作散点图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156# TODO BeiJing Scatter Graphbj_precipitation_scatter = ( Scatter() .add_xaxis(xaxis_data=bj_precipitation.values) .add_yaxis( series_name=&#x27;PM2.5&#x27;, y_axis=bj_PM_precipitation.values, symbol_size=5, label_opts=opts.LabelOpts(is_show=False) ) .set_series_opts() .set_global_opts( title_opts=opts.TitleOpts(title=&quot;累计降雨量对PM2.5的影响&quot;), xaxis_opts=opts.AxisOpts( name=&#x27;累计降雨量(mm)&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&quot;value&quot;, splitline_opts=opts.SplitLineOpts(is_show=True), max_=250 ), yaxis_opts=opts.AxisOpts( name=&#x27;PM2.5&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&#x27;value&#x27;, axistick_opts=opts.AxisTickOpts(is_show=True), splitline_opts=opts.SplitLineOpts(is_show=True) ), tooltip_opts=opts.ToolboxOpts(), visualmap_opts=opts.VisualMapOpts( type_=&quot;color&quot;, max_=800, min_=5, dimension=1 ) ))# ToDO ShangHai Scatter Graphsh_precipitation_scatter = ( Scatter() .add_xaxis(xaxis_data=sh_precipitation.values) .add_yaxis( series_name=&#x27;PM2.5&#x27;, y_axis=sh_PM_precipitation.values, symbol_size=5, label_opts=opts.LabelOpts(is_show=False) ) .set_series_opts() .set_global_opts( title_opts=opts.TitleOpts(title=&quot;累计降雨量对PM2.5的影响&quot;), xaxis_opts=opts.AxisOpts( name=&#x27;累计降雨量(mm)&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&quot;value&quot;, splitline_opts=opts.SplitLineOpts(is_show=True) ), yaxis_opts=opts.AxisOpts( name=&#x27;PM2.5&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&#x27;value&#x27;, axistick_opts=opts.AxisTickOpts(is_show=True), splitline_opts=opts.SplitLineOpts(is_show=True) ), tooltip_opts=opts.ToolboxOpts(), visualmap_opts=opts.VisualMapOpts( type_=&quot;color&quot;, max_=800, min_=5, dimension=1 ) ))# ToDO ChengDu Scatter Graphcd_precipitation_scatter = ( Scatter() .add_xaxis(xaxis_data=cd_precipitation.values) .add_yaxis( series_name=&#x27;PM2.5&#x27;, y_axis=cd_PM_precipitation.values, symbol_size=5, label_opts=opts.LabelOpts(is_show=False) ) .set_series_opts() .set_global_opts( title_opts=opts.TitleOpts(title=&quot;累计降雨量对PM2.5的影响&quot;), xaxis_opts=opts.AxisOpts( name=&#x27;累计降雨量(mm)&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&quot;value&quot;, splitline_opts=opts.SplitLineOpts(is_show=True) ), yaxis_opts=opts.AxisOpts( name=&#x27;PM2.5&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&#x27;value&#x27;, axistick_opts=opts.AxisTickOpts(is_show=True), splitline_opts=opts.SplitLineOpts(is_show=True) ), tooltip_opts=opts.ToolboxOpts(), visualmap_opts=opts.VisualMapOpts( type_=&quot;color&quot;, max_=800, min_=5, dimension=1 ) ))# ToDO GuangZhou Scatter Graphgz_precipitation_scatter = ( Scatter() .add_xaxis(xaxis_data=gz_precipitation.values) .add_yaxis( series_name=&#x27;PM2.5&#x27;, y_axis=gz_PM_precipitation.values, symbol_size=5, label_opts=opts.LabelOpts(is_show=False) ) .set_series_opts() .set_global_opts( title_opts=opts.TitleOpts(title=&quot;累计降雨量对PM2.5的影响&quot;), xaxis_opts=opts.AxisOpts( name=&#x27;累计降雨量(mm)&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&quot;value&quot;, splitline_opts=opts.SplitLineOpts(is_show=True) ), yaxis_opts=opts.AxisOpts( name=&#x27;PM2.5&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&#x27;value&#x27;, axistick_opts=opts.AxisTickOpts(is_show=True), splitline_opts=opts.SplitLineOpts(is_show=True) ), tooltip_opts=opts.ToolboxOpts(), visualmap_opts=opts.VisualMapOpts( type_=&quot;color&quot;, max_=800, min_=5, dimension=1 ) ))# ToDO ShenYang Scatter Graphsy_precipitation_scatter = ( Scatter() .add_xaxis(xaxis_data=sy_precipitation.values) .add_yaxis( series_name=&#x27;PM2.5&#x27;, y_axis=sy_PM_precipitation.values, symbol_size=5, label_opts=opts.LabelOpts(is_show=False) ) .set_series_opts() .set_global_opts( title_opts=opts.TitleOpts(title=&quot;累计降雨量对PM2.5的影响&quot;), xaxis_opts=opts.AxisOpts( name=&#x27;累计降雨量(mm)&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&quot;value&quot;, splitline_opts=opts.SplitLineOpts(is_show=True) ), yaxis_opts=opts.AxisOpts( name=&#x27;PM2.5&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&#x27;value&#x27;, axistick_opts=opts.AxisTickOpts(is_show=True), splitline_opts=opts.SplitLineOpts(is_show=True) ), tooltip_opts=opts.ToolboxOpts(), visualmap_opts=opts.VisualMapOpts( type_=&quot;color&quot;, max_=800, min_=5, dimension=1 ) ))bj_precipitation_scatter.render(&#x27;./picture/precipitation_scatter/precipitation_BeiJing.html&#x27;)sh_precipitation_scatter.render(&#x27;./picture/precipitation_scatter/precipitation_ShangHai.html&#x27;)cd_precipitation_scatter.render(&#x27;./picture/precipitation_scatter/precipitation_ChengDu.html&#x27;)gz_precipitation_scatter.render(&#x27;./picture/precipitation_scatter/precipitation_GuangZhou.html&#x27;)sy_precipitation_scatter.render(&#x27;./picture/precipitation_scatter/precipitation_ShenYang.html&#x27;) 北京 成都 广州 上海 沈阳 五城市每个区空气质量的月度差异(month_PM25_line.py) 先将不同城区数据按照月份聚类 1234567891011121314151617181920212223242526272829303132333435import pursue_meanimport matplotlib.pyplot as pltimport numpy as np# TODO group by monthbj_month_PM_mean_1 = pursue_mean.df_bj.loc[pursue_mean.df_bj[&#x27;PM_Dongsi&#x27;].notnull(), [&#x27;PM_Dongsi&#x27;]]. \\ groupby(pursue_mean.df_bj[&#x27;month&#x27;]).mean()bj_month_PM_mean_2 = pursue_mean.df_bj.loc[pursue_mean.df_bj[&#x27;PM_Dongsihuan&#x27;].notnull(), [&#x27;PM_Dongsihuan&#x27;]]. \\ groupby(pursue_mean.df_bj[&#x27;month&#x27;]).mean()bj_month_PM_mean_3 = pursue_mean.df_bj.loc[pursue_mean.df_bj[&#x27;PM_Nongzhanguan&#x27;].notnull(), [&#x27;PM_Nongzhanguan&#x27;]]. \\ groupby(pursue_mean.df_bj[&#x27;month&#x27;]).mean()sh_month_PM_mean_1 = pursue_mean.df_sh.loc[pursue_mean.df_sh[&#x27;PM_Jingan&#x27;].notnull(), [&#x27;PM_Jingan&#x27;]]. \\ groupby(pursue_mean.df_sh[&#x27;month&#x27;]).mean()sh_month_PM_mean_2 = pursue_mean.df_sh.loc[pursue_mean.df_sh[&#x27;PM_Xuhui&#x27;].notnull(), [&#x27;PM_Xuhui&#x27;]]. \\ groupby(pursue_mean.df_sh[&#x27;month&#x27;]).mean()cd_month_PM_mean_1 = pursue_mean.df_cd.loc[pursue_mean.df_cd[&#x27;PM_Caotangsi&#x27;].notnull(), [&#x27;PM_Caotangsi&#x27;]]. \\ groupby(pursue_mean.df_cd[&#x27;month&#x27;]).mean()cd_month_PM_mean_2 = pursue_mean.df_cd.loc[pursue_mean.df_cd[&#x27;PM_Shahepu&#x27;].notnull(), [&#x27;PM_Shahepu&#x27;]]. \\ groupby(pursue_mean.df_cd[&#x27;month&#x27;]).mean()gz_month_PM_mean_1 = pursue_mean.df_gz.loc[pursue_mean.df_gz[&#x27;PM_City Station&#x27;].notnull(), [&#x27;PM_City Station&#x27;]]. \\ groupby(pursue_mean.df_gz[&#x27;month&#x27;]).mean()gz_month_PM_mean_2 = pursue_mean.df_gz.loc[pursue_mean.df_gz[&#x27;PM_5th Middle School&#x27;].notnull(), [&#x27;PM_5th Middle School&#x27;]]\\ .groupby(pursue_mean.df_gz[&#x27;month&#x27;]).mean()sy_month_PM_mean_1 = pursue_mean.df_sy.loc[pursue_mean.df_sy[&#x27;PM_Taiyuanjie&#x27;].notnull(), [&#x27;PM_Taiyuanjie&#x27;]]. \\ groupby(pursue_mean.df_sy[&#x27;month&#x27;]).mean()sy_month_PM_mean_2 = pursue_mean.df_sy.loc[pursue_mean.df_sy[&#x27;PM_Xiaoheyan&#x27;].notnull(), [&#x27;PM_Xiaoheyan&#x27;]]. \\ groupby(pursue_mean.df_sy[&#x27;month&#x27;]).mean() 作折线图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185plt.rcParams[&#x27;font.sans-serif&#x27;] = [&#x27;SimHei&#x27;] # 如果要显示中文字体,则在此处设为：SimHeiplt.rcParams[&#x27;axes.unicode_minus&#x27;] = False # 显示负号x = np.array([i for i in range(1, 13)])BeiJing_1 = np.array(bj_month_PM_mean_1.values)BeiJing_2 = np.array(bj_month_PM_mean_2.values)BeiJing_3 = np.array(bj_month_PM_mean_3.values)ShangHai_1 = np.array(sh_month_PM_mean_1.values)ShangHai_2 = np.array(sh_month_PM_mean_2.values)ChengDu_1 = np.array(cd_month_PM_mean_1.values)ChengDu_2 = np.array(cd_month_PM_mean_2.values)GuangZhou_1 = np.array(gz_month_PM_mean_1.values)GuangZhou_2 = np.array(gz_month_PM_mean_2.values)ShenYang_1 = np.array(sy_month_PM_mean_1.values)ShenYang_2 = np.array(sy_month_PM_mean_2.values)# TODO BeiJing line graph# label在图示(legend)中显示。若为数学公式,则最好在字符串前后添加&quot;$&quot;符号# color：b:blue、g:green、r:red、c:cyan、m:magenta、y:yellow、k:black、w:white、、、# 线型：- -- -. : ,# marker：. , o v &lt; * + 1plt.figure(num=&#x27;北京&#x27;, figsize=(10, 5))plt.grid(linestyle=&quot;--&quot;) # 设置背景网格线为虚线ax = plt.gca()ax.spines[&#x27;top&#x27;].set_visible(False) # 去掉上边框ax.spines[&#x27;right&#x27;].set_visible(False) # 去掉右边框plt.plot(x, BeiJing_1, marker=&#x27;o&#x27;, color=&quot;blue&quot;, label=&quot;Dongsi&quot;, linewidth=1.5)plt.plot(x, BeiJing_2, marker=&#x27;o&#x27;, color=&quot;red&quot;, label=&quot;Dongsihuan&quot;, linewidth=1.5)plt.plot(x, BeiJing_3, marker=&#x27;o&#x27;, color=&quot;magenta&quot;, label=&quot;Nongzhanguan&quot;, linewidth=1.5)group_labels = [&#x27;&#123;&#125;月&#x27;.format(i) for i in range(1, 13)] # x轴刻度的标识plt.xticks(x, group_labels, fontsize=12, fontweight=&#x27;bold&#x27;) # 默认字体大小为10plt.yticks(fontsize=12, fontweight=&#x27;bold&#x27;)plt.title(&quot;北京市不同城区PM2.5均值逐月变化&quot;, fontsize=12, fontweight=&#x27;bold&#x27;) # 默认字体大小为12plt.xlabel(&quot;月份&quot;, fontsize=13, fontweight=&#x27;bold&#x27;)plt.ylabel(&quot;PM2.5均值&quot;, fontsize=13, fontweight=&#x27;bold&#x27;)plt.xlim(0, 13) # 设置x轴的范围plt.ylim(30, 140)# plt.legend() #显示各曲线的图例plt.legend(loc=0, numpoints=1)leg = plt.gca().get_legend()ltext = leg.get_texts()plt.setp(ltext, fontsize=12, fontweight=&#x27;bold&#x27;) # 设置图例字体的大小和粗细plt.savefig(&#x27;./picture/district_month_line/BeiJing_month_line_graph.jpg&#x27;) # 建议保存为svg格式,再用inkscape转为矢量图emf后插入word中plt.show()# TODO ShangHai line graph# label在图示(legend)中显示。若为数学公式,则最好在字符串前后添加&quot;$&quot;符号# color：b:blue、g:green、r:red、c:cyan、m:magenta、y:yellow、k:black、w:white、、、# 线型：- -- -. : ,# marker：. , o v &lt; * + 1plt.figure(num=&#x27;上海&#x27;, figsize=(10, 5))plt.grid(linestyle=&quot;--&quot;) # 设置背景网格线为虚线ax = plt.gca()ax.spines[&#x27;top&#x27;].set_visible(False) # 去掉上边框ax.spines[&#x27;right&#x27;].set_visible(False) # 去掉右边框plt.plot(x, ShangHai_1, marker=&#x27;o&#x27;, color=&quot;green&quot;, label=&quot;Jingan&quot;, linewidth=1.5)plt.plot(x, ShangHai_2, marker=&#x27;o&#x27;, color=&quot;blue&quot;, label=&quot;Xuhui&quot;, linewidth=1.5)group_labels = [&#x27;&#123;&#125;月&#x27;.format(i) for i in range(1, 13)] # x轴刻度的标识plt.xticks(x, group_labels, fontsize=12, fontweight=&#x27;bold&#x27;) # 默认字体大小为10plt.yticks(fontsize=12, fontweight=&#x27;bold&#x27;)plt.title(&quot;上海市不同城区PM2.5均值逐月变化&quot;, fontsize=12, fontweight=&#x27;bold&#x27;) # 默认字体大小为12plt.xlabel(&quot;月份&quot;, fontsize=13, fontweight=&#x27;bold&#x27;)plt.ylabel(&quot;PM2.5均值&quot;, fontsize=13, fontweight=&#x27;bold&#x27;)plt.xlim(0, 13) # 设置x轴的范围plt.ylim(25, 120)# plt.legend() #显示各曲线的图例plt.legend(loc=0, numpoints=1)leg = plt.gca().get_legend()ltext = leg.get_texts()plt.setp(ltext, fontsize=12, fontweight=&#x27;bold&#x27;) # 设置图例字体的大小和粗细plt.savefig(&#x27;./picture/district_month_line/ShangHai_month_line_graph.jpg&#x27;) # 建议保存为svg格式,再用inkscape转为矢量图emf后插入word中plt.show()# TODO ChengDu line graph# label在图示(legend)中显示。若为数学公式,则最好在字符串前后添加&quot;$&quot;符号# color：b:blue、g:green、r:red、c:cyan、m:magenta、y:yellow、k:black、w:white、、、# 线型：- -- -. : ,# marker：. , o v &lt; * + 1plt.figure(num=&#x27;成都&#x27;, figsize=(10, 5))plt.grid(linestyle=&quot;--&quot;) # 设置背景网格线为虚线ax = plt.gca()ax.spines[&#x27;top&#x27;].set_visible(False) # 去掉上边框ax.spines[&#x27;right&#x27;].set_visible(False) # 去掉右边框plt.plot(x, ChengDu_1, marker=&#x27;o&#x27;, color=&quot;red&quot;, label=&quot;Caotangsi&quot;, linewidth=1.5)plt.plot(x, ChengDu_2, marker=&#x27;o&#x27;, color=&quot;black&quot;, label=&quot;Shahepu&quot;, linewidth=1.5)group_labels = [&#x27;&#123;&#125;月&#x27;.format(i) for i in range(1, 13)] # x轴刻度的标识plt.xticks(x, group_labels, fontsize=12, fontweight=&#x27;bold&#x27;) # 默认字体大小为10plt.yticks(fontsize=12, fontweight=&#x27;bold&#x27;)plt.title(&quot;成都市不同城区PM2.5均值逐月变化&quot;, fontsize=12, fontweight=&#x27;bold&#x27;) # 默认字体大小为12plt.xlabel(&quot;月份&quot;, fontsize=13, fontweight=&#x27;bold&#x27;)plt.ylabel(&quot;PM2.5均值&quot;, fontsize=13, fontweight=&#x27;bold&#x27;)plt.xlim(0, 13) # 设置x轴的范围plt.ylim(30, )# plt.legend() #显示各曲线的图例plt.legend(loc=0, numpoints=1)leg = plt.gca().get_legend()ltext = leg.get_texts()plt.setp(ltext, fontsize=12, fontweight=&#x27;bold&#x27;) # 设置图例字体的大小和粗细plt.savefig(&#x27;./picture/district_month_line/ChengDu_month_line_graph.jpg&#x27;) # 建议保存为svg格式,再用inkscape转为矢量图emf后插入word中plt.show()# TODO GuangZhou line graph# label在图示(legend)中显示。若为数学公式,则最好在字符串前后添加&quot;$&quot;符号# color：b:blue、g:green、r:red、c:cyan、m:magenta、y:yellow、k:black、w:white、、、# 线型：- -- -. : ,# marker：. , o v &lt; * + 1plt.figure(num=&#x27;广州&#x27;, figsize=(10, 5))plt.grid(linestyle=&quot;--&quot;) # 设置背景网格线为虚线ax = plt.gca()ax.spines[&#x27;top&#x27;].set_visible(False) # 去掉上边框ax.spines[&#x27;right&#x27;].set_visible(False) # 去掉右边框plt.plot(x, GuangZhou_1, marker=&#x27;o&#x27;, color=&quot;magenta&quot;, label=&quot;City Station&quot;, linewidth=1.5)plt.plot(x, GuangZhou_2, marker=&#x27;o&#x27;, color=&quot;green&quot;, label=&quot;5th Middle School&quot;, linewidth=1.5)group_labels = [&#x27;&#123;&#125;月&#x27;.format(i) for i in range(1, 13)] # x轴刻度的标识plt.xticks(x, group_labels, fontsize=12, fontweight=&#x27;bold&#x27;) # 默认字体大小为10plt.yticks(fontsize=12, fontweight=&#x27;bold&#x27;)plt.title(&quot;广州市不同城区PM2.5均值逐月变化&quot;, fontsize=12, fontweight=&#x27;bold&#x27;) # 默认字体大小为12plt.xlabel(&quot;月份&quot;, fontsize=13, fontweight=&#x27;bold&#x27;)plt.ylabel(&quot;PM2.5均值&quot;, fontsize=13, fontweight=&#x27;bold&#x27;)plt.xlim(0, 13) # 设置x轴的范围plt.ylim(15, 100)# plt.legend() #显示各曲线的图例plt.legend(loc=0, numpoints=1)leg = plt.gca().get_legend()ltext = leg.get_texts()plt.setp(ltext, fontsize=12, fontweight=&#x27;bold&#x27;) # 设置图例字体的大小和粗细plt.savefig(&#x27;./picture/district_month_line/GuangZhou_month_line_graph.jpg&#x27;) # 建议保存为svg格式,再用inkscape转为矢量图emf后插入word中plt.show()# TODO ShenYang line graph# label在图示(legend)中显示。若为数学公式,则最好在字符串前后添加&quot;$&quot;符号# color：b:blue、g:green、r:red、c:cyan、m:magenta、y:yellow、k:black、w:white、、、# 线型：- -- -. : ,# marker：. , o v &lt; * + 1plt.figure(num=&#x27;北京&#x27;, figsize=(10, 5))plt.grid(linestyle=&quot;--&quot;) # 设置背景网格线为虚线ax = plt.gca()ax.spines[&#x27;top&#x27;].set_visible(False) # 去掉上边框ax.spines[&#x27;right&#x27;].set_visible(False) # 去掉右边框plt.plot(x, ShenYang_1, marker=&#x27;o&#x27;, color=&quot;magenta&quot;, label=&quot;Taiyuanjie&quot;, linewidth=1.5)plt.plot(x, ShenYang_2, marker=&#x27;o&#x27;, color=&quot;blue&quot;, label=&quot;Xiaoheyan&quot;, linewidth=1.5)group_labels = [&#x27;&#123;&#125;月&#x27;.format(i) for i in range(1, 13)] # x轴刻度的标识plt.xticks(x, group_labels, fontsize=12, fontweight=&#x27;bold&#x27;) # 默认字体大小为10plt.yticks(fontsize=12, fontweight=&#x27;bold&#x27;)plt.title(&quot;沈阳市不同城区PM2.5均值逐月变化&quot;, fontsize=12, fontweight=&#x27;bold&#x27;) # 默认字体大小为12plt.xlabel(&quot;月份&quot;, fontsize=13, fontweight=&#x27;bold&#x27;)plt.ylabel(&quot;PM2.5均值&quot;, fontsize=13, fontweight=&#x27;bold&#x27;)plt.xlim(0, 13) # 设置x轴的范围plt.ylim(30, 145)# plt.legend() #显示各曲线的图例plt.legend(loc=0, numpoints=1)leg = plt.gca().get_legend()ltext = leg.get_texts()plt.setp(ltext, fontsize=12, fontweight=&#x27;bold&#x27;) # 设置图例字体的大小和粗细plt.savefig(&#x27;./picture/district_month_line/ShenYang_month_line_graph.jpg&#x27;) # 建议保存为svg格式,再用inkscape转为矢量图emf后插入word中plt.show() 北京 成都 广州 上海 沈阳 可以看出，夏季各大城市空气质量都是一年中最好的时候，冬季则相反 统计每个城市每天的平均PM2.5的数值(avergeDay_PM25_bar.py) 借助地理分布图的数据 1import geo_map 作条形图 12345678910111213141516171819from pyecharts import options as optsfrom pyecharts.charts import Barfrom pyecharts.globals import ThemeTypeaverageDay = ( Bar(&#123;&quot;theme&quot;: ThemeType.MACARONS&#125;) .add_xaxis([&#x27;北京&#x27;, &#x27;上海&#x27;, &#x27;成都&#x27;, &#x27;广州&#x27;, &#x27;沈阳&#x27;]) .add_yaxis(series_name=&#x27;城市&#x27;, y_axis=[int(geo_map.bj_PM_mean), int(geo_map.sh_PM_mean), int(geo_map.cd_PM_mean), int(geo_map.gz_PM_mean), int(geo_map.sy_PM_mean)]) .set_series_opts(label_opts=opts.LabelOpts(is_show=True)) .set_global_opts( title_opts=opts.TitleOpts(title=&quot;五大城市每天平均PM2.5数值&quot;), xaxis_opts=opts.AxisOpts(name=&#x27;城市&#x27;, name_location=&#x27;middle&#x27;, name_gap=30), yaxis_opts=opts.AxisOpts(name=&#x27;PM2.5日均值(含USA数据)&#x27;, name_location=&#x27;middle&#x27;, name_gap=30), toolbox_opts=opts.ToolboxOpts() ) .render(&#x27;./picture/averageDay_bar_graph.html&#x27;)) 基于天数对比中国环保部和美国驻华大使馆统计的污染状态(compare_CN_USA_bar.py) 先将5城市数据按天聚类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485from pyecharts import options as optsfrom pyecharts.charts import Barfrom pyecharts.globals import ThemeTypefrom itertools import chainimport pursue_mean# TODO BeiJing&#x27;s datapursue_mean.df_bj[&#x27;year&#x27;] = pursue_mean.df_bj[&#x27;year&#x27;].astype(&#x27;str&#x27;)pursue_mean.df_bj[&#x27;month&#x27;] = pursue_mean.df_bj[&#x27;month&#x27;].astype(&#x27;str&#x27;)pursue_mean.df_bj[&#x27;day&#x27;] = pursue_mean.df_bj[&#x27;day&#x27;].astype(&#x27;str&#x27;)pursue_mean.df_bj[&#x27;per day&#x27;] = pursue_mean.df_bj[&#x27;year&#x27;] + &#x27;-&#x27; + pursue_mean.df_bj[&#x27;month&#x27;] + &#x27;-&#x27; + pursue_mean.df_bj[ &#x27;day&#x27;]bj_CN = pursue_mean.df_bj.loc[pursue_mean.df_bj[&#x27;PM_mean_CN&#x27;].notnull(), [&#x27;PM_mean_CN&#x27;]]. \\ groupby(pursue_mean.df_bj[&#x27;per day&#x27;]).mean()bj_CN_fresh = int(bj_CN[bj_CN[&#x27;PM_mean_CN&#x27;] &lt;= 100].count().values)bj_CN_pollute = int(bj_CN[bj_CN[&#x27;PM_mean_CN&#x27;] &gt; 100].count().values)bj_USA = pursue_mean.df_bj.loc[pursue_mean.df_bj[&#x27;PM_US Post&#x27;].notnull(), [&#x27;PM_US Post&#x27;]]. \\ groupby(pursue_mean.df_bj[&#x27;per day&#x27;]).mean()bj_USA_fresh = int(bj_USA[bj_USA[&#x27;PM_US Post&#x27;] &lt;= 100].count().values)bj_USA_pollute = int(bj_USA[bj_USA[&#x27;PM_US Post&#x27;] &gt; 100].count().values)# TODO ShangHai&#x27;s datapursue_mean.df_sh[&#x27;year&#x27;] = pursue_mean.df_sh[&#x27;year&#x27;].astype(&#x27;str&#x27;)pursue_mean.df_sh[&#x27;month&#x27;] = pursue_mean.df_sh[&#x27;month&#x27;].astype(&#x27;str&#x27;)pursue_mean.df_sh[&#x27;day&#x27;] = pursue_mean.df_sh[&#x27;day&#x27;].astype(&#x27;str&#x27;)pursue_mean.df_sh[&#x27;per day&#x27;] = pursue_mean.df_sh[&#x27;year&#x27;] + &#x27;-&#x27; + pursue_mean.df_sh[&#x27;month&#x27;] + &#x27;-&#x27; + pursue_mean.df_sh[ &#x27;day&#x27;]sh_CN = pursue_mean.df_sh.loc[pursue_mean.df_sh[&#x27;PM_mean_CN&#x27;].notnull(), [&#x27;PM_mean_CN&#x27;]]. \\ groupby(pursue_mean.df_sh[&#x27;per day&#x27;]).mean()sh_CN_fresh = int(sh_CN[sh_CN[&#x27;PM_mean_CN&#x27;] &lt;= 100].count().values)sh_CN_pollute = int(sh_CN[sh_CN[&#x27;PM_mean_CN&#x27;] &gt; 100].count().values)sh_USA = pursue_mean.df_sh.loc[pursue_mean.df_sh[&#x27;PM_US Post&#x27;].notnull(), [&#x27;PM_US Post&#x27;]]. \\ groupby(pursue_mean.df_sh[&#x27;per day&#x27;]).mean()sh_USA_fresh = int(sh_USA[sh_USA[&#x27;PM_US Post&#x27;] &lt;= 100].count().values)sh_USA_pollute = int(sh_USA[sh_USA[&#x27;PM_US Post&#x27;] &gt; 100].count().values)# TODO ChengDu&#x27;s datapursue_mean.df_cd[&#x27;year&#x27;] = pursue_mean.df_cd[&#x27;year&#x27;].astype(&#x27;str&#x27;)pursue_mean.df_cd[&#x27;month&#x27;] = pursue_mean.df_cd[&#x27;month&#x27;].astype(&#x27;str&#x27;)pursue_mean.df_cd[&#x27;day&#x27;] = pursue_mean.df_cd[&#x27;day&#x27;].astype(&#x27;str&#x27;)pursue_mean.df_cd[&#x27;per day&#x27;] = pursue_mean.df_cd[&#x27;year&#x27;] + &#x27;-&#x27; + pursue_mean.df_cd[&#x27;month&#x27;] + &#x27;-&#x27; + pursue_mean.df_cd[ &#x27;day&#x27;]cd_CN = pursue_mean.df_cd.loc[pursue_mean.df_cd[&#x27;PM_mean_CN&#x27;].notnull(), [&#x27;PM_mean_CN&#x27;]]. \\ groupby(pursue_mean.df_cd[&#x27;per day&#x27;]).mean()cd_CN_fresh = int(cd_CN[cd_CN[&#x27;PM_mean_CN&#x27;] &lt;= 100].count().values)cd_CN_pollute = int(cd_CN[cd_CN[&#x27;PM_mean_CN&#x27;] &gt; 100].count().values)cd_USA = pursue_mean.df_cd.loc[pursue_mean.df_cd[&#x27;PM_US Post&#x27;].notnull(), [&#x27;PM_US Post&#x27;]]. \\ groupby(pursue_mean.df_cd[&#x27;per day&#x27;]).mean()cd_USA_fresh = int(cd_USA[cd_USA[&#x27;PM_US Post&#x27;] &lt;= 100].count().values)cd_USA_pollute = int(cd_USA[cd_USA[&#x27;PM_US Post&#x27;] &gt; 100].count().values)# TODO GuangZhou&#x27;s datapursue_mean.df_gz[&#x27;year&#x27;] = pursue_mean.df_gz[&#x27;year&#x27;].astype(&#x27;str&#x27;)pursue_mean.df_gz[&#x27;month&#x27;] = pursue_mean.df_gz[&#x27;month&#x27;].astype(&#x27;str&#x27;)pursue_mean.df_gz[&#x27;day&#x27;] = pursue_mean.df_gz[&#x27;day&#x27;].astype(&#x27;str&#x27;)pursue_mean.df_gz[&#x27;per day&#x27;] = pursue_mean.df_gz[&#x27;year&#x27;] + &#x27;-&#x27; + pursue_mean.df_gz[&#x27;month&#x27;] + &#x27;-&#x27; + pursue_mean.df_gz[ &#x27;day&#x27;]gz_CN = pursue_mean.df_gz.loc[pursue_mean.df_gz[&#x27;PM_mean_CN&#x27;].notnull(), [&#x27;PM_mean_CN&#x27;]]. \\ groupby(pursue_mean.df_gz[&#x27;per day&#x27;]).mean()gz_CN_fresh = int(gz_CN[gz_CN[&#x27;PM_mean_CN&#x27;] &lt;= 100].count().values)gz_CN_pollute = int(gz_CN[gz_CN[&#x27;PM_mean_CN&#x27;] &gt; 100].count().values)gz_USA = pursue_mean.df_gz.loc[pursue_mean.df_gz[&#x27;PM_US Post&#x27;].notnull(), [&#x27;PM_US Post&#x27;]]. \\ groupby(pursue_mean.df_gz[&#x27;per day&#x27;]).mean()gz_USA_fresh = int(gz_USA[gz_USA[&#x27;PM_US Post&#x27;] &lt;= 100].count().values)gz_USA_pollute = int(gz_USA[gz_USA[&#x27;PM_US Post&#x27;] &gt; 100].count().values)# TODO ShenYang&#x27;s datapursue_mean.df_sy[&#x27;year&#x27;] = pursue_mean.df_sy[&#x27;year&#x27;].astype(&#x27;str&#x27;)pursue_mean.df_sy[&#x27;month&#x27;] = pursue_mean.df_sy[&#x27;month&#x27;].astype(&#x27;str&#x27;)pursue_mean.df_sy[&#x27;day&#x27;] = pursue_mean.df_sy[&#x27;day&#x27;].astype(&#x27;str&#x27;)pursue_mean.df_sy[&#x27;per day&#x27;] = pursue_mean.df_sy[&#x27;year&#x27;] + &#x27;-&#x27; + pursue_mean.df_sy[&#x27;month&#x27;] + &#x27;-&#x27; + pursue_mean.df_sy[ &#x27;day&#x27;]sy_CN = pursue_mean.df_sy.loc[pursue_mean.df_sy[&#x27;PM_mean_CN&#x27;].notnull(), [&#x27;PM_mean_CN&#x27;]]. \\ groupby(pursue_mean.df_sy[&#x27;per day&#x27;]).mean()sy_CN_fresh = int(sy_CN[sy_CN[&#x27;PM_mean_CN&#x27;] &lt;= 100].count().values)sy_CN_pollute = int(sy_CN[sy_CN[&#x27;PM_mean_CN&#x27;] &gt; 100].count().values)sy_USA = pursue_mean.df_sy.loc[pursue_mean.df_sy[&#x27;PM_US Post&#x27;].notnull(), [&#x27;PM_US Post&#x27;]]. \\ groupby(pursue_mean.df_sy[&#x27;per day&#x27;]).mean()sy_USA_fresh = int(sy_USA[sy_USA[&#x27;PM_US Post&#x27;] &lt;= 100].count().values)sy_USA_pollute = int(sy_USA[sy_USA[&#x27;PM_US Post&#x27;] &gt; 100].count().values) 作条形图 1234567891011121314151617181920212223# TODO graphgraph = ( Bar(&#123;&quot;theme&quot;: ThemeType.MACARONS&#125;) .add_xaxis([&#x27;北京&#x27;, &#x27;上海&#x27;, &#x27;成都&#x27;, &#x27;广州&#x27;, &#x27;沈阳&#x27;]) .add_yaxis(series_name=&#x27;CN-该市空气优良天数&#x27;, y_axis=[bj_CN_fresh, sh_CN_fresh, cd_CN_fresh, gz_CN_fresh, sy_CN_fresh]) .add_yaxis(series_name=&#x27;USA-该市空气优良天数&#x27;, y_axis=[bj_USA_fresh, sh_USA_fresh, cd_USA_fresh, gz_USA_fresh, sy_USA_fresh]) .add_yaxis(series_name=&#x27;CN-该市空气污染天数&#x27;, y_axis=[bj_CN_pollute, sh_CN_pollute, cd_CN_pollute, gz_CN_pollute, sy_CN_pollute]) .add_yaxis(series_name=&#x27;USA-该市空气污染天数&#x27;, y_axis=[bj_USA_pollute, sh_USA_pollute, cd_USA_pollute, gz_USA_pollute, sy_USA_pollute]) .set_series_opts(label_opts=opts.LabelOpts(is_show=True)) .set_global_opts( title_opts=opts.TitleOpts(title=&quot;&quot;), xaxis_opts=opts.AxisOpts(name=&#x27;基于天数对比中国环保部和美国驻华大使馆统计的污染状态&#x27;, name_location=&#x27;middle&#x27;, name_gap=40), yaxis_opts=opts.AxisOpts(name=&#x27;中美各自统计的五大城市空气优良与污染天数&#x27;, name_location=&#x27;middle&#x27;, name_gap=40), toolbox_opts=opts.ToolboxOpts() ) .render(&#x27;./picture/compare_CN_USA_bar_graph.html&#x27;)) 可以看出，美国的数据统计的较为全面，中美两国统计的优良和污染天数并无特别大的差距 思考与总结 这次python实验报告，我学习了百度开源作图库 pyecharts 的使用，以及 NumPy、pandas 、matplotlib 库的使用。在整个学习过程中，我体验了一般用python操作excel表的乐趣，并惊叹于python作图模块的强大。这是区别于C语言、JAVA的重大特征。 同时也了解了我们国家五大城市过去6年的空气质量状况。由美国使领馆和邻近的环保部站点的原始PM2.5数据计算得出的评价空气质量的统计指标，具有很高的一致性与可比性。 附录 完整源代码在文件夹 PM25ProJ 中。 所有生成的图片在文件夹 PM25ProJ 下的 picture 目录中 PM2.5_five_cities.md 文档是PM2.5_five_cities.pdf的markdown文件 实验报告的标题处均有这个标题所对应的 .py 文件名","categories":[],"tags":[]},{"title":"Web程序设计","slug":"Web_PHP_Learn","date":"2022-09-24T07:42:10.000Z","updated":"2022-11-21T16:26:24.554Z","comments":true,"path":"2022/09/24/Web_PHP_Learn/","link":"","permalink":"http://example.com/2022/09/24/Web_PHP_Learn/","excerpt":"","text":"第1次作业 1 PHP脚本运行程序的运行，需要借助php预处理器，Web浏览器，Web服务器，的支持，必要时需要数据库服务器的支持。 浏览器主要功能是显示HTML的内容，由于PHP在发送到浏览器的时候已经被解析成其他代码，所以PHP对浏览器没有任何限制。 php预处理器，是将php程序中的php代码解释为文本信息。单纯的Web服务器，只能响应静态界面，比如不含任何php代码的html页面，如果浏览器请求的是动态页面，那Web服务器会调用php预处理器将其解释为静态页面，再将静态页面返回给浏览器。其实现对PHP文件的解析和编译。 Web服务器存储大量的网络资源，供用户访问和处理HTTP请求，可以向浏览器提供文档，放置文件让用户浏览，下载； 数据库服务器是存储和管理数据的容器。 2 常见的Web服务器：Apache、IIS、Nginx 常见的数据库服务器：MySQL、SQL Sever、Oracle、DB2 3 客户端浏览器向Web服务器请求访问指定界面； Web服务器接到客户端请求后，查找相关页面； 如果代码需要连接数据库，Web服务器则转给PHP预处理器，预处理器再转给SQL，数据库服务器处理以后，返回数据库的处理结果； 通过PHP预处理器将PHP脚本处理后的结果返回给Web服务器； Web服务器将预处理器解释好的HTML静态页面返给浏览器； 浏览器渲染； 需要注意的是：Web服务器，看到浏览器请求的是动态还是静态，静态自己就直接解决了，不求人，解决完返给浏览器；动态的才求人，求助于PHP预处理器。预处理器会把动态的解释成静态的。 4 静态网页：网页的内容是固定的，其修改和更新必须通过专用的网页制作工具。这种网页不是由程序制作出来的。 动态网页：是用网页脚本语言，如PHP，将网页内容动态存储在数据库中，是由数据库动态生成的网页，网站上只有一些框架，内容都是数据库动态提供的。 二者最大的区别就是，动态网页内容可以在线更新，静态网页不行。 5 网页通常是HTML文件，要通过浏览器来阅读，通常由图片，链接，文字，音视频等元素构成。 HTML表单控件： 1234567891011&lt;input&gt;&lt;label&gt;&lt;select&gt;&lt;textarea&gt;&lt;button&gt;&lt;fieldset&gt;&lt;legend&gt;&lt;datalist&gt;&lt;output&gt;&lt;option&gt;&lt;optgroup&gt; 6-20 D C B B A C A D D A B B A D D 第2次作业 链接的跳转 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;欢迎访问详情页&lt;/h2&gt; &lt;a href=&quot;index.html&quot;&gt;首页&lt;/a&gt;&amp;nbsp;&amp;nbsp; &lt;a href=&quot;list.html&quot;&gt;列表页&lt;/a&gt;&amp;nbsp;&amp;nbsp; &lt;a href=&quot;detail.html&quot;&gt;详情页&lt;/a&gt;&amp;nbsp;&amp;nbsp; &lt;a href=&quot;product.html&quot;&gt;产品页&lt;/a&gt;&amp;nbsp;&amp;nbsp; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;div&gt; &lt;img src=&quot;img/r1.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;欢迎访问首页&lt;/h2&gt; &lt;a href=&quot;index.html&quot;&gt;首页&lt;/a&gt;&amp;nbsp;&amp;nbsp; &lt;a href=&quot;list.html&quot;&gt;列表页&lt;/a&gt;&amp;nbsp;&amp;nbsp; &lt;a href=&quot;detail.html&quot;&gt;详情页&lt;/a&gt;&amp;nbsp;&amp;nbsp; &lt;a href=&quot;product.html&quot;&gt;产品页&lt;/a&gt;&amp;nbsp;&amp;nbsp; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;div&gt; &lt;img src=&quot;img/jst.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;欢迎访问详情页&lt;/h2&gt; &lt;a href=&quot;index.html&quot;&gt;首页&lt;/a&gt;&amp;nbsp;&amp;nbsp; &lt;a href=&quot;list.html&quot;&gt;列表页&lt;/a&gt;&amp;nbsp;&amp;nbsp; &lt;a href=&quot;detail.html&quot;&gt;详情页&lt;/a&gt;&amp;nbsp;&amp;nbsp; &lt;a href=&quot;product.html&quot;&gt;产品页&lt;/a&gt;&amp;nbsp;&amp;nbsp; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;div&gt; &lt;img src=&quot;img/r1.jpg&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;img/r2.jpg&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;img/r3.jpg&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;img/r4.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;欢迎访问产品页&lt;/h2&gt; &lt;a href=&quot;index.html&quot;&gt;首页&lt;/a&gt;&amp;nbsp;&amp;nbsp; &lt;a href=&quot;list.html&quot;&gt;列表页&lt;/a&gt;&amp;nbsp;&amp;nbsp; &lt;a href=&quot;detail.html&quot;&gt;详情页&lt;/a&gt;&amp;nbsp;&amp;nbsp; &lt;a href=&quot;product.html&quot;&gt;产品页&lt;/a&gt;&amp;nbsp;&amp;nbsp; &lt;br&gt; &lt;br&gt; &lt;br&gt; 当前是产品的详情 此处省略1万字&lt;/body&gt;&lt;/html&gt; 路径 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;img src=&quot;../../../image1/image2/image3/a.jpg&quot; alt=&quot;&quot;&gt; &lt;/body&gt;&lt;/html&gt; 表格练习 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;个人简历&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table border=&quot;1&quot; width=&quot;500&quot;&gt; &lt;tr bgcolor=&quot;#adff2f&quot;&gt; &lt;td colspan=&quot;5&quot; align=&quot;center&quot; width=&quot;500&quot;&gt;个人简历&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;姓&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;名:&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;性&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;别:&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;&lt;/td&gt; &lt;td rowspan=&quot;4&quot; align=&quot;center&quot; width=&quot;100&quot;&gt;照片&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;婚姻状况:&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;出生年月:&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;民&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;族:&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;政治面貌:&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;身&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;高:&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;学&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;历:&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Hot Bot&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table border=&quot;2&quot; width=&quot;600&quot; cellspacing=&quot;0&quot; style=&quot;border-collapse: collapse&quot;&gt; &lt;tr&gt; &lt;td align=&quot;center&quot; width=&quot;50&quot;&gt;&lt;b&gt;排名&lt;/b&gt;&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;&lt;b&gt;关键词&lt;/b&gt;&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;80&quot;&gt;&lt;b&gt;趋势&lt;/b&gt;&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;&lt;b&gt;今日搜索&lt;/b&gt;&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;&lt;b&gt;最近七日&lt;/b&gt;&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;170&quot;&gt;&lt;b&gt;相关链接&lt;/b&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;center&quot; width=&quot;50&quot;&gt;1&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;鬼吹灯&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;80&quot;&gt;&lt;img src=&quot;image2/down.jpg&quot; alt=&quot;&quot;&gt;&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;345&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;123&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;170&quot;&gt;&lt;font color=&quot;#8a2be2&quot;&gt;&lt;u&gt;贴吧&lt;/u&gt;&amp;nbsp;&lt;u&gt;图片&lt;/u&gt;&amp;nbsp;&lt;u&gt;百科&lt;/u&gt;&lt;/font&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;center&quot; width=&quot;50&quot;&gt;2&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;盗墓笔记&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;80&quot;&gt;&lt;img src=&quot;image2/down.jpg&quot; alt=&quot;&quot;&gt;&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;124&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;675432&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;170&quot;&gt;&lt;font color=&quot;#8a2be2&quot;&gt;&lt;u&gt;贴吧&lt;/u&gt;&amp;nbsp;&lt;u&gt;图片&lt;/u&gt;&amp;nbsp;&lt;u&gt;百科&lt;/u&gt;&lt;/font&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;center&quot; width=&quot;50&quot;&gt;3&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;西游记&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;80&quot;&gt;&lt;img src=&quot;image2/up.jpg&quot; alt=&quot;&quot;&gt;&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;212&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;7654&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;170&quot;&gt;&lt;font color=&quot;#8a2be2&quot;&gt;&lt;u&gt;贴吧&lt;/u&gt;&amp;nbsp;&lt;u&gt;图片&lt;/u&gt;&amp;nbsp;&lt;u&gt;百科&lt;/u&gt;&lt;/font&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;center&quot; width=&quot;50&quot;&gt;4&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;东游记&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;80&quot;&gt;&lt;img src=&quot;image2/up.jpg&quot; alt=&quot;&quot;&gt;&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;23&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;75645&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;170&quot;&gt;&lt;font color=&quot;#8a2be2&quot;&gt;&lt;u&gt;贴吧&lt;/u&gt;&amp;nbsp;&lt;u&gt;图片&lt;/u&gt;&amp;nbsp;&lt;u&gt;百科&lt;/u&gt;&lt;/font&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;center&quot; width=&quot;50&quot;&gt;5&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;甄嬛传&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;80&quot;&gt;&lt;img src=&quot;image2/down.jpg&quot; alt=&quot;&quot;&gt;&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;121&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;7676&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;170&quot;&gt;&lt;font color=&quot;#8a2be2&quot;&gt;&lt;u&gt;贴吧&lt;/u&gt;&amp;nbsp;&lt;u&gt;图片&lt;/u&gt;&amp;nbsp;&lt;u&gt;百科&lt;/u&gt;&lt;/font&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;center&quot; width=&quot;50&quot;&gt;6&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;水浒传&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;80&quot;&gt;&lt;img src=&quot;image2/up.jpg&quot; alt=&quot;&quot;&gt;&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;576576&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;1231421&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;170&quot;&gt;&lt;font color=&quot;#8a2be2&quot;&gt;&lt;u&gt;贴吧&lt;/u&gt;&amp;nbsp;&lt;u&gt;图片&lt;/u&gt;&amp;nbsp;&lt;u&gt;百科&lt;/u&gt;&lt;/font&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;center&quot; width=&quot;50&quot;&gt;7&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;三国演义&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;80&quot;&gt;&lt;img src=&quot;image2/up.jpg&quot; alt=&quot;&quot;&gt;&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;234&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;7686&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;170&quot;&gt;&lt;font color=&quot;#8a2be2&quot;&gt;&lt;u&gt;贴吧&lt;/u&gt;&amp;nbsp;&lt;u&gt;图片&lt;/u&gt;&amp;nbsp;&lt;u&gt;百科&lt;/u&gt;&lt;/font&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 第3次作业 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;大卖场&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;?php $good1 = &#x27;香蕉&#x27;; $good2 = &#x27;苹果&#x27;; $good3 = &#x27;橘子&#x27;; $num1 = 2; $num2 = 1; $num3 = 3; $price1 = 7.99; $price2 = 6.89; $price3 = 3.99; $discount = 0.8; $sumprice = ($num1 * $price1 + $num2 * $price2 + $num3 * $price3) * $discount; ?&gt;&lt;table border=&quot;2&quot; style=&quot;border-collapse: collapse&quot; cellspacing=&quot;0&quot;&gt; &lt;tr&gt; &lt;td&gt;商品名称&lt;/td&gt; &lt;td&gt;购买数量(斤)&lt;/td&gt; &lt;td&gt;商品价格(元/斤)&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;?php echo $good1 ?&gt;&lt;/td&gt; &lt;td&gt;&lt;?php echo $num1 ?&gt;&lt;/td&gt; &lt;td&gt;&lt;?php echo $price1 ?&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;?php echo $good2 ?&gt;&lt;/td&gt; &lt;td&gt;&lt;?php echo $num2 ?&gt;&lt;/td&gt; &lt;td&gt;&lt;?php echo $price2 ?&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;?php echo $good3 ?&gt;&lt;/td&gt; &lt;td&gt;&lt;?php echo $num3 ?&gt;&lt;/td&gt; &lt;td&gt;&lt;?php echo $price3 ?&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;3&quot;&gt;商品折扣：&lt;?php echo $discount ?&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;3&quot;&gt;打折后购买商品总价格：&lt;?php echo $sumprice ?&gt;元&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 第4次作业 1 XML标记风格(标准标记)：推荐使用这种标记123&lt;?php?&gt; 脚本标记风格：仅需了解1234&lt;script language=&quot;php&quot;&gt;&lt;/script&gt; 简短标记风格：需要到PHP配置文件修改才能使用123&lt;??&gt; ASP标记风格：需要到PHP配置文件修改才能使用123&lt;%%&gt; 2 PHP注释种类 /* */ 多行注释：当我们需要写很多注释，一行写不下时用多行注释； // 单行注释：只写一行注释，简洁； shell脚本风格注释：还是推荐单行注释； 注释标签 用于在 HTML 插入注释。 3 PHP数据类型: 标量数据类型: bool类型:仅有TRUE和FALSE，且不区分大小写。常用于逻辑判断; 整型:存储整数 浮点型:存储实数 字符串类型:存储连续的字符序列; 复合数据类型: 数组:存储一组数据； 对象:将客观事物抽象成类，类是对象的模板，对象是类的实例。每个类都有自己的特征和行为，其特征就是字段，其行为就是方法。同属于一个类的每个对象都有相同的属性和方法。 特殊数据类型: 资源数据类型:句柄 空数据类型:没有为该变量设置任何值，NULL和null不区分大小写。被赋空值的三种情况: 在定义变量时，没有被赋任何值； 被赋值为null； 用unset()函数处理过的变量； 伪类型 4 使用define()函数声明自定义常量。比如define(&quot;-_-&quot;, “我爱你”); 使用const关键字定义常量，比如，const PI = 3.14; 二者区别： const定义常量，标识符大小写敏感；但是define()就不一定了，define()可以通过第三个参数指定是否大小写敏感。 const不能在函数，循环，分支结构中被访问；但define()可以； define()不能在类中被访问到，但是const可以； 获取常量值有2种方法： 使用constant()函数可以获取常量的值； 直接取它的变量名； 5 “===” 是恒等于运算符，$a === $b， 当二者数据类型而且值也相同时，返回true，否则返回false； 6 检查一个变量是否设置，用 bool isset(mixed var) 函数，若该变量已经定义，并且该值不是NULL，那么返回布尔值true，否则返回false。 is_null()来判断变量是否为null，若是null，返回true，否则返回false. 区别： 123$c = null;var_dump(isset($c));var_dump(is_null($c)); 输出是 bool(false) bool(true) 7 echo语句： echo是一个语言结构，可以带括号或不带括号使用： echo或echo()，都可以用来输出，它是最常用的输出语句。在平时，echo或echo()的输出是一样的，只有在将多个参数传递给echo语句，进行输出时，则使用括号将生成解析错误。不能加@；没有返回值。 print语句： print语句也可以实现输出，且有返回值。当输出成功会返回1，失败就会返回0；因此它可以在表达式中使用。print语句同样可以带括号或不带括号使用，没有多大区别。一次只能输出1个值。 printf()函数 printf()函数也可以实现输出，可以输出普通的字符串，也格式化输出。 print_r() print_r()函数是用来输出变量的，可以用人类容易读取的格式来显示这个变量的信息。 var_dump() var_dump()函数用于输出变量，可以显示变量的结构化信息。 8 双引号和单引号的区别： 双引号中包含的变量会被自动替换成实际数值，而单引号中的变量按照普通字符串输出； 单引号的速度比双引号快； 9 传值赋值，改变其中一个变量的值，不会影响到另一个变量的值。但引用赋值会，引用赋值传的是地址。 10 检查一个变量是否设置，用 bool isset(mixed var) 函数，若该变量已经定义，并且该值不是NULL，那么返回布尔值true，否则返回false。 is_null()来判断变量是否为null，若是null，返回true，否则返回false. (PHP 4, PHP 5, PHP 7, PHP 8) empty — 检查一个变量是否为空 判断一个变量是否被认为是空的。当一个变量并不存在，或者它的值等同于false，那么它会被认为不存在。如果变量不存在的话，empty()并不会产生警告。没有警告会产生，哪怕变量并不存在。 这意味着 empty() 本质上与 !isset($var) || $var == false 等价。 当var存在，并且是一个非空****非零的值时返回 false ，否则返回 true. 以下的东西被认为是空的： “” (空字符串) 0 (作为整数的0) 0.0 (作为浮点数的0) “0” (作为字符串的0) null false array() (一个空数组) $var; (一个声明了，但是没有值的变量) 11 1234$x = 5;$y = 6;$z = 7;$max = $x&gt;$y ? ( $x&gt;$z ? $x : $z ) : ($y&gt;$z ?$y :$z); 12-30 D C B B D B C B B D C D D D D A C B A 第5次作业 成绩等级判断 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;学生成绩&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;请输入您的姓名和分数&lt;/h2&gt; &lt;form action=&quot;#&quot; method=&quot;post&quot;&gt; 请输入姓名：&lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot;&gt; &lt;hr&gt; 请输入成绩：&lt;input type=&quot;text&quot; name=&quot;score&quot; id=&quot;score&quot;&gt; &lt;hr&gt; &lt;input type=&quot;submit&quot; name=&quot;btn&quot; id=&quot;btn&quot;&gt; &lt;/form&gt; &lt;?php if (isset($_POST[&#x27;btn&#x27;]))&#123; $Name = $_POST[&#x27;name&#x27;]; $Score = $_POST[&#x27;score&#x27;]; if (is_numeric($Score))&#123; echo &quot;您好&#123;$Name&#125;，很高兴你能在CAU学习！&lt;hr&gt;&quot;; switch ($Score)&#123; case $Score &gt;= 90: echo &#x27;A&lt;br/&gt;&#x27;; break; case $Score &gt;= 80: echo &#x27;B&lt;br/&gt;&#x27;; break; case $Score &gt;= 70: echo &#x27;C&lt;br/&gt;&#x27;; break; case $Score &gt;= 60: echo &#x27;D&lt;br/&gt;&#x27;; break; default: echo &#x27;E&lt;br/&gt;&#x27;; &#125; &#125; &#125; ?&gt;&lt;/body&gt;&lt;/html&gt; 更改文字颜色 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;改变颜色&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;my_color&quot;&gt; 轻轻的你走了，&lt;br&gt; 正如你轻轻的来。&lt;br&gt; 我轻轻的招手，&lt;br&gt; 作别西天的云彩。 &lt;/div&gt; &lt;form action=&quot;#&quot; method=&quot;post&quot;&gt; &lt;select name=&quot;color&quot; id=&quot;color&quot;&gt; &lt;option value=&quot;0&quot;&gt;请选择颜色&lt;/option&gt; &lt;option value=&quot;1&quot;&gt;红色&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;绿色&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;蓝色&lt;/option&gt; &lt;/select&gt; &lt;input type=&quot;submit&quot; name=&quot;btn&quot; value=&quot;更改颜色&quot;&gt; &lt;/form&gt; &lt;?php if (isset($_POST[&#x27;btn&#x27;]))&#123; switch ($_POST[&#x27;color&#x27;])&#123; case &#x27;1&#x27;: $color = &#x27;#FF0000&#x27;; break; case &#x27;2&#x27;: $color = &#x27;#009900&#x27;; break; case &#x27;3&#x27;: $color = &#x27;#0000FF&#x27;; break; default: $color = &#x27;#000000&#x27;; &#125; echo &lt;&lt;&lt;str &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function()&#123; document.getElementById(&#x27;my_color&#x27;).style.color=&#x27;$color&#x27;; &#125; &lt;/script&gt;str; &#125; ?&gt;&lt;/body&gt;&lt;/html&gt; 第6次作业 1 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;今日距离您的生日还有几天？&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;#&quot; method=&quot;post&quot;&gt; 请输入您的生日年份：&lt;input type=&quot;text&quot; name=&quot;birth_year&quot; id=&quot;birth_year&quot;&gt;&lt;br&gt; 请输入您的生日月份：&lt;input type=&quot;text&quot; name=&quot;birth_month&quot; id=&quot;birth_month&quot;&gt;&lt;br&gt; 请输入您的生日日期：&lt;input type=&quot;text&quot; name=&quot;birth_day&quot; id=&quot;birth_day&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; name=&quot;btn&quot; value=&quot;提交您的生日&quot;&gt; &lt;/form&gt; &lt;?php if (isset($_POST[&#x27;btn&#x27;]))&#123; $now_year = date(&quot;Y&quot;); $next_year = date(&quot;Y&quot;); $now_month = date(&quot;m&quot;); $now_day = date(&quot;d&quot;); $birth_month = $_POST[&quot;birth_month&quot;]; $birth_day = $_POST[&quot;birth_day&quot;]; if ($now_month &gt; $birth_month)&#123; $next_year = $next_year + 1; &#125;elseif ($birth_month == $now_month)&#123; if ($now_day &gt; $birth_day)&#123; $next_year = $next_year + 1; &#125; &#125; $date1=date_create(&quot;$next_year-$birth_month-$birth_day&quot;); $date2=date_create(&quot;$now_year-$now_month-$now_day&quot;); $diff=date_diff($date2,$date1); echo $diff-&gt;format(&quot;%R%a days&quot;); &#125; ?&gt;&lt;/body&gt;&lt;/html&gt; 2 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;逢七过&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;?php $cnt = 0; for ($n = 1; $n &lt;= 99; $n++)&#123; if (($n % 10 == 7) || ($n % 7 == 0))&#123; $cnt++; &#125; &#125; echo $cnt; ?&gt;&lt;/body&gt;&lt;/html&gt; 3 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;大卖场&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;?php $num1 = mt_rand(); $num2 = mt_rand(); echo $num1 + $num2; ?&gt;&lt;/body&gt;&lt;/html&gt; 4 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;大卖场&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;?php $sum = 0; for ($n = 1; $n &lt;= 100; $n++)&#123; if (($n % 3 )== 0)&#123; $sum += $n; &#125; &#125; echo $sum; ?&gt;&lt;/body&gt;&lt;/html&gt; 5 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;大卖场&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;table border=&quot;1&quot; align=&quot;center&quot; width=&quot;1000&quot;&gt; &lt;?php for ($i = 1; $i &lt;= 9; ++$i): ?&gt; &lt;tr&gt; &lt;?php for ($j = 1; $j &lt;= $i; $j++): $product = $i * $j; ?&gt; &lt;td&gt;&lt;?=&quot;&#123;$i&#125; × &#123;$j&#125; = &#123;$product&#125;&quot; ?&gt;&lt;/td&gt; &lt;?php endfor; ?&gt; &lt;/tr&gt; &lt;?php endfor; ?&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 6 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;ATM&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;#&quot; method=&quot;post&quot;&gt; 请输入您的账号:&lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;username&quot;&gt;&lt;br&gt; 请输入您的密码:&lt;input type=&quot;password&quot; name=&quot;pwd&quot; id=&quot;pwd&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; name=&quot;btn&quot; value=&quot;登录&quot;&gt;&lt;br&gt; &lt;input type=&quot;hidden&quot; name=&quot;cnt&quot; value=&quot;1&quot; id=&quot;failed&quot;&gt; &lt;/form&gt; &lt;?php if (isset($_POST[&#x27;btn&#x27;]))&#123; $name = $_POST[&#x27;username&#x27;]; $password = $_POST[&#x27;pwd&#x27;]; $count = $_POST[&#x27;cnt&#x27;]; if ($count &gt; 3)&#123; echo &#x27;您已经登录3次以上且均失败，将要吞卡&lt;br/&gt;&#x27;; die(&quot;寄了&quot;); &#125;elseif (($name != &#x27;admin&#x27;))&#123; echo &#x27;用户名错误 登录失败&lt;br/&gt;&#x27;; $count++; &#125;elseif ($password != &#x27;abc&#x27;)&#123; echo &#x27;用户名正确 密码错误 登录失败&lt;br/&gt;&#x27;; $count++; &#125;else &#123; echo &#x27;用户名正确 密码正确，登录成功&lt;br/&gt;&#x27;; &#125; echo &lt;&lt;&lt;str &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function()&#123; document.getElementById(&#x27;failed&#x27;).style.color=&#x27;$count&#x27;; &#125; &lt;/script&gt;str; &#125; ?&gt;&lt;/body&gt;&lt;/html&gt; 第7次作业 Include_And_Require_index.php 12345678910111213141516171819202122232425262728293031&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;网页布局&lt;/title&gt; &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;/&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;这部分是网页的表头&lt;/div&gt;&lt;div&gt; &lt;div&gt;&lt;?php include &quot;./Include_And_Require_content.php&quot;;?&gt;&lt;/div&gt; &lt;div&gt;&lt;?php include &quot;./Include_And_Require_side.php&quot;;?&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;这不是网页尾部信息&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; Include_And_Require_content.php 12345678910111213141516171819&lt;?php$books = [&#x27;php.jpg&#x27;, &#x27;mysql.jpg&#x27;, &#x27;python.jpg&#x27;, &#x27;database.jpg&#x27;];?&gt;&lt;div&gt; &lt;?php foreach($books as $book):?&gt; &lt;div&gt; &lt;img src=&quot;./img_index/&lt;?php echo $book;?&gt;&quot; width=&quot;75&quot; height=&quot;100&quot;&gt; &lt;/div&gt; &lt;?php endforeach;?&gt;&lt;/div&gt; Include_And_Require_side.php 1234567891011121314151617181920212223&lt;?php$arr = [[&#x27;编程基础类&#x27;, &#x27;程序设计I&#x27;, &#x27;Web程雪设计&#x27;,&#x27;Python语言程序设计&#x27;], [&#x27;数据处理类&#x27;, &#x27;数据分析&#x27;, &#x27;数据库原理&#x27;]];?&gt;&lt;h2&gt;开设课程信息&lt;/h2&gt;&lt;ul&gt; &lt;?php foreach($arr as $values): ?&gt; &lt;?php foreach($values as $k =&gt; $v): ?&gt; &lt;?php echo $k &gt; 0 ? &quot;&lt;li&gt;$v&lt;/li&gt;&quot; : &quot;&lt;p&gt;$v&lt;/p&gt;&quot;; ?&gt; &lt;?php endforeach; ?&gt; &lt;?php endforeach; ?&gt;&lt;/ul&gt; 第8次作业 1 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;大卖场&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;?php function Pascal_Triangle($n)&#123; $a = array(); for ($i = 0; $i &lt; $n; ++$i)&#123; $a[$i][0] = 1; $a[$i][$i] = 1; &#125; for ($i = 1; $i &lt; $n; ++$i)&#123; for ($j = 1; $j &lt; $i; ++$j)&#123; $a[$i][$j] = $a[$i - 1][$j - 1] + $a[$i - 1][$j]; &#125; &#125; for ($i = 0; $i &lt; $n; ++$i)&#123; for ($j = 0; $j &lt;= $i; ++$j)&#123; echo $a[$i][$j].&#x27;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&#x27;; &#125; echo &#x27;&lt;br/&gt;&#x27;; &#125; &#125; Pascal_Triangle(10); ?&gt;&lt;/body&gt;&lt;/html&gt; 2 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;大卖场&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;?php $arr = array(9, 8, 7, 6, 5, 4, 3, 2, 1); $len = 10; function Bubble_Selection($arr, $len)&#123; if (is_array($arr))&#123; for ($i = 0; $i &lt; $len - 1; ++$i)&#123; for ($j = 0; $j &lt; $len - $i - 1; ++$j)&#123; if (isset($arr[$j]) &amp;&amp; isset($arr[$j + 1]))&#123; if ($arr[$j] &gt; $arr[$j + 1])&#123; $t = $arr[$j]; $arr[$j] = $arr[$j + 1]; $arr[$j + 1] = $t; &#125; &#125; &#125; &#125; return $arr; &#125; &#125; print_r(Bubble_Selection($arr, $len)); ?&gt;&lt;/body&gt;&lt;/html&gt; 3 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;大卖场&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;?php $date1 = strtotime(&quot;2022-5-1 13:12:12&quot;); $date2 = strtotime(&quot;2022-5-2 12:45:11&quot;); $diff = abs($date1 - $date2); $days = floor($diff / 3600 / 24); $hours = floor(($diff - $days * 86400) / 3600); $mins = floor(($diff - $days * 86400 - $hours * 3600) / 60); $seconds = floor($diff - $days * 86400 - $hours * 3600 - $mins * 60); printf(&quot;相差: %f 日，%f 小时，%f 分钟，%f 秒&quot;, $days, $hours, $mins, $hours); echo &#x27;&lt;br/&gt;&#x27;; echo &quot;相差: &#123;$days&#125; 日，&#123;$hours&#125; 小时，&#123;$mins&#125; 分钟，&#123;$seconds&#125; 秒&quot; ?&gt;&lt;/body&gt;&lt;/html&gt; 4 快排 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;大卖场&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;?php $arr2 = array(9, 8, 7, 6, 5, 4, 3, 2, 1); $L2 = 0; $R2 = 8; function Quick_Sort(&amp;$arr, $L, $R)&#123; if ($L &gt;= $R)&#123; return $arr; &#125; $left = $L; //这样移动left就好，不去动L，因为后面递归要用到L $right = $R; //这样移动right就好，不去动R，因为后面递归要用到R $pivot = $arr[$left]; while ($left &lt; $right)&#123; // 外层循环不能少，因为left和right在一次循环中各自最多找到一个要变动的元素，要找到更多需要变动的元素，只能进入下一个循环 while (($left &lt; $right) &amp;&amp; ($arr[$right] &gt;= $pivot))&#123; //等于的话，就不去动它.($left &lt; $right)一定不能省略，防止right减成left还继续减 $right--; &#125; if ($left &lt; $right)&#123; // 这个判断也不能少，因为出了上面那个循环，right可能已经变了很多了，但此时left还是0 $arr[$left] = $arr[$right]; &#125; while (($left &lt; $right) &amp;&amp; ($arr[$left] &lt;= $pivot))&#123; //right已经成功找到了一个比pivot小的了，该left找了 $left++; &#125; if ($left &lt; $right)&#123; $arr[$right] = $arr[$left]; &#125; if ($left == $right)&#123; $arr[$left] = $pivot; &#125; &#125; Quick_Sort($arr, $L, $right - 1); // 此时 $left = $right，新一轮的函数调用会有自己的$left和$right Quick_Sort($arr, $left + 1, $R); // 此时 $left = $right，新一轮的函数调用会有自己的$left和$right return $arr; &#125; print_r(Quick_Sort($arr2, $L2, $R2)); ?&gt;&lt;/body&gt;&lt;/html&gt; 冒泡 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;大卖场&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;?php $arr = array(9, 8, 7, 6, 5, 4, 3, 2, 1); $len = 10; function Bubble_Selection($arr, $len)&#123; if (is_array($arr))&#123; for ($i = 0; $i &lt; $len - 1; ++$i)&#123; for ($j = 0; $j &lt; $len - $i - 1; ++$j)&#123; if (isset($arr[$j]) &amp;&amp; isset($arr[$j + 1]))&#123; if ($arr[$j] &gt; $arr[$j + 1])&#123; $t = $arr[$j]; $arr[$j] = $arr[$j + 1]; $arr[$j + 1] = $t; &#125; &#125; &#125; &#125; return $arr; &#125; &#125; print_r(Bubble_Selection($arr, $len)); ?&gt;&lt;/body&gt;&lt;/html&gt; 5 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;大卖场&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;?php function sortByKeyDesc($arr, $key) &#123; //降序 array_multisort(array_column($arr, $key), SORT_DESC, $arr); return $arr; &#125; function sortByKeyAsc($arr, $key) &#123; //升序 array_multisort(array_column($arr, $key), SORT_ASC, $arr); return $arr; &#125; ?&gt;&lt;/body&gt;&lt;/html&gt; 6 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;大卖场&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;?php function FileName_Suffix($path)&#123; $position = strrpos($path, &#x27;.&#x27;); $suffix = substr($path, $position); return $suffix; &#125; ?&gt;&lt;/body&gt;&lt;/html&gt; 第9次作业 1 break和continue都是用来控制循环结构的，主要作用是停止循环。 不管是哪种循环，一旦在循环体中遇到break，系统将完全结束循环，开始执行循环之后的代码。 continue语句的作用是跳过本次循环体中剩下尚未执行的语句，立即进行下一次的循环条件判定，可以理解为只是中止(跳过)本次循环，接着开始下一次循环。 continue语句并没有使整个循环终止。 continue 只能在循环语句中使用，即只能在 for、while 和 do…while 语句中使用。只能在循环体内和switch语句体内使用break。 2 require()和include()函数作用类似，但是区别如下： 若引用文件发生错误或者无法找到，require()将给出警告并终止程序运行，include()只会给出警告，但是不会终止程序运行。 require()只要程序开始执行，就会立即调用外部文件，但是include()只会待到程序执行到该函数时，才会调用外部文件。 3 while循环执行时只有当满足条件时才会进入循环，进入循环后，执行完循环体内全部语句直到条件不满足时，再跳出循环。do-while循环将先运行一次，在经过第一次do循环后，执行完一次后检查条件表达式的值是否成立，其值为不成立时才会退出循环。while循环是先判断后执行，如果判断条件不成立可以不执行中间循环体。do-while循环是先执行后判断，执行次数至少为一次，执行一次后判断条件是否成立，如果不成立跳出循环，成立则继续运行循环体。 1234567&lt;?php$i=0;//控制变量初始化while($i&lt;10)&#123;//表达式执行语句;//反复执行直到表达式为假$i++;//控制变量自增长&#125;?&gt; 123456&lt;?php$i = 0;//控制变量初始化do &#123; &lt;span style=&quot;font-family: monospace; white-space: pre; background-color: rgb(240, 240, 240);&quot;&gt;执行语句&lt;/span&gt;;//先执行一次&#125; while ($i &gt;0);//表达式?&gt; 4-10 C B A A C D C 第10次作业 1 1234function max($a, $b, $c)&#123; $max1 = $a &gt; $b ? $a : $b; return $max1 &gt; $c ? $max1 : $c; &#125; 2 1234function get_url_extention($url)&#123; $path_parts = pathinfo($url); return $path_parts[&#x27;extension&#x27;]; &#125; 3 传值赋值： 值传递是 PHP 中函数的默认传值方式，也称为“拷贝传值”。 顾名思义值赋值的方式会将实参的值复制一份再传递给函数的形参，所以在函数中操作参数的值并不会对函数外的实参造成影响。 因此如果不希望函数修改实参的值，就可以通过值传递的方式。 传地址赋值 参数的引用传递就是把实参的内存地址复制一份，然后传递给函数的形参，进而将实参值赋值给形参。 实参和形参都指向同一个内存地址，因此函数对形参的操作，会影响到函数外的实参。 按引用传递就是将实参的内存地址传递到函数的形参中。因此实参和形参指向的是同一个内存地址。这时在函数内部的所有操作都会影响到函数外实参的值。 4 require()和include()函数作用类似，但是区别如下： 若引用文件发生错误或者无法找到，require()将给出警告并终止程序运行，include()只会给出警告，但是不会终止程序运行。 require()只要程序开始执行，就会立即调用外部文件，但是include()只会待到程序执行到该函数时，才会调用外部文件。 5 ‘/[1]\\d{4,}/’ 6 7-22 B C A B B A D B C C B C B B C D 第11次作业 1 sort()函数将数组中的元素按照值正排序； asort()函数将数组中的元素按照值倒排序； ksort()函数将数组中的元素按照键正排序； 2 123456789101112131415161718192021222324252627282930313233343536373839$b = array(9, 6, 7, 5, 3, 8); $L2 = 0; $R2 = 5; function Quick_Sort(&amp;$arr, $L, $R)&#123; //必须是引用传递数组，否则递归无效 if ($L &gt;= $R)&#123; return $arr; &#125; $left = $L; //这样移动left就好，不去动L，因为后面递归要用到L $right = $R; //这样移动right就好，不去动R，因为后面递归要用到R $pivot = $arr[$left]; while ($left &lt; $right)&#123; // 外层循环不能少，因为left和right在一次循环中各自最多找到一个要变动的元素，要找到更多需要变动的元素，只能进入下一个循环 while (($left &lt; $right) &amp;&amp; ($arr[$right] &gt;= $pivot))&#123; //等于的话，就不去动它.($left &lt; $right)一定不能省略，防止right减成left还继续减 $right--; &#125; if ($left &lt; $right)&#123; // 这个判断也不能少，因为出了上面那个循环，right可能已经变了很多了，但此时left还是0 $arr[$left] = $arr[$right]; &#125; while (($left &lt; $right) &amp;&amp; ($arr[$left] &lt;= $pivot))&#123; //right已经成功找到了一个比pivot小的了，该left找了 $left++; &#125; if ($left &lt; $right)&#123; $arr[$right] = $arr[$left]; &#125; if ($left == $right)&#123; $arr[$left] = $pivot; &#125; &#125; Quick_Sort($arr, $L, $right - 1); // 此时 $left = $right，新一轮的函数调用会有自己的$left和$right Quick_Sort($arr, $left + 1, $R); // 此时 $left = $right，新一轮的函数调用会有自己的$left和$right return $arr; &#125; print_r(Quick_Sort($b, $L2, $R2)); 3 D B A A D B C A C A C A C D 第12次作业 1 GET方式提交 POST方式提交 php接受通过HTML表单提交的信息时，会将提交的数据保存在全局数组中，我们可以调用系统特定的自动全局变量数组来获取这些值。常用的自动全局变量如下所示： $_GET $_POST REQUEST在获取表单数据中，最常用的自动全局变量是_REQUEST 在获取表单数据中，最常用的自动全局变量是R​EQUEST在获取表单数据中，最常用的自动全局变量是_GET和$_POST,它们分别获取通过GET方法提交的数据和通过POST方法提交的数据。 2 当客户没有禁止Cookie时 使用session_set_cookie_params()函数，它必须在session_start前面调用，但不推荐使用该方法； 和cookie一样，用setcookie()函数手动设置失效时间； 客户端禁用cookie 必须打开cookie； 设置php.ini文件； 使用GET方式隐藏表单传递session_id； 使用文件或者数据库存储session_id，在页面间传递时手动调用； 3 禁用cookie后，Session页面间的传递会失效，但我们可以用一些方法去让它生效： 当客户没有禁止Cookie时 使用session_set_cookie_params()函数，它必须在session_start前面调用，但不推荐使用该方法； 和cookie一样，用setcookie()函数手动设置失效时间； 客户端禁用cookie 必须打开cookie； 设置php.ini文件； 使用GET方式隐藏表单传递session_id； 使用文件或者数据库存储session_id，在页面间传递时手动调用； 4 cookie和session的区别： 存储位置：cookie数据存放在客户的浏览器上，session数据放在服务器上。 隐私策略不同，Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些。 session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用COOKIE。 存储大小不同，单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie。 存取方式的不同，Cookie 只能保存 ASCII，Session 可以存任意数据类型，一般情况下我们可以在 Session 中保持一些常用变量信息，比如说 UserId 等。 有效期不同，Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效。 cookie原理： HTTP Cookie（也叫 Web Cookie或浏览器 Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。 Cookie 主要用于以下三个方面： 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息） 个性化设置（如用户自定义设置、主题等） 浏览器行为跟踪（如跟踪分析用户行为等） session原理： Session 代表着服务器和客户端一次会话的过程。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 Session 超时失效时会话结束。 Cookie 和 Session 的配合 用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建创建对应的 Session ，请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器，浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名。 当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。 根据以上流程可知，SessionID 是连接 Cookie 和 Session 的一道桥梁，大部分系统也是根据此原理来验证用户登录状态。 既然服务端是根据 Cookie 中的信息判断用户是否登录，那么如果浏览器中禁止了 Cookie，如何保障整个机制的正常运转。 第一种方案，每次请求中都携带一个 SessionID 的参数，也可以 Post 的方式提交，也可以在请求的地址后面拼接。 第二种方案，Token 机制。Token 机制多用于 App 客户端和服务器交互的模式，也可以用于 Web 端做用户状态管理。Token 的意思是“令牌”，是服务端生成的一串字符串，作为客户端进行请求的一个标识。Token 机制和 Cookie 和 Session 的使用机制比较类似。当用户第一次登录后，服务器根据提交的用户信息生成一个 Token，响应时将 Token 返回给客户端，以后客户端只需带上这个 Token 前来请求数据即可，无需再次登录验证。 5 123456789101112&lt;?php function get_url($url) &#123; $url_para = parse_url($url); $query = explode(&quot;&amp;&quot;, $url_para[&quot;query&quot;]); foreach ($query as $item) &#123; echo &quot;$item&quot;.&quot;&lt;br&gt;&quot;; &#125; &#125; $url = &quot;https://www.bilibili.com/video/BV18U4y1j7o1/?spm_id_from=333.788.recommend_more_video.2&amp;vd_source=86560676da6f4c30de25eecbfa96c918&quot;; get_url($url);?&gt; 6 Cookie在客户端存储数据； Session在服务器端存储数据； Session更安全； 7-20 C A D C B B D A A A C D D A 21 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;大卖场&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;#&quot; method=&quot;post&quot;&gt; &lt;center&gt;注册账号&lt;/center&gt; &lt;table align=&quot;center&quot; border=&quot;1&quot;&gt; &lt;tr&gt; &lt;td&gt;用户名:&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;content[username]&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;email:&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;content[email]&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码:&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;content[pwd]&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;确认密码:&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;content[confirm_pwd]&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;性别:&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;radio&quot; name=&quot;content[sex]&quot; value=&quot;男&quot;&gt;男 &lt;input type=&quot;radio&quot; name=&quot;content[sex]&quot; value=&quot;女&quot; checked&gt;女 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;手机号码:&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;content[phone]&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;喜欢的编程技术:&lt;/td&gt; &lt;td&gt; &lt;select name=&quot;content[loveLanguage]&quot;&gt; &lt;option selected&gt;PHP&lt;/option&gt; &lt;option &gt;Python&lt;/option&gt; &lt;option&gt;Java&lt;/option&gt; &lt;option&gt;C&lt;/option&gt; &lt;option&gt;C++&lt;/option&gt; &lt;option&gt;Go&lt;/option&gt; &lt;option&gt;Rust&lt;/option&gt; &lt;option&gt;C#&lt;/option&gt; &lt;/select&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td COLSPAN=&quot;2&quot;&gt; &lt;input type=&quot;checkbox&quot; checked name=&quot;content[check]&quot;&gt;我已经看过并接受&lt;a href=&quot;https://www.bilibili.com/&quot; target=&quot;_blank&quot;&gt; &lt;b&gt;用户协议&lt;/b&gt;&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;立即注册&quot; name=&quot;bnt&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/form&gt; &lt;?php if (isset($_POST[&quot;bnt&quot;])) &#123; if (isset($_POST[&quot;content&quot;][&quot;check&quot;])) &#123; if ($_POST[&quot;content&quot;][&quot;username&quot;] == &quot;&quot; || $_POST[&quot;content&quot;][&quot;email&quot;] == &quot;&quot; || $_POST[&quot;content&quot;][&quot;pwd&quot;] == &quot;&quot; || $_POST[&quot;content&quot;][&quot;confirm_pwd&quot;] == &quot;&quot; || $_POST[&quot;content&quot;][&quot;sex&quot;] == &quot;&quot; || $_POST[&quot;content&quot;][&quot;phone&quot;] == &quot;&quot; || $_POST[&quot;content&quot;][&quot;loveLanguage&quot;] == &quot;&quot;) &#123; echo &quot;不能有不填的！&quot; or exit(&quot;回去填&quot;); &#125;else &#123; echo &quot;你好&quot;; echo &quot;用户名:&quot;.$_POST[&quot;content&quot;][&quot;username&quot;].&quot;&lt;br&gt;&quot;; echo &quot;邮箱:&quot;.$_POST[&quot;content&quot;][&quot;email&quot;].&quot;&lt;br&gt;&quot;; echo &quot;密码:&quot;.$_POST[&quot;content&quot;][&quot;pwd&quot;].&quot;&lt;br&gt;&quot;; echo &quot;确认密码:&quot;.$_POST[&quot;content&quot;][&quot;confirm_pwd&quot;].&quot;&lt;br&gt;&quot;; echo &quot;性别:&quot;.$_POST[&quot;content&quot;][&quot;sex&quot;].&quot;&lt;br&gt;&quot;; echo &quot;手机号:&quot;.$_POST[&quot;content&quot;][&quot;phone&quot;].&quot;&lt;br&gt;&quot;; echo &quot;你喜欢的编程预言:&quot;.$_POST[&quot;content&quot;][&quot;loveLanguage&quot;].&quot;&lt;br&gt;&quot;; &#125; &#125; &#125; ?&gt;&lt;/body&gt;&lt;/html&gt; 第13次作业 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;给排2班&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;?php $_red = range(1, 33); $_red_keys = array_rand($_red, 6); shuffle($_red_keys); foreach ($_red_keys as $key) &#123; if ($_red[$key] &lt; 10) &#123; echo &quot;0&quot;.$_red[$key].&quot;&lt;br&gt;&quot;; &#125;else &#123; echo $_red[$key].&quot;&lt;br&gt;&quot;; &#125; &#125; $_blue = range(1, 16); $_blue_key = array_rand($_blue, 1); echo $_blue[$_blue_key]; ?&gt;&lt;/body&gt;&lt;/html&gt; 第14次作业 1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;大卖场&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;#&quot; method=&quot;post&quot;&gt; &lt;center&gt;注册账号&lt;/center&gt; &lt;table align=&quot;center&quot; border=&quot;1&quot;&gt; &lt;tr&gt; &lt;td&gt;用户名:&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;content[username]&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;email:&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;content[email]&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码:&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;content[pwd]&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;确认密码:&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;content[confirm_pwd]&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;性别:&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;radio&quot; name=&quot;content[sex]&quot; value=&quot;男&quot;&gt;男 &lt;input type=&quot;radio&quot; name=&quot;content[sex]&quot; value=&quot;女&quot; checked&gt;女 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;手机号码:&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;content[phone]&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;喜欢的编程技术:&lt;/td&gt; &lt;td&gt; &lt;select name=&quot;content[loveLanguage]&quot;&gt; &lt;option selected&gt;PHP&lt;/option&gt; &lt;option &gt;Python&lt;/option&gt; &lt;option&gt;Java&lt;/option&gt; &lt;option&gt;C&lt;/option&gt; &lt;option&gt;C++&lt;/option&gt; &lt;option&gt;Go&lt;/option&gt; &lt;option&gt;Rust&lt;/option&gt; &lt;option&gt;C#&lt;/option&gt; &lt;/select&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td COLSPAN=&quot;2&quot;&gt; &lt;input type=&quot;checkbox&quot; checked name=&quot;content[check]&quot;&gt;我已经看过并接受&lt;a href=&quot;https://www.bilibili.com/&quot; target=&quot;_blank&quot;&gt; &lt;b&gt;用户协议&lt;/b&gt;&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;立即注册&quot; name=&quot;bnt&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/form&gt; &lt;?php if (isset($_POST[&quot;bnt&quot;])) &#123; if (isset($_POST[&quot;content&quot;][&quot;check&quot;])) &#123; if ($_POST[&quot;content&quot;][&quot;username&quot;] == &quot;&quot; || $_POST[&quot;content&quot;][&quot;email&quot;] == &quot;&quot; || $_POST[&quot;content&quot;][&quot;pwd&quot;] == &quot;&quot; || $_POST[&quot;content&quot;][&quot;confirm_pwd&quot;] == &quot;&quot; || $_POST[&quot;content&quot;][&quot;sex&quot;] == &quot;&quot; || $_POST[&quot;content&quot;][&quot;phone&quot;] == &quot;&quot; || $_POST[&quot;content&quot;][&quot;loveLanguage&quot;] == &quot;&quot;) &#123; echo &quot;不能有不填的！&quot; or exit(&quot;回去填&quot;); &#125;else &#123; echo &quot;你好&quot;; echo &quot;用户名:&quot;.$_POST[&quot;content&quot;][&quot;username&quot;].&quot;&lt;br&gt;&quot;; echo &quot;邮箱:&quot;.$_POST[&quot;content&quot;][&quot;email&quot;].&quot;&lt;br&gt;&quot;; echo &quot;密码:&quot;.$_POST[&quot;content&quot;][&quot;pwd&quot;].&quot;&lt;br&gt;&quot;; echo &quot;确认密码:&quot;.$_POST[&quot;content&quot;][&quot;confirm_pwd&quot;].&quot;&lt;br&gt;&quot;; echo &quot;性别:&quot;.$_POST[&quot;content&quot;][&quot;sex&quot;].&quot;&lt;br&gt;&quot;; echo &quot;手机号:&quot;.$_POST[&quot;content&quot;][&quot;phone&quot;].&quot;&lt;br&gt;&quot;; echo &quot;你喜欢的编程预言:&quot;.$_POST[&quot;content&quot;][&quot;loveLanguage&quot;].&quot;&lt;br&gt;&quot;; &#125; &#125; &#125; ?&gt;&lt;/body&gt;&lt;/html&gt; 2 login_index.php 1234567891011121314&lt;?phpsession_start();if (! isset($_SESSION[&quot;is_login&quot;])) &#123; $_SESSION[&quot;is_login&quot;] = FALSE; echo &quot;亲爱的，请先&lt;a href=&#x27;login.html&#x27;&gt;&lt;b&gt;登录&lt;b&gt;&lt;a&gt;&quot;.&quot;&lt;br&gt;&quot;;&#125;else &#123; if ($_SESSION[&quot;is_login&quot;]) &#123; $name = $_SESSION[&quot;name&quot;]; echo $name.&quot;! 您好，欢迎光临本会所！&quot;.&quot;&lt;br&gt;&quot;; echo &quot;&lt;a href=&#x27;logout.php&#x27;&gt;&lt;b&gt;退出&lt;b&gt;&lt;a&gt;&quot;.&quot;&lt;br&gt;&quot;; &#125;else &#123; echo &quot;亲爱的，请先&lt;a href=&#x27;login.html&#x27;&gt;&lt;b&gt;登录&lt;b&gt;&lt;a&gt;&quot;.&quot;&lt;br&gt;&quot;; &#125;&#125; login.html 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;登陆系统&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3 align=&quot;center&quot;&gt;请登录！&lt;/h3&gt; &lt;form action=&quot;login.php&quot; method=&quot;post&quot;&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;您的昵称:&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;text&quot; name=&quot;user_name&quot; placeholder=&quot;最少一个汉字，最多10个汉字&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;您的密码:&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;password&quot; name=&quot;user_password&quot; placeholder=&quot;至少包含数字、字母，特殊字符中的2种&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;center&quot; colspan=&quot;2&quot;&gt;&lt;input type=&quot;checkbox&quot; value=&quot;7&quot; name=&quot;ok_boy&quot;&gt;&lt;i&gt;七天内自动登录&lt;/i&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;center&quot; colspan=&quot;2&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;登录&quot; name=&quot;bnt&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; login.php 123456789101112131415161718192021222324252627282930313233&lt;?phpsession_start();if (isset($_POST[&quot;bnt&quot;])) &#123; $user_name = trim($_POST[&quot;user_name&quot;]); $user_password = trim($_POST[&quot;user_password&quot;]); if ($user_name == &quot;&quot; || $user_password == &quot;&quot;) &#123; $_SESSION[&quot;is_login&quot;] = FALSE; echo &quot;您输入的昵称和密码不能为空，请重新输入！&lt;br&gt;3秒后自动跳转&lt;br&gt;&quot;; header(&quot;refresh:3;url = login.html&quot;); die(); &#125;elseif ($user_name != &quot;辉哥&quot; || $user_password != &quot;辉哥要发财&quot;)&#123; $_SESSION[&quot;is_login&quot;] = FALSE; echo &quot;您输入的昵称或密码有误，请重新输入！&lt;br&gt;3秒后自动跳转&lt;br&gt;&quot;; header(&quot;refresh:3;url = login.html&quot;); die(); &#125;else &#123; $_SESSION[&quot;is_login&quot;] = TRUE; $_SESSION[&quot;name&quot;] = $user_name; $_SESSION[&quot;password&quot;] = $user_password; if (isset($_POST[&quot;ok_boy&quot;])) &#123; if ($_POST[&quot;ok_boy&quot;] == &quot;7&quot;) &#123; setcookie(&quot;name&quot;, $user_name, time() + 7 * 24 * 3600); setcookie(&quot;password&quot;, $user_password, time() + 7 * 24 * 3600); &#125; &#125;else &#123; setcookie(&quot;name&quot;, $user_name, time() + 3600); setcookie(&quot;password&quot;, $user_password, time() + 3600); &#125; echo &quot;恭喜您！登陆成功！&lt;br&gt;3秒后自动跳转&lt;br&gt;&quot;; header(&quot;refresh:3;url = login_index.php&quot;); &#125;&#125; logout.php 123456789&lt;?phpsession_start();$name = $_SESSION[&quot;name&quot;];echo $name.&quot;，相逢何必曾相识，再见！&lt;br&gt;&quot;;setcookie(&quot;name&quot;, &quot;&quot;, 0);setcookie(&quot;password&quot;, &quot;&quot;, 0);$_SESSION = array();session_destroy();echo &quot;&lt;a href=&#x27;login_index.php&#x27;&gt;重新来一次&lt;a&gt;&quot;; 第15次作业 1 1INSERT INTO department VALUES (&#x27;1005&#x27;, &#x27;财务部&#x27;, &#x27;财务管理&#x27;, &#x27;天津&#x27;) 2 1SELECT d_id, d_name, function FROM department 3 1SELECT * FROM employee WHERE birthday BETWEEN 25 AND 30 4 1SELECT name, birthday, address FROM employee WHERE address LIKE(&#x27;%北京%&#x27;) 5 1UPDATE employee SET salary * 1.1 WHERE d_id = &#x27;1002&#x27; 6 1DELETE FROM employee WHERE id = &#x27;9006&#x27; 一个模板 12345678910111213141516171819$link = mysqli_connect(&quot;localhost&quot;, &quot;root&quot;, &quot;&quot;, &quot;jxgl&quot;);if ($link) &#123; echo &quot;连接本地mysql服务器成功！&lt;br&gt;&quot;; $data = mysqli_select_db($link, &quot;jxgl&quot;); if ($data)&#123; echo &quot;选择jxgl成功&lt;br&gt;&quot;; $query = &quot;SELECT * FROM student&quot;; $result = mysqli_query($link, $query); if ($result)&#123; ; # 处理数据结果集 &#125;else&#123; echo &quot;读取数据集失败&lt;br&gt;&quot;; &#125; &#125;else&#123; echo &quot;选择jxgl失败&lt;br&gt;&quot;; &#125;&#125;else &#123; echo &quot;连接本地mysql服务器失败！&quot;;&#125; 第16次作业 前面已经连接过一次数据库了，这里就不再重复连接了，只需要执行sql语句即可，比如下面的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;majors enquiry&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;?php $link = mysqli_connect(&quot;localhost&quot;, &quot;root&quot;, &quot;&quot;, &quot;jxgl&quot;); if ($link) &#123; echo &quot;连接本地mysql服务器成功！&lt;br&gt;&quot;; $data = mysqli_select_db($link, &quot;jxgl&quot;); if ($data)&#123; echo &quot;选择jxgl成功&lt;br&gt;&quot;; $query = &quot;SELECT * FROM specialty&quot;; $result = mysqli_query($link, $query); if ($result)&#123; echo &quot;读取数据集成功&lt;br&gt;&quot;; ; &#125;else&#123; echo &quot;读取数据集失败&lt;br&gt;&quot;; &#125; &#125;else&#123; echo &quot;选择jxgl失败&lt;br&gt;&quot;; &#125; &#125;else &#123; echo &quot;连接本地mysql服务器失败！&quot;; &#125;?&gt;&lt;?php if (isset($result)): ?&gt; &lt;form action=&quot;#&quot; method=&quot;post&quot;&gt; 请选择专业： &lt;select name=&quot;majors_zno&quot;&gt; &lt;?php while ($rs = mysqli_fetch_array($result, MYSQLI_ASSOC)): ?&gt; &lt;option value=&quot;&lt;?=$rs[&#x27;zno&#x27;]?&gt;&quot;&gt;&lt;?=$rs[&#x27;zname&#x27;]?&gt;&lt;/option&gt; &lt;?php endwhile; ?&gt; &lt;/select&gt; &lt;br&gt; &lt;input type=&quot;submit&quot; name=&quot;btn&quot; value=&quot;enquire&quot;&gt;&lt;!-- 先连接连接服务器查询专业再提交--&gt; &lt;/form&gt;&lt;?php endif; ?&gt;&lt;?php if (isset($_POST[&#x27;btn&#x27;]))&#123; $zno = $_POST[&#x27;majors_zno&#x27;]; echo $zno.&quot;&lt;hr&gt;&quot;;//前面已经连接过一次数据库了，这里就不再重复连接了，只需要执行sql语句即可 $query2 = &quot;SELECT * FROM student WHERE BINARY zno = &#x27;&#123;$zno&#125;&#x27;&quot;; $result2 = mysqli_query($link, $query2); if ($result2)&#123; echo &quot;读取数据集成功&lt;br&gt;&quot;; ; &#125;else&#123; echo &quot;读取数据集失败&lt;br&gt;&quot;; &#125; &#125;?&gt; &lt;?php if (isset($result2)): ?&gt;&lt;!--必须点击查询按钮之后，才会有result2，有result2才会有下面的学生信息表，没有if (isset($result2))，不提交查询按钮也会显示下面的表头--&gt; &lt;center&gt;&lt;h2&gt;学生信息&lt;/h2&gt;&lt;/center&gt; &lt;table border=&quot;1&quot; align=&quot;center&quot; width=&quot;1000&quot;&gt; &lt;tr&gt; &lt;th&gt;学号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;班级&lt;/th&gt; &lt;th&gt;查看出生日期&lt;/th&gt; &lt;/tr&gt; &lt;?php while ($rs2 = mysqli_fetch_array($result2, MYSQLI_ASSOC)): ?&gt; &lt;?php if ($rs2[&#x27;ssex&#x27;] == &#x27;男&#x27;): ?&gt; &lt;tr bgcolor=&quot;#dc143c&quot;&gt; &lt;?php endif; ?&gt; &lt;td&gt;&lt;?=$rs2[&#x27;sno&#x27;]?&gt;&lt;/td&gt; &lt;td&gt;&lt;?=$rs2[&#x27;sname&#x27;]?&gt;&lt;/td&gt; &lt;td&gt;&lt;?=$rs2[&#x27;ssex&#x27;]?&gt;&lt;/td&gt; &lt;td&gt;&lt;?=$rs2[&#x27;sclass&#x27;]?&gt;&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;detail.php?sbirth=&lt;?=$rs2[&#x27;sbirth&#x27;]?&gt;&quot; target=&quot;_blank&quot;&gt;查看出生日期&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;?php endwhile; ?&gt; &lt;?php echo &quot;共有数据：&quot;.mysqli_num_rows($result2).&quot;条&quot;; ?&gt; &lt;?php endif; ?&gt;&lt;/body&gt;&lt;/html&gt; 第17次作业 UPDATE 更新数据表必须加 WHERE，否则要么报错，要么修改所有行 JS if语句和C语言一样，一定要加{}，否则只会执行下面第一行 JS点击链接不跳转的3个方法： href属性设置为 1href = &quot;javascript:void(0);&quot; onclick属性设置为 1onclick = &quot;return false;&quot; 如果onclick 后面跟了一个函数，这个函数返回true or false，函数返回false则终止链接的跳转，那么必须这样写： 1onclick = &quot;return Checkme()&quot; Checkme()前面的return是必不可少的，否则达不到想要的效果 update_delete_student_info.php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Redden Boy&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;?php$link = mysqli_connect(&quot;localhost&quot;, &quot;root&quot;, &quot;&quot;, &quot;jxgl&quot;);if ($link) &#123; echo &quot;连接本地mysql服务器成功！&lt;br&gt;&quot;; $data = mysqli_select_db($link, &quot;jxgl&quot;); mysqli_set_charset($link, &#x27;utf8&#x27;); if ($data)&#123; echo &quot;选择jxgl成功&lt;br&gt;&quot;; $query = &quot;SELECT * FROM student&quot;; $result = mysqli_query($link, $query); if ($result)&#123; echo &quot;读取数据集成功&lt;br&gt;&quot;; ; &#125;else&#123; echo &quot;读取数据集失败&lt;br&gt;&quot;; &#125; &#125;else&#123; echo &quot;选择jxgl失败&lt;br&gt;&quot;; &#125;&#125;else &#123; echo &quot;连接本地mysql服务器失败！&quot;;&#125;?&gt;&lt;center&gt;&lt;h2&gt;学生信息&lt;/h2&gt;&lt;/center&gt;&lt;table border=&quot;1&quot; align=&quot;center&quot; width=&quot;1000&quot;&gt; &lt;tr&gt; &lt;th&gt;学号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;班级&lt;/th&gt; &lt;th&gt;更新&lt;/th&gt; &lt;th&gt;删除&lt;/th&gt; &lt;/tr&gt; &lt;script language=&quot;JavaScript&quot;&gt; function Checkme() &#123; if (confirm(&quot;是否确定删除数据？&quot;) === true)&#123; alert(&quot;成功删除数据&quot;); return true; &#125; else &#123; alert(&quot;没有删除数据&quot;); return false; &#125; &#125; &lt;/script&gt; &lt;?php if (isset($result)): ?&gt; &lt;?php while ($rs = mysqli_fetch_array($result, MYSQLI_ASSOC)): ?&gt; &lt;?php if ($rs[&#x27;ssex&#x27;] == &#x27;男&#x27;): ?&gt; &lt;tr bgcolor=&quot;#dc143c&quot;&gt; &lt;?php endif; ?&gt; &lt;td&gt;&lt;?=$rs[&#x27;sno&#x27;]?&gt;&lt;/td&gt; &lt;td&gt;&lt;?=$rs[&#x27;sname&#x27;]?&gt;&lt;/td&gt; &lt;td&gt;&lt;?=$rs[&#x27;ssex&#x27;]?&gt;&lt;/td&gt; &lt;td&gt;&lt;?=$rs[&#x27;sclass&#x27;]?&gt;&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;update.php?sno=&lt;?=$rs[&#x27;sno&#x27;]?&gt;&quot; target=&quot;_blank&quot;&gt;update&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;deletion.php?sno=&lt;?=$rs[&#x27;sno&#x27;]?&gt;&quot; target=&quot;_blank&quot; onclick=&quot;return Checkme()&quot;&gt;delete&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;?php endwhile; ?&gt; &lt;?php endif; ?&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; update.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Crud Boy&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;?php$sno = $_GET[&#x27;sno&#x27;];$link = mysqli_connect(&quot;localhost&quot;, &quot;root&quot;, &quot;&quot;, &quot;jxgl&quot;);if ($link) &#123; echo &quot;连接本地mysql服务器成功！&lt;br&gt;&quot;; $data = mysqli_select_db($link, &quot;jxgl&quot;); mysqli_set_charset($link, &#x27;utf8&#x27;); if ($data)&#123; echo &quot;选择jxgl成功&lt;br&gt;&quot;; $query = &quot;SELECT * FROM specialty&quot;; $result = mysqli_query($link, $query); $query2 = &quot;SELECT * FROM student WHERE sno = &#x27;&#123;$sno&#125;&#x27;&quot;; $result2 = mysqli_query($link, $query2); $rs2 = mysqli_fetch_array($result2, MYSQLI_ASSOC); if ($result and $result2)&#123; echo &quot;读取数据集成功&lt;br&gt;&quot;; &#125;else&#123; echo &quot;读取数据集失败&lt;br&gt;&quot;; &#125; &#125;else&#123; echo &quot;选择jxgl失败&lt;br&gt;&quot;; &#125;&#125;else &#123; echo &quot;连接本地mysql服务器失败！&quot;;&#125;?&gt;&lt;?php if (isset($result) and isset($result2) and isset($rs2)): ?&gt;&lt;form action=&quot;#&quot; method=&quot;post&quot;&gt; &lt;center&gt;&lt;h2&gt;crud学生信息&lt;/h2&gt;&lt;/center&gt; &lt;table border=&quot;1&quot; align=&quot;center&quot; width=&quot;1000&quot;&gt; &lt;tr&gt; &lt;td align=&quot;right&quot;&gt;学号&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;txtsno&quot; value=&quot;&lt;?=$rs2[&#x27;sno&#x27;]?&gt;&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;right&quot;&gt;姓名&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;txtsname&quot; value=&quot;&lt;?=$rs2[&#x27;sname&#x27;]?&gt;&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;right&quot;&gt;性别&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;radio&quot; name=&quot;rdossex&quot; value=&quot;男&quot; &lt;?php if ($rs2[&#x27;ssex&#x27;]==&#x27;男&#x27;)&#123;echo &#x27;checked=&quot;checked&quot;&#x27;;&#125;?&gt;&gt;男 &lt;input type=&quot;radio&quot; name=&quot;rdossex&quot; value=&quot;女&quot; &lt;?php if ($rs2[&#x27;ssex&#x27;]==&#x27;女&#x27;)&#123;echo &#x27;checked=&quot;checked&quot;&#x27;;&#125;?&gt;&gt;女 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;right&quot;&gt;出生日期&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;txtsbirth&quot; value=&quot;&lt;?=$rs2[&#x27;sbirth&#x27;]?&gt;&quot;&gt;(形如：YYYY-MM-DD)&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;right&quot;&gt;专业&lt;/td&gt; &lt;td&gt; &lt;select name=&quot;majors_zno&quot;&gt; &lt;?php while ($rs = mysqli_fetch_array($result, MYSQLI_ASSOC)): ?&gt; &lt;?php if ($rs[&#x27;zno&#x27;]==$rs2[&#x27;zno&#x27;]): ?&gt; &lt;option value=&quot;&lt;?=$rs[&#x27;zno&#x27;]?&gt;&quot; selected=&quot;selected&quot;&gt;&lt;?=$rs[&#x27;zname&#x27;]?&gt;&lt;/option&gt; &lt;?php else: ?&gt; &lt;option value=&quot;&lt;?=$rs[&#x27;zno&#x27;]?&gt;&quot;&gt;&lt;?=$rs[&#x27;zname&#x27;]?&gt;&lt;/option&gt; &lt;?php endif; ?&gt; &lt;?php endwhile; ?&gt; &lt;/select&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;right&quot;&gt;所在班级&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;txtsclass&quot; value=&quot;&lt;?=$rs2[&#x27;sclass&#x27;]?&gt;&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;right&quot;&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;submit&quot; name=&quot;btn_update&quot; value=&quot;update&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/form&gt;&lt;?php endif; ?&gt;&lt;?phpif (isset($_POST[&#x27;btn_update&#x27;]))&#123; $sno = $_POST[&#x27;txtsno&#x27;]; $sname = $_POST[&#x27;txtsname&#x27;]; $ssex = $_POST[&#x27;rdossex&#x27;]; $sbirth = $_POST[&#x27;txtsbirth&#x27;]; $zno = $_POST[&#x27;majors_zno&#x27;]; $sclass = $_POST[&#x27;txtsclass&#x27;]; $query3 = &quot;UPDATE student SET sno=&#x27;$sno&#x27;, sname=&#x27;$sname&#x27;, ssex=&#x27;$ssex&#x27;, sbirth=&#x27;$sbirth&#x27;, zno=&#x27;$zno&#x27;, sclass=&#x27;$sclass&#x27; WHERE sno=&#x27;$sno&#x27;&quot;; $result3 = mysqli_query($link, $query3); if ($result3)&#123; echo &quot;读取数据集成功&lt;br&gt;&quot;; echo &quot;update successfully!&lt;br&gt;&quot;; ; &#125;else&#123; echo &quot;读取数据集失败&lt;br&gt;&quot;; &#125;&#125;?&gt;&lt;/body&gt;&lt;/html&gt; deletion.php 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Crud Boy&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;?php$sno = $_GET[&#x27;sno&#x27;];$link = mysqli_connect(&quot;localhost&quot;, &quot;root&quot;, &quot;&quot;, &quot;jxgl&quot;);if ($link) &#123; echo &quot;连接本地mysql服务器成功！&lt;br&gt;&quot;; $data = mysqli_select_db($link, &quot;jxgl&quot;); mysqli_set_charset($link, &#x27;utf8&#x27;); if ($data)&#123; echo &quot;选择jxgl成功&lt;br&gt;&quot;; $query = &quot;DELETE FROM student WHERE sno = &#x27;&#123;$sno&#125;&#x27;&quot;; $result = mysqli_query($link, $query); $query2 = &quot;DELETE FROM sc WHERE sno = &#x27;&#123;$sno&#125;&#x27;&quot;; $result2 = mysqli_query($link, $query2); if ($result and $result2)&#123; echo &quot;读取数据集成功&lt;br&gt;&quot;; echo &quot;delete successfully!&lt;br&gt;&quot;; &#125;else&#123; echo &quot;读取数据集失败&lt;br&gt;&quot;; &#125; &#125;else&#123; echo &quot;选择jxgl失败&lt;br&gt;&quot;; &#125;&#125;else &#123; echo &quot;连接本地mysql服务器失败！&quot;;&#125;?&gt;&lt;/body&gt;&lt;/html&gt; insert_student_info.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Crud Boy&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;?php$link = mysqli_connect(&quot;localhost&quot;, &quot;root&quot;, &quot;&quot;, &quot;jxgl&quot;);if ($link) &#123; echo &quot;连接本地mysql服务器成功！&lt;br&gt;&quot;; $data = mysqli_select_db($link, &quot;jxgl&quot;); mysqli_set_charset($link, &#x27;utf8&#x27;); if ($data)&#123; echo &quot;选择jxgl成功&lt;br&gt;&quot;; $query = &quot;SELECT * FROM specialty&quot;; $result = mysqli_query($link, $query); if ($result)&#123; echo &quot;读取数据集成功&lt;br&gt;&quot;; ; &#125;else&#123; echo &quot;读取数据集失败&lt;br&gt;&quot;; &#125; &#125;else&#123; echo &quot;选择jxgl失败&lt;br&gt;&quot;; &#125;&#125;else &#123; echo &quot;连接本地mysql服务器失败！&quot;;&#125;?&gt;&lt;form action=&quot;#&quot; method=&quot;post&quot;&gt;&lt;center&gt;&lt;h2&gt;crud学生信息&lt;/h2&gt;&lt;/center&gt;&lt;table border=&quot;1&quot; align=&quot;center&quot; width=&quot;1000&quot;&gt; &lt;tr&gt; &lt;td align=&quot;right&quot;&gt;学号&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;txtsno&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;right&quot;&gt;姓名&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;txtsname&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;right&quot;&gt;性别&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;radio&quot; name=&quot;rdossex&quot; value=&quot;男&quot;&gt;男 &lt;input type=&quot;radio&quot; name=&quot;rdossex&quot; value=&quot;女&quot; checked=&quot;checked&quot;&gt;女 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;right&quot;&gt;出生日期&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;txtsbirth&quot;&gt;(形如：YYYY-MM-DD)&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;right&quot;&gt;专业&lt;/td&gt; &lt;td&gt; &lt;select name=&quot;majors_zno&quot;&gt; &lt;?php if (isset($result)): ?&gt; &lt;?php while ($rs = mysqli_fetch_array($result, MYSQLI_ASSOC)): ?&gt; &lt;option value=&quot;&lt;?=$rs[&#x27;zno&#x27;]?&gt;&quot;&gt;&lt;?=$rs[&#x27;zname&#x27;]?&gt;&lt;/option&gt; &lt;?php endwhile; ?&gt; &lt;?php endif; ?&gt; &lt;/select&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;right&quot;&gt;所在班级&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;txtsclass&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;right&quot;&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;submit&quot; name=&quot;btn_insert&quot; value=&quot;insert&quot;&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/form&gt;&lt;?phpif (isset($_POST[&#x27;btn_insert&#x27;]))&#123; $sno = $_POST[&#x27;txtsno&#x27;]; $sname = $_POST[&#x27;txtsname&#x27;]; $ssex = $_POST[&#x27;rdossex&#x27;]; $sbirth = $_POST[&#x27;txtsbirth&#x27;]; $zno = $_POST[&#x27;majors_zno&#x27;]; $sclass = $_POST[&#x27;txtsclass&#x27;]; $query2 = &quot;INSERT INTO student SET sno=&#x27;$sno&#x27;, sname=&#x27;$sname&#x27;, ssex=&#x27;$ssex&#x27;, sbirth=&#x27;$sbirth&#x27;, zno=&#x27;$zno&#x27;, sclass=&#x27;$sclass&#x27;&quot;; $result2 = mysqli_query($link, $query2); if ($result2)&#123; echo &quot;读取数据集成功&lt;br&gt;&quot;; echo &quot;insert successfully!&lt;br&gt;&quot;; ; &#125;else&#123; echo &quot;读取数据集失败&lt;br&gt;&quot;; &#125; &#125;?&gt;&lt;/body&gt;&lt;/html&gt; 第18次作业 1 整型 浮点型 定点型 日期时间类型 字符型 TINYINT FLOAT DECIMAL YEAY CHAR SMALLINT DOUBLE TIME VARCHAR MEDIUMINT DATE TINYTEXT INT DATETIME TEXT BIGINT TIMETAMP MEDIUMTEXT LONGTEXT ENUM(&quot;&quot;, “”, ……) SET(&quot;&quot;, “”, ……) 2 having是在分组后对数据进行过滤 where是在分组前对数据进行过滤 having后面可以使用聚合函数 where后面不可以使用聚合 3 count()函数：实现统计表中数据的条数 avg()函数：实现计算字段值的平均值 sum()函数：实现计算字段值的总和 max()函数：实现查询字段值的最大值 min()函数：实现查询字段值的最小值 4-27 D C B A A A A C B C A B B A A D C B C D C B B 第19次作业 1 连接mysql服务器 选择mysql数据库 执行sql语句 关闭结果集 关闭mysql服务器 2 使用mysqli_fetch_array()从结果集中获取一行作为对象 使用mysqli_fetch_array()从结果集中获取一行作为数组 3 1-3 12345678CREATE DATABASE tom;USE tom;CREATE TABLE &#x27;tomcat&#x27; (&#x27;name&#x27; char(10), &#x27;age&#x27; int(6));INSERT INTO tomcat SET name = &#x27;li1&#x27;, age = 15;INSERT INTO tomcat SET name = &#x27;li2&#x27;, age = 16;INSERT INTO tomcat SET name = &#x27;li3&#x27;, age = 17;INSERT INTO tomcat SET name = &#x27;li4&#x27;, age = 18;INSERT INTO tomcat SET name = &#x27;li5&#x27;, age = 19; 4 123456789101112131415161718192021222324$link = mysqli_connect(&quot;localhost&quot;, &quot;root&quot;, &quot;&quot;, &quot;tom&quot;);if ($link) &#123; echo &quot;连接本地mysql服务器成功！&lt;br&gt;&quot;; $data = mysqli_select_db($link, &quot;tom&quot;); mysqli_set_charset($link, &#x27;utf8&#x27;); if ($data)&#123; echo &quot;选择tom成功&lt;br&gt;&quot;; $query = &quot;SELECT * FROM tomcat&quot;; $result = mysqli_query($link, $query); if ($result)&#123; echo &quot;读取数据集成功&lt;br&gt;&quot;; while ($rs = mysqli_fetch_array($result, MYSQLI_ASSOC))&#123; echo $rs[&#x27;name&#x27;].&quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;.$rs[&#x27;age&#x27;].&quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;; &#125; echo &quot;共有数据：&quot;.mysqli_num_rows($result).&quot;条&quot;; &#125;else&#123; echo &quot;读取数据集失败&lt;br&gt;&quot;; &#125; &#125;else&#123; echo &quot;选择jxgl失败&lt;br&gt;&quot;; &#125;&#125;else &#123; echo &quot;连接本地mysql服务器失败！&quot;;&#125; 4-10 D B D A D A D 构造方法可以带参数，但不能有return 第20次作业 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?php class Circle &#123; private $radius; const pi = 3.1415926; public function __construct($radius = 0) &#123; $this-&gt;radius = $radius; &#125; public function __set($name, $value) &#123; // TODO: Implement __set() method. if ($value &gt;= 0) &#123; $this-&gt;$name = $value; &#125; else &#123; exit(&#x27;your radius is illegal&#x27;); &#125; &#125; public function __get($name) &#123; // TODO: Implement __get() method. if (isset($this-&gt;$name)) &#123; return $this-&gt;$name; &#125; else &#123; return null; &#125; &#125; public function getPerimeter() &#123; return 2 * self::pi * $this-&gt;radius; &#125; public function getArea() &#123; return self::pi * pow($this-&gt;radius, 2); &#125; &#125; $circle1 = new Circle(3); echo &quot;&lt;hr&gt;perimeter is &quot;.$circle1-&gt;getPerimeter(); echo &quot;&lt;hr&gt;area is &quot;.$circle1-&gt;getArea(); 面向对象编程时，所有方法和成员变量都要带上关键字，倒不是说必须，而是一种好的编程习惯 每个类尽量放在单独的一个php文件中，并且该php文件与存放的类名保持一致，这是一个好习惯。 1-9 ↩︎","categories":[],"tags":[]},{"title":"C语言控制台打印图标小技巧","slug":"C_Print_icon","date":"2022-09-18T16:00:00.000Z","updated":"2022-10-19T09:06:43.750Z","comments":true,"path":"2022/09/19/C_Print_icon/","link":"","permalink":"http://example.com/2022/09/19/C_Print_icon/","excerpt":"","text":"打印左直角三角形： 123456789101112131415#include &lt;stdio.h&gt;int main(void) &#123; for(int i = 1; i &lt;= 7; ++i)&#123; for (int j = 1; j &lt;= i; ++j)&#123; // 技巧在于 j &lt;= i printf(&quot;*&quot;); &#125; // for(int j = 1; j &lt;= i; ++j)&#123; // printf(&quot;*&quot;); // &#125; printf(&quot;\\n&quot;); &#125; return 0;&#125; 打印右直角三角形： 1234567891011121314151617#include &lt;stdio.h&gt;int main(void) &#123; for(int i = 1; i &lt;= 7; ++i)&#123; for (int j = 6; j &gt;= i; --j)&#123; /* 这里是 j = 6开始，为什么不是7呢， 因为如果是7，在最后一行就会多打一个空格出来。*/ printf(&quot; &quot;); &#125; for(int j = 1; j &lt;= i; ++j)&#123; // 其实我们打印左直角三角形，还是打印右直角三角形，还是等腰，每行打印的 * 号数量都不变，他的形状变化主要用空格来调控。 printf(&quot;*&quot;); &#125; printf(&quot;\\n&quot;); &#125; return 0;&#125; 打印等腰三角形： 12345678910111213141516#include &lt;stdio.h&gt;int main(void) &#123; for(int i = 1; i &lt;= 7; ++i)&#123; for (int j = 6; j &gt;= i; --j)&#123; printf(&quot; &quot;); &#125; for(int j = 1; j &lt;= i; ++j)&#123; printf(&quot;* &quot;); // 只需在右直角三角形的*后面加空格。 //加一个空格为什么就能变成等腰三角形呢？第一行多打印了1个空格，第2行多打印了2个空格，以此类推 &#125; printf(&quot;\\n&quot;); &#125; return 0;&#125; 打印图形这种题目，把它化成函数很容易解决，比如下面这个： 1234567891011121314int main()&#123; int n = 0; scanf(&quot;%d&quot;, &amp;n); char c = &#x27;A&#x27;; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt;= i; ++j) &#123; printf(&quot;%c&quot;, c); &#125; printf(&quot;\\n&quot;); ++c; &#125; return 0;&#125; 我们输入6，输出： 123456ABBCCCDDDDEEEEEFFFFFF 其中第1个循环相当于给出x的范围，第2个循环相当于在坐标轴上打印 y &lt;= x 我们改一下第2个循环的函数曲线： 123456789101112131415int main()&#123; int n = 0; scanf(&quot;%d&quot;, &amp;n); char c = &#x27;A&#x27;; for (int i = 0; i &lt; n; ++i) &#123; int n2 = n / 2; for (int j = 0; j &lt;= (n2 - abs(n2 - i)); ++j) &#123; printf(&quot;%c&quot;, c); &#125; printf(&quot;\\n&quot;); ++c; &#125; return 0;&#125; 我们输入7，输出： 1234567ABBCCCDDDDEEEFFG 如果我们想让输出的每一行的字母个数都是奇数，该这样做： 1234567891011121314int main()&#123; int n = 0; scanf(&quot;%d&quot;, &amp;n); char c = &#x27;A&#x27;; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 1; j &lt;= 2 * i + 1; ++j) &#123; printf(&quot;%c&quot;, c); &#125; printf(&quot;\\n&quot;); ++c; &#125; return 0;&#125; 我们输入5，输出： 12345ABBBCCCCCDDDDDDDEEEEEEEEE 同样的，更改y函数也可以让输出的每一行的字母个数都是奇数： 123456789101112131415int main()&#123; int n = 0; scanf(&quot;%d&quot;, &amp;n); char c = &#x27;A&#x27;; for (int i = 0; i &lt; n; ++i) &#123; int n2 = n / 2; for (int j = 1; j &lt;= 2 * (n2 - abs(n2 - i)) + 1; ++j) &#123; printf(&quot;%c&quot;, c); &#125; printf(&quot;\\n&quot;); ++c; &#125; return 0;&#125; 我们输入7，输出： 1234567ABBBCCCCCDDDDDDDEEEEEFFFG","categories":[],"tags":[]},{"title":"解决CLion中建立多个c/cpp文件(多个main函数共存)的问题","slug":"CLion-Single-File-Execution","date":"2022-09-05T07:08:12.000Z","updated":"2022-09-05T07:49:14.241Z","comments":true,"path":"2022/09/05/CLion-Single-File-Execution/","link":"","permalink":"http://example.com/2022/09/05/CLion-Single-File-Execution/","excerpt":"","text":"用下面这些方法需要注意，既然在 Cmakelists.text 文件里多了几行add_executable(……)，那么删除项目里c文件或者cpp文件时，就必须记得连同Cmakelists.text 文件里相应的add_executable(……)一同删去，否则会警告。 另外，add executable for simple C/C++ file 后别忘了Cmakelists.text重新加载变更，否则会有警告。 另外，一个project里面貌似不能既有cpp又有c文件。我不确定哈，只是我目前这样做cpp会报错。 贴链接： 使用CLion 刷题解决多个main函数问题的终极方法 解决CLion中建立多个c/cpp文件(多个main函数共存)的问题 Clion如何编译运行多个源文件 感谢Kosuke Nakago和他的C/C+​+​ Single File Execution","categories":[],"tags":[]},{"title":"小作业1-登录功能(控制台)","slug":"FunctionLogin-1","date":"2022-08-30T10:30:31.000Z","updated":"2022-08-30T14:21:11.315Z","comments":true,"path":"2022/08/30/FunctionLogin-1/","link":"","permalink":"http://example.com/2022/08/30/FunctionLogin-1/","excerpt":"","text":"小作业 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169/* 根据以下要求, 实现一套登录功能 已知有全局变量 int[] ids = &#123;10001,10002,10003,10004&#125;; String[] names = &#123;&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;, &quot;赵六&quot;&#125;; String[] passwords = &#123;&quot;aaaaa&quot;,&quot;bbbbb&quot;,&quot;ccccc&quot;,&quot;ddddd&quot;&#125;; int uNum = 4; 其中 每个下标对应一套用户数据(id, 名称, 密码) 如下标[1]: 对应10002, 李四, bbbbb 根据以下的函数声明和注释, 写出相应的函数实现 */import java.util.Scanner;public class FunctionLogin&#123; public static void main(String[] args) &#123; Function F1 = new Function(); F1.showLoginPage(); &#125;&#125;class Function &#123; // 定义字段 int[] ids = &#123;10001, 10002, 10003, 10004&#125;; String[] names = &#123;&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;, &quot;赵六&quot;&#125;; String[] passwords = &#123;&quot;aaaaa&quot;, &quot;bbbbb&quot;, &quot;ccccc&quot;, &quot;ddddd&quot;&#125;; int uNum = 4; int id; String password; String name;/* 功能: 根据id 查询用户是否存在, 如果存在返回用户名, 如果不存在返回空 参数: uid: 用户id 返回值: 如果用户存在, 返回用户名. 如果用户不存在, 返回NULL*/ public String selectUserById(int uid) &#123; for (int i = 0; i &lt; uNum; i++)&#123; if (ids[i] == uid)&#123; this.name = names[i]; &#125; &#125; //属性String型如果不初始化则默认赋null return this.name; &#125;/* 功能: 根据id 查询用户密码, 如果存在返回用户密码, 如果不存在返回空 参数: uid: 用户id 返回值: 如果密码存在, 返回密码. 如果密码不存在, 返回NULL*/ public String selectPassById(int uid) &#123; for (int i = 0; i &lt; uNum; i++)&#123; if (ids[i] == uid)&#123; this.password = passwords[i]; &#125; &#125; //属性String型如果不初始化则默认赋null return this.password; &#125;/* 功能: 传入用户id和密码, 根据上面两个函数(selectUserById, selectPassById)来获取相应用户数据, 并判断是否登录成功 传入用户id 查询用户名是否存在, 并获取用户密码 如果用户存在 则判断密码是否正确 参数: uid: 用户账户 password: 用户密码 返回值: 如果账号不存在, 返回1 如果密码错误, 返回2 如果登录成功, 返回0*/ public int login(int uid, String uPassword)&#123; int res = 0; this.name = selectUserById(uid); this.password = selectPassById(uid); if (this.name == null)&#123; res = 1; &#125; if (this.password == null)&#123; res = 2; &#125; if (res == 0) &#123; if (this.password.equals(uPassword)) &#123; System.out.println(&quot;您输入的密码正确！\\n&quot;); &#125; else &#123; System.out.println(&quot;您输入id正确，但密码有误\\n&quot;); res = 3; &#125; &#125; return res; &#125;/* 功能: 提示用户输入账号密码, 根据login函数判断是否登录成功, 如果登录成功提示正在进入首页 如果登录失败 密码错误: 提示密码错误, 并让用户重新登录 账号不存在: 提示账号不存在, 并提示正在进入注册界面 参数: 无 返回值: 无*/ public void showLoginPage() &#123; Scanner myScanner = new Scanner(System.in); System.out.println(&quot;请依次输入您的id和密码\\n&quot;); int uid2 = myScanner.nextInt(); String uPassword2 = myScanner.next(); int rly = login(uid2, uPassword2); switch (rly) &#123; case 0 -&gt; System.out.println(&quot;登录成功，正在进入首页……\\n&quot;); case 1 -&gt; System.out.println(&quot;您输入的id不存在，正在重新进入注册界面……\\n&quot;); case 2 -&gt; System.out.println(&quot;根据您的id查询不到相应密码，正在重新进入注册界面……\\n&quot;); case 3 -&gt; System.out.println(&quot;您的id输入正确，但密码输入错误，清重新登录！\\n&quot;); default -&gt; System.out.println(&quot;Who care ?\\n&quot;); &#125; &#125;/* 实现一套注册功能 */ public void registerYou()&#123; Scanner myScanner = new Scanner(System.in); System.out.println(&quot;请给您的账户起一个好听的名字\\n&quot;); String newName = myScanner.next(); System.out.println(&quot;请给您的账户输入一个密码\\n&quot;); String newPassWord = myScanner.next(); int[] ids2 = new int[1000]; String[] names2 = new String[1000]; String[] passwords2 = new String[1000]; for (int i = 0; i &lt; uNum; i++)&#123; ids2[i] = this.ids[i]; names2[i] = this.names[i]; passwords2[i] = this.passwords[i]; &#125; ids2[uNum] = 10000 + (uNum + 1); names2[uNum] = newName; passwords2[uNum] = newPassWord; ++uNum; this.ids = ids2; this.names = names2; this.passwords = passwords2; int rly2 = login(this.ids[uNum - 1], this.passwords[uNum - 1]); if (rly2 == 0)&#123; System.out.println(&quot;恭喜您，注册成功！&quot;); &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"韩总Java修仙","slug":"Java-learning","date":"2022-08-21T08:23:00.000Z","updated":"2022-11-15T02:56:13.762Z","comments":true,"path":"2022/08/21/Java-learning/","link":"","permalink":"http://example.com/2022/08/21/Java-learning/","excerpt":"","text":"环境搭建 IDEA自带JDK吗 下载idea的时候可以选带JDK的或者不带的，默认带JDK的，理论上也可以不用外部的，配置自带的JDK即可，不过Idea自带的是OpenJDK，不是oracle jdk; idea自带jdk，是openjdk，idea是使用Java开发的，所以为了在一台没有配置过Java环境的电脑上也可以运行idea，又考虑了商业版权问题，所以采用了OpenJDK JDK、JRE、JVM之间的关系 JDK(Java Development Kit):Java开发工具包，提供给Java程序员使用，包含了JRE，同时还包含了编译器javac与自带的调试工具Jconsole、jstack等。，它提供了Java的开发环境(提供了编译器javac等工具，用于将java文件编译为class文件)和运行环境(提供了JVM和Runtime辅助包，用于解析class文件使其得到运行)。如果你下载并安装了JDK，那么你不仅可以开发Java程序，也同时拥有了运行Java程序的平台。 JDK是整个Java的核心，包括了Java运行环境(JRE)，一堆Java工具tools.jar和Java标准类库 (rt.jar)。当今最流行的两个Java开发工具包(JDK):Oracle JDK和 OpenJDK，常用Oracle JDK。 JRE(Java Runtime Environment):Java运行时环境，包含了JVM，Java基础类库。是使用Java语言编写程序运行的所需环境。JRE面向Java程序的使用者，而不是开发者。如果你仅下载并安装了JRE，那么你的系统只能运行Java的class程序。JRE是运行Java程序所必须环境的集合，包含JVM标准实现及 Java核心类库。它包括Java虚拟机、Java平台核心类和支持文件。 它不包含开发工具(编译器、调试器等)。 JVM(Java Virtual Machine)：Java虚拟机，运行Java代码。不同的操作系统需要安装不同版本的JVM，而JVM是JDK的子集，因此，JDK也有对应不同操作系统的各种版本。JVM屏蔽底层运行平台的差别，从而实现“一次编译，到处运行”。 JDK=JRE+开发工具集(比如:javac) JRE=JVM+JavaSE标准类库 综上，JDK是JRE的超集，而JRE又是JVM的超集 JavaSE、JavaEE、JavaME Java是一门编程语言, 分为 JavaSE、JavaEE、JavaME 三大版本. JavaSE (Java Platform，Standard Edition, 标准版) also known as Java 2 Platform 可以开发和部署在桌面、服务器、嵌入式环境和实时环境中使用的 Java 应用程 序。 Java SE 包含了支持 Java Web 服务开发的类是EE，和ME的基础。javaSE是java的基石，如果将java程序想象成一座高楼大厦，那么javaSE就是地基。 主要做一般的java应用, 比如, 应用软件/ QQ之类的通信软件等等. 此前叫做J2SE Java EE (Java Platform，Enterprise Edition, 企业版) 是Sun公司为企业级应用推出的标准平台。JavaEE是个大杂烩，包括Applet、EJB、JDBC、JNDI、Servlet、JSP等技术的标准，运行在一个完整的应用服务器上，用来开发大规模、分布式、健壮的网络应用。 其实是一套规范，就是用java语言做企业开发, 比如公司网站, 企业解决方案等 在JavaSE的基础上构建 提供Web 服务、组建模型、管理和通信API.可以用来实现企业级的面向服务体系结构(service-oriented architecture,SOA)和web2.0应用程序 此前叫做J2EE JavaWeb 主要指以Java语言为基础 可以粗略地认为JavaWeb就是JavaEE的一部分 利用JavaEE中的Servlet, JSP等技术开发动态页面, 方便用户通过浏览器与服务器后台交互 Java Web应用程序可运行在一个轻量级的Web服务器中，比如Tomcat。 Java ME (Java Platform，Micro Edition, 微型版) 写移动端(移动设备和嵌入式设备（比如手机、PDA、电视机顶盒和打印机）。javaME这一块只需要了解就可以了，因为现在很少有使用这个东西的了， SDK 与 JDK的区别 SDK（Software Development Kit） 软件开发工具包，是一个相当广泛的名词， 可以这么说辅助开发某一类软件的相关文档，范例和工具的集合都可以叫做“SDK”。SDK是一系列文件的组合，它为软件的开发提供了一个平台。 JDK（Java Development Kit）Java 开发工具包，是针对Java开发的产品。 JDK是SDK的一个子集，因为它是开发java程序的一个平台，开发其他程序的SDK可以没有JDK。比如你下载了一个软件平台eclipse-SDK-3.2.2-win32.zip，它本身里面是没有JDK的。但是只要开发Java程序就必须使用JDK（Java EE和Java SE） Day 1 java是编译型语言还是解释型语言？ 现在用编译型、解释型来分类编程语言已经有点力不从心了。java的javac编译器(全称java compiler)先将其编译为class文件，也就是字节码；然后将字节码交由jvm(java虚拟机)解释执行；所以很多地方都说“java是一种半编译、半解释执行”的语言；现在倾向于避开把编程语言描述为“编译型”或者“解释性”的。 java诞生 1990年 SUN公司启动绿色计划，希望在一些设备，比如电视、冰箱、微波炉、机顶盒上编程。 1992年创建oak(橡树)语言，最开始叫“Oak”，是一种在硅谷很常见的橡树。但开发公司在申请注册商标时发现，Oak已经被使用了。如果没有一个合适的名字，他们不得不延后这个语言的面世。没有办法，开发公司只好召开了一个命名征集会，在命名顾问一系列名字之后，最终，使用了Java这一名字。Java其实是印度尼西亚爪哇岛的英文名称，当地因盛产咖啡而闻名。据说，命名者就是在与同事品尝Java咖啡时得到的灵感。 1994年gosling在硅谷大会上演示Java一个可以在网页上展示动态图的功能震惊了世界，当时网页只能展示静态图。 1995年SUN正式发布Java第一个版本 2009甲骨文(Oracle)公司宣布收收购SUN。2011，发布java7。目前java是Oracle的，也是由它维护的。 2014发布java8，该版本也是现在企业用的最广泛的。因为该版本∈LTS(long-term-support)，即长期支持版。Java11也是LTS，像什么第9版第10版，第12版第13版，都不是LTS，都已经不可获得了，所以8和11版本也是现在企业用的最广泛的。因此我们一般学习8和11的特性。 第一个程序入门 123456789101112131415//这是java的快速入门，演示java的开发步骤//对代码的相关说明//1. public class HelloWorld是一个java 类，这也是我们创建时点类的原因，是一个public公有类//2. HelloWorld&#123;&#125; 表示一个类的开始和结束。//3. public static void main(String[] args) 表示一个主方法，即我们程序的入口。//4. main()&#123;&#125; 表示方法的开始和结束。//5. System.out.println(&quot;Hello World !&quot;); 表示输出&quot;Hello World !&quot;到屏幕。//6. ; 表示语句的结束。public class HelloWorld &#123; // 编写一个main方法 public static void main(String[] args) &#123; System.out.println(&quot;Hello World !!&quot;); &#125;&#125; JAVA运行机制 .java 文件称为源文件，经过javac编译为 .class 文件，又称字节码文件，再装载给JVM运行。修改源文件记得重新编译为新的字节码文件。 JAVA开发注意事项 JAVA源文件以.java为扩展名，不要乱改。 JAVA语言严格区分大小写。 JAVA方法由一条条语句构成，每个语句以 ; 结束。 {} 只能成对出现。 源文件的基本组成部分是类(class)，如HelloWorld类 一个源文件中最多只能有一个public类，其它类的个数不限。 如果源文件中包含一个public类，则文件名必须按照该类名命名。 JAVA应用程序的执行入口是main()方法，它有固定的书写格式，即：public static void main(String[] args) {} ，不得乱改。 也可以将main()方法写在非public类中，然后指定运行非public类，这样入口方法就是非public的main方法。一个class文件中只能有一个mian()方法，否则在编译运行的时候会出错。 如果一个java文件中有多个类,除去内部类,剩下的每个普通类都会生成一个class文件。 12345678910111213141516171819202122232425262728//这是java的快速入门，演示java的开发步骤//对代码的相关说明//1. public class HelloWorld是一个java 类，这也是我们创建时点类的原因，是一个public公有类//2. HelloWorld&#123;&#125; 表示一个类的开始和结束。//3. public static void main(String[] args) 表示一个主方法，即我们程序的入口。//4. main()&#123;&#125; 表示方法的开始和结束。//5. System.out.println(&quot;Hello World !&quot;); 表示输出&quot;Hello World !&quot;到屏幕。//6. ; 表示语句的结束。public class HelloWorld &#123; // 编写一个main方法 public static void main(String[] args) &#123; System.out.println(&quot;Hello World !!&quot;); &#125;&#125;// Dog也是一个类，//编译后，每一个类，都对应一个.class文件class Dog&#123; //也可以将main()方法写在非public类中，然后指定运行非public类，这样入口方法就是非public的main方法 public static void main(String[] args) &#123; System.out.println(&quot;Hello Dog !!&quot;); &#125;&#125;class Cat &#123; public static void main(String[] args) &#123; System.out.println(&quot;Hello Cat !!&quot;); &#125;&#125; JAVA常见错误 常见的语法错误是最容易修改的，因为编译器一般会报错并给出原因，虽然有时候原因会很笼统。业务错误和环境错误更难改，业务错误指语法没有错误，编译不会报错，但是代码逻辑写错了，达不到业主需求。环境错误指，我在本地跑没有任何问题，在另一台机器上run就报错。 comment 单行注释：//注释文字 多行注释：/* 注释文字 */，注意，多行注释不允许嵌套使用，即 / * 注释文字 * /里面不允许再有/ * 文档注释：注释内容可以被JDK提供的工具 javadoc 所解析，生成一套以网页文件形式体现的该程序的说明文档，一般写在类。文档注释用的还是蛮多的。文档注释只放在类、接口、成员变量、方法之前，因为 Javadoc 只处理这些地方的文档注释，而忽略其它地方的文档注释。 Javadoc 是 Sun 公司提供的一种工具，它可以从程序源代码中抽取类、方法、成员等注释，然后形成一个和源代码配套的 API 帮助文档。也就是说，只要在编写程序时以一套特定的标签注释，在程序编写完成后，通过 Javadoc 就形成了程序的 API 帮助文档。API 帮助文档相当于产品说明书，而说明书只需要介绍那些供用户使用的部分，所以 Javadoc 默认只提取 public、protected 修饰的部分。如果要提取 private 修饰的部分，需要使用 -private。 java代码规范 截止目前，我们所学甚少，所以java代码规范先讲8条，后面会增加。 类、方法的注释，要以 javadoc 的方式来写，因为 Javadoc 只处理这些地方的文档注释，而忽略其它地方的文档注释。JAVA的设计者就是经常用文档注释；javadoc往往给用户看的。 单行注释，、多行注释，往往是给代码的维护者看的，着重告诉读者为什么要这么写。 使用TAB键，实现代码的缩进和自动补全，使用shift+tab，可以取消一个缩进； 运算符两边习惯性加一个空格(Spacebar)，JAVA设计者就是这么做的。如 int a = 1 + 2; 源文件使用UTF-8编码； 一行的宽度不超过80个字符，太宽了读起来不方便； 代码编写推荐行尾风格，但是次行风格也是正确的； 行尾风格： if (a &gt; b){ a=; } 次行风格： if (a &gt; b) { a=; } Day 2 DOS命令是什么 DOS : Disk Operating System 磁盘操作系统 我们在控制台输入DOS指令时，控制台会把指令发送给DOS系统，DOS系统会对windows文件系统进行相应的操作。 Linux下用DOS命令比较多。 相对路径和绝对路径 文件夹在编程里面称为目录。 比如，D盘下面有abc1文件夹和abc2文件夹，abc1文件夹下面有一个test1文件夹，abc2文件夹下面有一个test2文件夹. 相对路径：从当前目录(当前文件夹)开始定位，形成的一个路径。 绝对路径：从顶级目录(例子中是D盘)，开始定位，形成的一个路径。 如果当前目录在test1，我们想访问test2， 相对路径是 …\\abc2\\test2 绝对路径是 D:\\abc2\\test2 …\\是返回上一级目录。 JAVA中+号的使用 当+号左右两边都是数值型时，则做数学上的加法运算。 当+号左右两边有任何一方为字符串时，则做拼接运算。 举例： 100+98 输出：198 “100”+98 输出：“10098” 100+3+“hello” 输出：“103hello” “hello”+100+3 输出：“hello1003” JAVA的数据类型 JAVA是强类型语言，分为两种， 基本数据类型： 数值型： 整数类型： byte:1个字节； short:2个字节； int:4个字节； long:8个字节； 浮点类型： float:4个字节； double:8个字节； 字符型：char:2个字节(C语言里char类型占用1个字节)； 布尔类型：boolean:占用1个字节，存放true,false。 引用数据类型(复杂数据类型)： 类(class);(string就是类) 接口(interface); 数组([]); JAVA整型细节 JAVA里面的各种整型的长度是固定的，不受具体OS的影响，以保证java程序的可移植性，这一点与C不同，C语言里int和long的长度取决于编译器和CPU。 java中通常用int声明整型即可，除非超出int范围了。如果我们不能保证一定不会超过int范围，就用long。 java的整型的字面量默认为int型(这一点和C一样)，如果声明long类型，则字面量后面必须加上&quot;l&quot;或&quot;L&quot;，建议大写L结尾。比如long a=2147483648，则默认a是int型，会超出int范围而报错，long a=2147483648L a才是long型。 Day 3 JAVA浮点数细节 与整型类似，java浮点数也是固定长度，和OS无关； JAVA的浮点数的字面量默认是double型，声明float时，字面量必须加“f”或“F”， float a=1.1; 是错的，因为1.1默认是double是8个字节，而float是4个字节； float b=1.1F; 是对的； double c=1.1F; 是对的； 浮点数如果是0.几，允许把个位的0省略。比如double a=0.52，可以写成dpuble a= .52 通常情况下，我们一般使用double型，而且JAVA也是默认double型。 由于计算机的缺陷，导致小数在计算机内部并不能被准确表达，这一点已经在C语言里了解过了，所以不能轻易将浮点数的运算结果和某个小数做相等判断，应该用两值之差的绝对值做精度判断，小于一个很小的数就能得出两个浮点数相等。但是如果是 double a=2.7; double b=2.7; a和b可以直接判断相等，因为这是直接赋的。 JAVA API文档 API:(Application Programming Interface),即应用程序编程接口，是java设计者给我们提供的一些类，还有一些方法。也即java标准类库提供的函数，android开发的api是指android sdk函数库。也可以解释为一些预先定义的接口，目的是提供应用程序与开发人员基于某软件或硬件的以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。还有一个很泛的解释，即可以直接调用的东西都可以称作API。 JAVA API文档：是指把这些API收录在一个字典里，这个字典就叫JAVA API文档。 JAVA语言提供了大量基础类，Oracle也为这些基础类提供了相应的API文档。 想知道怎么使用JAVA API文档，有必要先了解JAVA类的组织形式。 JAVA类的组织形式： JDK 8、11、17 包1 包2 包3 …… 异常 接口1 接口2 接口3 …… 类1 类2 类3 …… 字段(又叫属性又叫成员变量) 构造器(构造方法) 成员方法(方法) 方法一：想查找一个方法，可以先弄清在哪个包下面，再找对应的类，就能找到这个方法。 方法二：直接搜索。 JAVA字符型介绍 字符类型char占2个字节，可以用来表示单个字符。可以存放汉字也可以存放英文。 多个字符我们可以用字符串string。 12345678910111213public class HelloWorld &#123; // 编写一个main方法 public static void main(String[] args) &#123; char c1 = &#x27;a&#x27;; char c2 = &#x27;韩&#x27;; char c3 = &#x27;\\t&#x27;; char c4 = 97; System.out.println(c1); System.out.println(c2); System.out.println(c3); System.out.println(c4); &#125;&#125; 输出： a 韩 a 字符型细节 字符型字面量是用‘’引起的，如果用“”，则代表字符串类型，编译器会报告错误； 逃逸字符看起来是2个字符，其实是1个字符； JAVA用的是Unicode编码规则； char的本质是一个整数型，它可以参与运算，这一点和C是一样的，它在计算机内存里面就是个数字，取决于我们输出时用整数型格式还是字符型格式。但是JAVA里char占2个字节，C里面占1个字节。 1234567891011121314151617181920212223public class HelloWorld &#123; // 编写一个main方法 public static void main(String[] args) &#123; /* 和C语言的char本质是一样的，输出什么取决于我们怎么选择什么格式，但在计算机里面始终是个整数， 和C不同的是，C的char类型窄字符采用ASCII码，JAVA采用Unicode；C的char占1个字节，java的char占2个字节*/ char c1 = 97; char c2 = &#x27;a&#x27;; char c3 = &#x27;韩&#x27;; char c4 = 38889; System.out.println(c1); System.out.println((int)c2); System.out.println((double)c2); System.out.println((int)c3); System.out.println(c3); System.out.println(c4); System.out.println(&#x27;a&#x27; + 10); char c5 = &#x27;b&#x27; + 1; System.out.println(c5); System.out.println((int)c5); int c = &#x27;a&#x27;; System.out.println(c); &#125;&#125; 输出： a 97 97.0 38889 韩 韩 107 c 99 97 boolean 在JAVA里面，不允许用0或者非0的整数代替false或true，这一点与C语言不同。在JAVA里，bool类型只能是true 或者 false，不能是其它值。 boolean isPass = true; √ if (isPass = ture){} boolean isPass = 1; × if (isPass = ture){} Day 4 JAVA 自动类型转换 当JAVA程序在进行赋值或者运算时，精度小的类型自动转换为精度大的数据类型。 数据类型按精度从小到大按下面2条路线可以实现自动转换： char——&gt;int——&gt;long——&gt;float——&gt;double byte——&gt;short——&gt;int——&gt;long——&gt;float——&gt;double byte 和 short 不会和 char 类型之间自动转换。 byte b1 = 10; char c1 = b1; × 虽然char容量比byte大，但是也不能这样赋值，原因就是byte类型不能自动转成char类型。编译器就是这么规定的，可以把它当成一个规则来理解。 short b2 = 10; char c1 = b2; × 原因同上 byte char short 三个类型的数，不管是同类型之间的运算，还是不同类型混合运算，在运算时首先转为int型才会运算。 byte b2 = 1; short s1 = 1; short s2 = b1 + s1; √ int s2 = b1 + s1; × byte b3 = 1; byte b4 = 1; byte b5 = b3 + b4; × 因为已经转为int了 int s3 = b3 + s4; √ int a = ‘a’; 对的，而且输出a是97，而且这个97在计算机内部占4个字节，说明char已经自动转换为int了，等价于：int a = 97; double b = 80; 对的，而且输出80.0，说明已经自动转换了. 有多种类型数据混合运算时，系统首先将所有数据转换成容量最大的那种数据类型，然后再1进行计算。 把容量大的赋值给容量小的数据类型，编译器会报错。 byte b1 = 10; 这个语句是对的，之前虽然说过java的整型的字面量默认为int型，我们猜测int赋给byte会报错，然而编译器并未报错，原因是，编译器会先检查该字面量10是否在byte范围内，如果在就可以；如果不行，再进行类型检查。这一点和C一样，比如C里面将一个double赋给float，先将双精度转为单精度，即只取6-7位有效数字，存储到float型变量的4个字节中，当double的数值大小不超出float的数值范围时，也不会报错，只是IDE会给警告。 int n1 = 1; byte b2 = n1; 这样编译就过不了，因为1在内存中已经是4个字节存放了，再赋给一个字节的b2就小了，所以如果是变量赋值，则不再检查是否在数据类型范围内，而是直接做类型检查。 但是可以强制类型转换： byte b2 = (byte)n1; √ JAVA/C++ 在类型转换上和C不同，虽然三种语言都是强类型语言，但JAVA/C类型检查要比C严格，举例，C语言中，int a = 1.1; 不会报错，而且会自动向下取整，最后a=1，我们还利用C语言的这个弱点实现了一些编程小套路，但是在JAVA/C中，这种把double赋给int是绝对不行的；再比如，调用函数时，给的参数类型和函数定义的参数类型不匹配，则C语言编译器会偷偷进行类型转换再传递给函数，但这可能不是你所期望的，所以这是C语言传统上最大的漏洞，JAVA/C++则会报错。 boolean不参与类型的自动转换。 boolean pass = true; int num = pass; 会报错 JAVA 强制类型转换 强制类型转换是自动类型转换的逆过程，将容量大的数据类型转为容量小的数据类型，但是一般会造成精度降低或者溢出，所以一般我们都是有意为之才这么做。 1234567public class HelloWorld &#123; // 编写一个main方法 public static void main(String[] args) &#123; int n1 = (int)1.9; //强制类型转换造成精度降低 System.out.println(&quot;n1=&quot; + n1); &#125;&#125; 输出：n1=1 ，造成精度降低 int n2 = 2000; byte b1 = (byte)n2; System.out.println(“b1=” + b1); 输出 b1 = -48 ,造成数据溢出。 强制转换只针对最近的操作数有效，往往会使用小括号提升优先级， int x = (int)10 * 3.5 + 6; 编译会报错，因为这里只会把10转换成int，3.5还是double，所以最后结果是dounle， int x = (int)(10 * 3.5 + 6); 这么写是对的 String和基本数据类型之间的转换 string是引用数据类型，是一种类，但我们优势需要将基本数据类型和string类型相互转换。 基本数据类型转string： 语法：将基本数据类型的值+&quot;&quot;即可 1234567891011121314public class HelloWorld &#123; // 编写一个main方法 public static void main(String[] args) &#123; int n1 = 100; float n2 = 100F; double n3 = 100; boolean n4 = true; String s1 = n1 + &quot;&quot;; //当+号左右两边有任何一方为字符串时，则做拼接运算。 String s2 = n2 + &quot;&quot;; String s3 = n3 + &quot;&quot;; String s4 = n4 + &quot;&quot;; System.out.println(s1 + &quot; &quot; + s2 + &quot; &quot; + s3 + &quot; &quot; + s4); &#125;&#125; 输出：100 100.0 100.0 true String转基本数据类型 在java里每一个基本数据类型都对应一个包装类，包装类提供一个方法，叫parseXX，XX是相应的数据类型，用这个方法就能转换成对应类型。 String转char类型只能取出String的一个字符，因为char只能存一个字符 1234567891011121314151617public class HelloWorld &#123; // 编写一个main方法 public static void main(String[] args) &#123; String s5 = &quot;123&quot;; int a = Integer.parseInt(s5); double b = Double.parseDouble(s5); float c = Float.parseFloat(s5); boolean d = Boolean.parseBoolean(&quot;true&quot;); System.out.println(a); System.out.println(b); System.out.println(c); System.out.println(d); System.out.println(s5.charAt(0)); System.out.println(s5.charAt(1)); System.out.println(s5.charAt(2)); &#125;&#125; 输出： 123 123.0 123.0 true 1 2 3 int这个基本数据类型对应的包装类就是Integer,这个包装类提供一个parseInt方法可以把String转换成int型。 在将String类型转成基本数据类型时，要确保String类型能够转成有效的数据，比如可以把“123”转成一个整数，但是不能把“hello”转成一个整数，否则虽然编译能过，但是执行时就会抛出异常，程序就会终止。反之，基本数据类型转字符串不存在这个问题。 md 文件写成 { {} }即可，否则hexo g 会报错 jdk8 怎么着都得装上，因为一些软件需要jdk8的环境，只装jd17满足不了","categories":[],"tags":[]},{"title":"走马观花《Code》第13章-如何实现减法","slug":"Code-chapter13","date":"2022-08-07T08:23:22.000Z","updated":"2022-08-10T06:45:52.483Z","comments":true,"path":"2022/08/07/Code-chapter13/","link":"","permalink":"http://example.com/2022/08/07/Code-chapter13/","excerpt":"","text":"继电器可以连接起来构成二进制加法器，那么减法器怎么实现？其实加法和减法在某些方面是相互补充的，但两者计算机制不同，加法用到进位这种机制，从最右边一列向左进位；减法不用进位而是借位。 比如,253-176这道题，3-6不够减，向十位借10，再减6得4，4再加个位剩下得3得7，好了，到十位了，十位本身不够用，还被个位借走1位，得，只能向百位借，10减7加4得7，百位被借走只剩1，1-1=0，故差为77。 如何用逻辑门实现这种逻辑呢？ 答：我们不会用这种借位逻辑，取而代之得是一个小技巧。还是那道题，要想不借位，首先将减数176用999减去，即999-176=823，一位都不用借，注意，这里因为操作数是3位，所以用999，操作数是4位我们则用9999，以此类推。把一个数从一串9999……中减去得到的结果我们称之为9的补码。176的9的补码就是823，反之823的9的补码是176，这样做的好处就是，无论减数是几，计算其9的补码时永远不会借位。 在计算出减数的9的补码后，将补码加到原来的被减数上，即823+253=1076，最后再加1并减去1000得77，看，是不是没用到借位！ 原理很简单，253-176=153-176+1000-1000=253-176+999+1-1000=(999-176)+253+1-1000，这样用2个减法和2个加法代替原来的1个减法，其中2个减法，计算减数9的补码和减1000，永远不需要借位，不信你随便找个比1000大的数减1000试试需不需要借位。这样可以省去借位。 那么问题来了，被减数比减数小怎么办？我们如果还用上面的方法，最后得到923-1000，遇到这种情况，小学的我们此时都是减数和被减数换个位子，得到的正数差取反即可，所以我们聪明地让1000-923企图取反，但是傻眼了，这样做还是不能绕过借位，我们用上面的方法，又是用999减，又是+1又是减1000的，不就是想不借位吗，本来被减数&gt;减数时，这种方法是可以绕过借位的，但被减数&lt;减数该方法就不灵了，即使我们耍小聪明让被减数和减数互换位置的情况下。 这种情况要绕过借位与前文略有不同，仍然是先求出减数253的9的补码为746，再746+176=922，好，从下面开始和前文不同，既然前面加了999，我们再减999，只不过反过来，999-922，这样不用借位，999-922=77，此时我们再取反得-77，整个过程就是，176-253=176-253+999-999=999-253+176-999=922-999(互换位置再取反)=-77，看，我们又绕过了借位。 这种绕借位的方法可以用在二进制数减法，而且比十进制数简单。 253二进制数是11111101，176二进制数是10110000，我们还用上面教的方法，11111101-10110000=(11111101-10110000)+(100000000-100000000)=11111111-10110000+11111101+00000001-100000000=101001101-100000000=01001101，01001101转十进制便是77，整个过程中没有借位。 得到一个十进制数的9的补码，我们是用一串9去减该数，对于一个二进制数，我们是用一串1去减，称为该数的1的补码，但请注意，求1的不码不仅不需要借位，减法也不用做，因为在求1的补码过程中，无非是将那个二进制数的0变为1，1变为0，所以二进制数的1的补码，也叫它的反码，计算机中有专门的反向器来做这个事。 相同地，再解决 10110000-11111101 的问题，与十进制情况类似，先求11111101的1的补码(反码)即00000010，再加被减数得10110010，再减11111111，如果我们加00000001再减100000000，则会用到借位。同样，先让11111111和10110000互换位置，即11111111-10110010=01001101，再取反为-01001101，完美避过借位。整个过程是，10110000-11111101+11111111-11111111=(11111111-11111101)+10110000-11111111。 现在我们弄清了怎么绕开借位实现减法，那么计算机内部怎么表示负数呢？ 从小就学，负数前面添一个负号，这个数就是负数，因此很容易想到，0和1可以分别代表正负号，比如8位二进制数，最高位定为符号位，可规定0正1负，余下数字定为数字位，这样也能表达有符号数。但是有个更好的方法，不仅能表示负数，还很适合计算正负数之间的加法，但该方法有个不足之处即，需要提前决定数字需要多少位。 我们小学学的正负号表示正负数的方法，可以表示所有的正负数，我们把0想象成向一个方向延伸的无穷的正数流和向相反方向延伸的负数流的中点，如果我们不需要无限的正数和负数，可以清楚的确定我们能用到的数的范围，那么我们或许不需要规定正负号来表达正负数。 比如银行给我们一个账号，账户存款上限是$499，可以透支$500，意味着账户上的数字在[-500.499]区间内，-500(-1)和0499共1000个整数，我们只需3位十进制000999就可以表达完全，且不用多余的位来表达正负号，我们用000499表示0499，然后500999不会在账户中出现闲着也是闲着，恰好拿来表示-500(-1)，500表示-500，501表示-499，502表示-498…………998表示-2、，999表示-1。换句话说，以5、6、7、8、9开头的三位数实际上都表示负数。注意这样形成了一个环形排序，想象两个圆圈，一个在内环，一个在外环，内环是0999顺时针排成一个环，外环先是0499顺时针排成一个半圆环，内外环的0499依次对应，从内环的500开始，外环开始变成负数，内环500对应外环-500，内环501对应外环-499，内环502对应外环-498，还是顺时针依次对应，直到内环998对应外环-2，内环999对应外环-1，最后内环回到0，外环也回到0。从外环看，最小的负数-500看上去好似外环最大正数499的延续；从内环看，数字999代表比0小的第一个负数。 说到这，我们绕开了借位做减法，也摒弃了用了多年的正负号来表示有符号数，还辛辛苦苦弄了两个圈表示一定范围的正负数，有什么用呢？ 如果给999加1，通常得到1000，但由于我们已经限制了3位十进制数，所以实际上得到000。这种处理称为10的补码，要把三位负数转换成10的补码，需要用999减它的绝对值再加1，换句话说就是求9的补码再加1.比如-255，其10的补码就是999-255+1=745，745+255=1000，某三位负数10的补码就是1000减去它的绝对值得到的数。 了解过负数的的补码，再回头看那两个圆环，有没有发现什么？对于我们苦心孤诣构造的两个圆环，前半部分都是非负数，内外环的数字都一样；对于后半圈，内环是外环数字的10的补码。在外圈我们想求-3+1=-2，我们用内圈-3的10的补码997，去加内圈正数区的1，得到结果998，再去对应外圈得-2，是不是很神奇！这也是我们规定500对应-500，501对应-499……的用意。 假设我现在账户上有 $143，并花出去了 $78，还剩多少？即求143-78=143+(-78)，-78的10的补码是922，故我们可以这样求143-78，143+922=1065，忽略上溢，即结果是065。如果我们提前知道-78的10的补码是922，是不是就没有用到减法！ 之前我们求十进制数的9的补码是用一串9……去减那个数，求十进制数的10的补码是用其9的补码加1得到，那么在二进制中也可以这么干。求二进制数1的补码是用一串1……去减那个数，得到该数的1的补码也称该数的反码，计算机内部有专门的反相器来求二进制数的反码。求该数的2的补码，就用该数的反码(该数1的补码)加1就可得到。 比如求十进制负数-237的10的补码，可以先求其9的补码999-237=762，再加1=763，即求得，也可以直接用1000-237=763，这样也能得到-273的10的补码，但是在求1000-237时需要用到借位。同理，我们求3的二进制数的1的补码(00000011的反码)，用11111111减它得到11111100，再加1得到11111101，11111101+00000011=100000000，由于只于一个字节所以把第9位1扔了，因此求00000011的2的补码也可以直接用100000000-00000011，但这样求会用到借位而且会用到减法。而先求00000011的反码，计算机做这一步有反向器所以不用11111111去做减法，再加1得2得补码，全程不用做减法。-3的二进制数在计算机内部只能用11111101来表示，其它二进制数没法表示-3，所谓的最高位是0正1负，不是把000000011最高位变成1，(注意：10000011在计算机内部表示-125而不是-3)，而是指00000011的2的补码算出来，为11111101，其最高位天然就是1。补码不能用常规的二进制转十进制方法计算它对应的十进制数，而是人为规定这个补码对应哪个十进制数。 只需求正数对应的二进制数的2的补码，就可得到该正数的相反数在计算机内部对应的二进制数；只需求负数对应的二进制数的2的补码，就可得到该负数的相反数在计算机内部对应的二进制数。比如我们想知道-3在计算机内部用什么二进制数表示，先用3转换为二进制数00000011，再求00000011的2的补码为11111101，这个11111101就是-3在计算机内部对应的二进制数。同理，求11111101的2的补码，先对11111101求反码得00000010，再加1得到00000011，就是3在计算机内部对应的二进制数。 好了，对于二进制，我们还能比着十进制的葫芦画2个圈。 我们在十进制中，用0-999这1000个数，成功对应了-500-499，并通过巧妙的对应方法和溢出，使得做减法时只需要加法就能得到。同理，我们用00000000-11111111这256个数对应-128-127，最内圈00000000-11111111顺时针排成最内圈，00000000-01111111在内环的前半圈，分别对应外圈的0-127，内圈后半圈是10000000-11111111，分别对应外环的(-128)-(-1)，其中10000000对应-128，10000001对应-127，10000010对应-126……11111110对应-2，11111111对应-1，仔细观察，我们发现在这种对应规则下，正数对应地二进制数最高位都是0，负数对应二进制数最高位都是1，但计算机其实不会特意注意这个最高位，它只会把它当作普通的二进制数。其实内环后半圈我们如果用正常的二进制转十进制的方法算，比如10000010，算出来的结果是130，表示无符号数时这么对应是对的，但我们这不是想让减法变成加法算嘛，所以我们用这种人为对应的方法强行让10000010对应-126，看看有什么好处。我们计算2-126，在计算机内部就是2+(-126)，2按照那两个圈的对应规则对应二进制数00000010，-126对应10000010，2+(-126)在计算机内部就是做00000010+10000010=10000100，然后根据对应规则，10000100对应-124，在计算机内部成功地用加法实现了减法 需要特别注意的是，计算机在做负数有关计算时，并不会跑过去特地判断最高位是0还是1，对于计算机来说这就是个2个普通的二进制数，计算机只需把他们加起来，多的位溢出即完成任务，只是，这普通的加法在我们对二进制人为设置的对应关系下，并结合溢出的特性，变成了减法。 特别需要注意上溢和下溢，即结果在[-128，127]区间之外的情况，例如，125+125，计算机内部就是01111101+01111101=11111010，根据我们规定的对应关系，11111010代表-6；再看10000011+10000011，即-125-125，得到100000110，由于限制了8位，所以最高位的1被计算机扔掉为00000110，该数表示6。一般而言，若两个操作数同号，而结果的符号与2个操作数符号不同，则这样的加法八成产生了溢出，我们一般认为这样的加法是无效的。 到此为止，二进制有两种使用方法，二进制数可以用来表示有符号数和无符号数，同是8位二进制数，可以表示无符号数的范围是0-255，可以表示有符号数的范围是(-128)-127，但这些二进制数本身不会告诉你它此刻表示的是有符号数还是无符号数。假设有人问你，10110110对应的十进制数是几，你一定不要先急着回答，问清楚是表示有符号数还是无符号数，它可能是182 or -74，-74怎么得到的？，求101101102的的补码，表示正数74，取相反数-74即得到。在C语言中，针对计算机内存里同一个二进制数，我们怎么控制让它输出是有符号数还是无符号数呢，用%d和%u控制。 看，这就是二进制数的麻烦之处，它仅仅是纯粹的0和1，但没有告诉你什么含义。 最后，我们回头看，最开始我们说减法要绕开借位做什么，用补码来做加法实现减法的效果和绕开借位有什么关系？因为我们想借绕开借位实现减法引入补码和反码。对于十进制来说，使用补码可以绕开借位实现减法，对于二进制来说，使用反码和补码不仅可以绕开二进制，还可以做加法实现减法的效果。","categories":[],"tags":[]},{"title":"专升本H哥我的好哥哥","slug":"H-brother","date":"2022-08-02T01:49:55.000Z","updated":"2022-08-27T06:30:53.189Z","comments":true,"path":"2022/08/02/H-brother/","link":"","permalink":"http://example.com/2022/08/02/H-brother/","excerpt":"","text":"计算机的诞生与发展 什么是计算机 电脑（微型机，组装机，大型机，超大型机…），手机，智能手表，ATM，安全系统… 图灵测试：有一台机器和一个人，提问者分别问机器和人相同的问题，提问者如果分不出来哪个是人哪个是机器，则判断那个机器是人工智能。图灵也被称为计算机科学之父，人工智能之父，冯诺伊曼是计算机之父。 机械计算器——&gt;分析机——&gt;布尔规定运算规则，建立逻辑代数——&gt;图灵理论论证了通用计算机可能性(图灵机)——&gt;冯诺依曼提出“存储程序控制原理”，并把二进制引入计算机——&gt;香农，信息论，信息是对数据的解释而数据是信息的载体，比如520就是数据，我爱你是信息。 什么是存储程序控制原理，比如我想制作王者这款游戏，想要在手机上运行，必须先下载到手机外存上，当要运行时这个外存的数据传输到内存里，然后CPU与内存自动交换数据，不是人工，CPU只跟内存交换数据。 1946年，第一台通用计算机ENIAC在美宾夕法尼亚大学研制成功，最初为分析弹道轨迹研制， 但ENIAC并未采用存储程序控制原理，因为冯诺依曼提出来的时候ENIAC已经快成功了， 采用大量电子管和继电器 采用十进制，可见十进制在计算机可以实现，十六进制也能实现，只不过最后发现二进制优势巨大。 无存储器 主要用于军事领域 通常按组成计算机的电子逻辑器件（元器件、元部件），将计算机划分4个阶段： 阶段 基本逻辑器件 存储 特点 第1代 电子管 存储器采用水银延迟线，外存采用纸带 采用机器语言和汇编语言(低级语言) 第2代 晶体管 存储器采用磁芯和磁鼓，外存采用磁盘 出现了高级语言，提出OS的概念 第3代 中、小规模集成电路 第一次采用半导体 出现OS 第4代 大、超大规模集成电路 半导体 出现微型计算机(微机) 微处理器是指微机CPU。服务器，大型计算机也有CPU但那不是微处理器。4位是指一次处理4位数据。 intel 486 中的486是指型号，全称是80486(奔腾)，现在用的是酷睿 微机的性能主要取决于它的核心器件：微处理器(CPU)的性能。 计算机的分类 按结构原理划分 数字计算机：电脉冲的位数和电位的阶变(离散)，这种最常见。 模拟计算机：电压的连续变化(连续) 按照用途划分 通用计算机：可以解决各类问题，最常见。 专用计算机：专为特定目的制造出来，比如ATM机，售票机。 按照规模划分 巨型机，比如太湖之光。 大中型机，比如服务器 小型机 微型计算机： 单片机：处理器，存储器输入输出集成在一个芯片上。比如门禁系统，无人机系统。 单板机：处理器，存储器，输入输出集成在一个电路板上。 个人计算机：PC机 按照字长划分 CPU一次处理多少位数据即字长，字长越大CPU处理数据越快，目前最常见是64位机。 按照工作模式划分 工作站：高档PC 服务器：提供服务，提供资源。我们平时自用的手机电脑叫做客户机，下载的东西叫客户端，我们的客户机访问淘宝请求资源，淘宝的服务器提供资源。 计算机信息的表示及存储 数据信息分为数值型(01001)和非数值型(字母，汉字…)，计算机之所以能识别不同的信息是因为有不同的编码规则。 数制 数值也叫计数制，是指用一组固定符号和统一规则来计数的方法，比如十进制，固定符号就是0-9，统一规则就是比如满十进一，8-2=6这种，十进制全称叫 十进位计数制，生活中最常用。还有16进制一般用于内存编制=址和编号，8进制一般用于权限。 数码 数值中表示基本数值大小的不同数字符号，比如二进制数码就是0和1，八进制数码就是0，1，2，3，4，5，6，7，十六进制是0，1，2，3，4，5，6，7，9，A, B, C, D, E, F，为什么从10开始就是大写英文字母了呢？因为如果还用10，11，12，13，14，15，那比如115，就会产生歧义，所以用A表示10这个数值，以此类推。R进制数码就是0-R-1。 基数 基数就是数码的个数，比如十进制的基数是10，二进制是2. 位权 数制中每个位置的价值，比如十进制中的个位，十位，百位。十进制位权是10n，二进制位权是2n，十六进制位权是16^n。 标识 数制的标识又称后缀，为了区分不同进制，二进制标识B，Q是八进制，十进制一般省略，十六进制是H， 规则 进位规则：9+1为什么等于10，因为十进制规定的规则，二进制下，1+1=10；八进制下，7+1=10，6+3=11；十六进制下，8+2=A(此时还没进位)，8+8=10，总之多少进制就满多少进一。 借位规则：十进制里面10-2为什么等于8，因为0-2不够，向十位借1位当作10，10再减2得8；二进制下面，10-1，0不够，向高位借一位当作2，2-1=1；八进制下，10-2，不够向高位借，当作8-2得6；十六进制下，11-2，借一位得16-2=14，14再加1等于F(15)，总之多少进制下，向高位借1位就当作多少。 Practice 102B是错的，二进制数码没有2； 7Q是对的，Q是八进制得标识，数码有7没有8； ABCDF H是对的；BTW，ABCDF H不能看作 1011121315，就像比如二进制1011100，没法直接看成十进制，想要转换为十进制只能计算出来。 6+3=11，则一定是八进制，因为让11-1=6+3-1，即10=6+2，逢8进一。 进制转换 十进制——&gt;R进制 整数：除以R反向取余 小数：乘R正向取整(取整后变为0) 比如： 20.625D=10100.101B 66.5D=102.4Q 30.5D=1E.8 (十六进制里面有14这个数值，但是是用E来表示)。 29.125D=11101.001B R进制——&gt;十进制 乘权求和法：每一位得值乘以它对应的位权。 需注意两点： 从个位开始标，小数和整数分开 位权是从0指数开始 10110.011B=22.375D 16.6Q=14.75D 8A.4H=138.25 1010.101B=10.625D 二进制——&gt;八进制/十六进制 分组转换法： 二进制——&gt;八进制：3位转成1位 二进制——&gt;十六进制：4位转成1位 在这个转换过程中我们熟悉的十进制成为媒介。 为什么能这么转换呢？ 二进制1位能表示的范围是0-1，2位能表示的范围是0-3，3位能表示的范围是0-7，而八进制1位刚好是0-7的范围，所以3位二进制转换1位八进制；4位二进制能表示的范围是0-15，刚好十六进制1位能表示的数值范围也是0-15； 注意两点： 以小数点为界，整数和小数分开 整数位数不够在前面添0，小数位数不够在后面添0。 10101.1B=25.4Q 110101.1101B=35.DH 110001.11B=61.6Q 八进制/十六进制——&gt;二进制 换组转换法： 八进制——&gt;二进制：1位转成3位 十六进制——&gt;二进制：1位转成4位 在这个转换过程中我们熟悉的十进制成为媒介。 16.32Q=1110.01101B F.3DH=1111.00111101B ABC.DH=101010111100.1101B 八进制&lt;——&gt;十六进制 以二进制为媒介 56.3Q=101110.011B=2E.6H 3D.2H=111101.001B=75.1Q 小数点移位 对于R进制，小数点左移n位，数变为原来的R^(-n)倍； 对于R进制，小数点右移n位，数变为原来的R^(n)倍； 对于二进制数110.11011B，小数点左移2位，则变为原来的2^(-2)=0.25倍；对于一个八进制数，小数点右移2位，则变为原来的64倍。 二进制的算术&amp;逻辑运算 算术运算 加：0+0=0；1+0=1；1+1=10 减：0-0=0；1-0=1；1-1=0；10-1=1； 乘：0×0=0；0×1=0；1×1=1； 除：0/1=0；1/1=1； 101+110=1011B 11001-101=10100B 11001×101=1111101B 11001/101=101B(与十进制除法规则相同) 逻辑运算 与(逻辑乘)：0&amp;&amp;1=0；0&amp;&amp;0=0；1&amp;&amp;1=1； 或(逻辑加)：0||0=0；0||1=1；1||1=1； 非：!1=0；!0=1； 异或(相同为0，不同为1)：0XOR0=0；1XOR1=0；1XOR0=1；0XOR1=1； 1010&amp;&amp;1011=1010B 1010||1101=1111B !1010=0101 1010XOR1101=0111B 千万注意逻辑运算和算术运算不同，逻辑运算前面的0不可省。 计算机中信息的表示 信息的单位 位(bit):计算机中最小的数据单位是二进制的一个数位，简称位(bit)，一般用b表示。 字节(Byte):字节是计算机中存储信息的基本单位，计算机内部是以字节为单位进行处理的，一般用B表示。1B=8b，1个字节=8位二进制。 字:CPU一次性传输，运算或处理的二进制数据。 字长:CPU一次性传输，运算或处理的二进制数据的位数。 比如CPU一次处理10101010B这个二进制数，这个就是字，一共8位，其字长就是8位。注意这是CPU一次(同时)能处理这么多位，但不是指CPU最大能够处理这么多。 单位换算 我们规定8位二进制称为1个字节，1B=8b，以此类推，2B=16b，32b=4B。 2^10=1024 1KB = 2^10 B =1024 B 1MB = 2^10 KB =1024 KB =2^20 B 1GB = 2^10 MB =1024 MB =2^30 B 1TB = 2^10 GB =1024 GB =2^40 B 1PB = 2^10 TB =1024 TB =2^50 B 1EB = 2^10 PB =1024 PB =2^60 B notes:传统数据量一般低于 PB，而大数据处理的数据往往有PB 甚至EB。 2MB = 2×2^20 B = 2^21 B 2^32 B = 232/230 GB = 4 GB 常见的，比如我们常说手机内存是4GB，8GB…… 数值表示 无符号数：0，1，2，3，4…… 有符号数：-2，-1，0，1，2…… 详见《Code》第13章。 n位二进制表达的数字范围 用n位二进制表示无符号数(十进制)的范围是 0-(2n)-1**，共能表示**2n个数。 用n位二进制表示有符号数(十进制)的范围：由于最高位被当作符号位，故只有n-1位可以来表达数字，符号位有两种状态，而剩下的(n-1)位用来表达无符号数可以表达2(n-1)个，可以表达的无符号数范围是0-2(n-1)-1。 故按理说，所能表达正数范围是12^(n-1)-1，所能表达负数范围是-2^(n-1)-1(-1)，符号位和数值位均为0则表达十进制数0，故按理来说，共能表达的有符号数范围是-2(n-1)-1~0~2(n-1)-1，但是是不是有点不对劲？若符号位和数值位均为0则表达十进制数0，那么还有一共=个原码没用到，就是符号位为1数值位全为0的数，它表示什么呢？难道也表达0？那不是重复表达吗？其实计算机将这个数定义为-2^(n-1)，这样n位二进制能表示的有符号数(十进制)的范围就是 -2(n-1)~0~2(n-1)-1，至于计算机为什么能怎么定义，此处先按下不表。(详解请看《Code》13章)，n位二进制能表示有符号数(十进制)的个数是2×2(n-1)=2n，8位二进制可表达的有符号数范围就是经典的-128~127，能表达256个数。 状态数：即数的个数，举例,16位二进制能表达的状态数是216，也就是能表达216个数字。这一点对于表达有符号数还是无符号数都是一样的。 浮点数 根据小数的位置是否固定，将数值分为定点数和浮点数。 浮点数：N = M × R^(e) 其中，M称为数N的尾数，决定数的精度。E是数N的阶码，决定数的范围。 比如12.5×10(3)，和12.51×10(4)，尾数分别是12.5和12.51，显然12.51精度更高；阶码分别是3和4，显然4的范围更大。 信息编码 上面讲的都是数值编码，这里讲非数值在计算机内部怎么表达。非数值比如，字母，汉字，图片，音频…… BCD码 BCD码：Binary-Coded-Decimal 这是一种二进制的数字编码形式，。BCD码这种编码形式利用了四个位元来储存一个十进制的数码，使二进制和十进制之间的转换得以快捷的进行。这种编码技巧最常用于会计系统的设计里，因为会计制度经常需要对很长的数字串作准确的计算。相对于一般的浮点式记数法，采用BCD码，既可保存数值的精确度，又可免去使计算机作浮点运算时所耗费的时间。 由于十进制数码有10个，09，但三位二进制只能表达07，所以至少需要4位二进制码来表示1位十进制数。这种编码方式在中国大陆最常见的是“8421码”。 ASCII码 标准ASCII码：美国信息交换标准代码 标准ASCII码占用1个字节但只用了7位，最高位始终为0。所以十进制数范围是0~127。 其中0~31是控制字符，比如回车，换行，不显示不打印，127是删除，也不显示不打印。从32开始是空格，开始可以显示打印出来，空格是能显示出来的最小的一个ASCII码。 0是48，1是49，A是65，a是97，A和a相差32D。数字&lt;大写字母&lt;小写字母。 扩展ASCII码：由于标准ASCII码没有用到第8位，所以出现了扩展ASCII码，它用到了第8位，标准ASCII码最高位始终为0，扩展ASCII码把第8位变成1，其范围是128~255，其实就是在标准ASCII码后面接了128个数。但是这个编码方式常见于拉丁文，所以我们一般不用。超过128叫高位字节，低于128叫低位字节。 GBK编码 GBK2312-80(GB2312) ASCII码用于西文，由于ASCII码只用1个字节，状态数是256，但汉字个数远远不止256个，所以我们汉字不能用ASCII码，因为不够用。所以出现了GBK2312,GBK2312-80中的80指上世纪80年代产生我们用2个字节表示汉字，两个字节有16位，状态数是2的16次方=65535，可以表达6w多个字符，但此编码标准只收录了6763个常用汉字，导致后来随着中文互联网普及，一些生僻字表达不出来，为了解决这个问题，后面又扩展成GBK。 GBK 1995年，GBK1.0收录了2w多个字符，可以表达我国少数民族字符。 GB18030 2000年GB18030-2000取代GBK，2005年，升级为GB18030-2005。 GBK如何兼容ASCII码 我们平时在计算机上打字，时而英文时而中文，但是我们上面了解到，ASCII码占用1个字节，而GBK占用2个字节，在计算机内部都是连续的010101……，计算机是怎么识别什么时候用两个字节编码，什么时候用1个字节编码呢？有人说，可以用GBK兼容ASCII码，在表示英文字母时可以用两个字节，然后高8位全为0，低8位用ASCII码，这样行是行，但是若全是英文字母的话，用ASCII编码大小如果是2MB，那么用GBK编码就是4MB，很浪费。于是有人就找到了扩展ASCII码一览表，说高位字节都是我们中国人平时用不到的字符，索性我们可以去掉ASCI码的高位字节，将汉字还用2个字节去编码，只不过2个字节每个字节都是高位字节。让电脑以1个字节去识别，出现1个低位字节时，我们用ASCII码编码，当出现2个连续的高位字节时，计算机将连续的2个字节一起识别，然后用GBK编码成汉字。 编码系统的统一(Unicode) 我国有GBK，台湾有BIG 5，日韩也有自己的。但是会产生问题，比如把日本游戏进口中国，但中国电脑上没有日本的编码系统，那么在中国电脑上展示会出现乱码，后来就装语言包，可以使日本游戏显示日文但仍然不显示中文。这时联合国出来搞了一个万国码，就是Unicode，统一天下，Unicode兼容ASCII码，比如’a’的ASCII码是0x61，在Unicode里就是0x0061，都对应97。Unicode现在已经收录了13w+的字符，一个字符占2~4个字节，大部分是占2个字节，支持全球各种语言，并能与各种编码系统相互转换，比如Unicode&lt;——&gt;GBK，Unicode&lt;——&gt;BIG5，为什么不直接用Unicode还要互相转呢，因为Unicode1.01994年才发布，GBK2312八十年代就出来了，当时有很多软件已经基于本国的编码系统开发出来了，不好推到再改；另一个原因就是很多产品只需要在本国用，没有用Unicode的需求。直到现在，全球电脑厂商出厂都支持Unicode，大多数软件也是。 但是Unicode一个字符占2~4个字节，存储和传输时会很大，所以针对传输+存储做了一个新的编码系统，即 UTF(Unicode Transformation Format)，它有3个版本，即UTF-8、UTF-16、UTF-32。其中 UTF-8 优先使用1个字节。无法满足则增加一个字节。最多4个字节，英文占1个字节(兼容ASCII码)，欧陆语系占2个字节，东亚语系占3个字节，其它及特殊字符占4个字节。虽然汉字的大小比Unicode更大了，但是在英文占多数的文件中，比Unicode要小。UTF-16 使用2、4个字节表示，优先2否则4，还是没有解决传输和存储时很大的问题；UTF-32一律用4个字节表示字符，更没人用。 UTF-8是互联网上使用最广泛的一种Unicode的实现方式。现在文字在内存里是Unicode，传输时转成UTF-8，保存在硬盘里也会转成UTF-8.但是需要特别注意，UTF-8不能像Unicode一样和GBK、BIG5这种编码系统互转。 python2开发出来是1990年，那个时候还没有Unicode，python2选的是ASCII码，所有python2不支持中文。","categories":[],"tags":[]},{"title":"翁恺哥哥的C","slug":"WengKai-C","date":"2022-07-24T08:11:23.000Z","updated":"2023-02-21T00:41:03.827Z","comments":true,"path":"2022/07/24/WengKai-C/","link":"","permalink":"http://example.com/2022/07/24/WengKai-C/","excerpt":"","text":"Day 1 计算机如何解决问题 计算机什么也不会，它只会按照指令去做事，我们需要把步骤串起来，所以我们需要使用编程语言去指挥计算机该做什么。 所有计算机去做的东西，我们都叫计算，并不只局限于加减乘除等，包括，画一张图，放一部电影，这些都叫计算。 那计算的步骤呢，就叫算法 algorithm. 算法是程序的灵魂，算法 + 数据结构 = 程序，数据结构即用整型，浮点，字符串，数组，指针还是结构体…… 做一个图书管理系统，下面就是数据的结构设计举例： 123456789101112131415161718192021222324252627282930struct class Book&#123; string 书名 int price; //浮点不精确，不适合算钱 int 页数; int bId; int 出版商ID; int 作者ID; &#125; struct 出版社; struct 作者&#123; int 作者id; 名称 年龄 体重 三围 &#125;; // 本图书管理系统的所有书籍 Book books[1000]; 作者 作者s[100]; 作者1; for(int i= 0; i&lt; 作者.size(); i++))&#123; if(book1.作者id == 作者s[i].id)&#123; 作者1 = 作者s[i]; &#125; &#125; 计算机的思维方式 枚举，二分，… 程序的执行，源代码-&gt;机器语言 解释 有一个程序，能够读懂我写的程序，它会看懂我的程序并读入我的程序并，转身让计算机去做 类似同声传译 编译 有一个程序，它也能读懂我的程序，它能把我的源代码，翻译成机器语言，然后，它会把这个翻译以后的，计算机能懂的机器语言，保存下来，以后，我的程序想执行时，它会直接拿原来翻译好的程序去让计算机执行，这个翻译的过程叫做编译。 类似书面翻译交纸质的。 对于计算机编程语言来说，语言本身是没有编译和解释之分的，任何一种语言既可以解释执行也可以编译执行，这仅仅是传统和习惯问题，只是，这种语言它常用的程序执行方式，比如，也有人去做C语言的解释器。 过去我们常常说，解释语言比较慢，因为需要一条条去执行，但现在计算机的计算速度已经到了一个非常高的程度，和编译型语言的运行效率已经差别不大了。只是传统和喜好的问题。 为什么是C C/C++语言才很多场合时唯一的选择，比如做操作系统，嵌入式系统. 上世纪60-70年代，不同语言的语法差异很大，但现如今，很多语言都可以叫做C—like语言。基本上，他们都和C语言很接近。 做同一件事情： 123456#include &lt;stdio.h&gt;int main()&#123; printf(&quot;Hello World!\\n&quot;); return 0;&#125; 12345class Hello &#123; public static void mian(String[] arg)&#123; System.out.println(&quot;Hello World!&quot;); &#125;&#125; 1print(&quot;Hello World!\\n&quot;) C简单历史 it was the summer of 69 C语言是从B语言发展而来， 但没有A语言，FORTRAN语言是世界上第一个被正式推广使用的高级语言。指针是C语言的灵魂，高级语言中C语言是一种比较底层C99.现在C语言的编译器基本上都支持C99了 以前OS用汇编语言写，汇编是面向硬件的，所以做出来的OS可移植性差，所以贝尔实验室发明了C语言，想用这门高级语言写Unix操作系统，使得Unix的可移植性变强。Mac就是类Unix系统。 编程软件 C语言写，操作系统，嵌入式系统，写驱动程序（比如U盘），游戏引擎。 网站的服务器本身的操作系统是C语言写的，网站的服务器软件是C语言写的，但网站直接提供数据的代码并不是C写的。 因此C是一门工业语言， 开发效率&gt;&gt;学习过程 开发效率&gt;&gt;学习乐趣 编辑器 如VSCode; 编译器 或者，IDE（集成开发环境） Day 2 第一个C程序 12345678#include &lt;stdio.h&gt;int main()&#123; printf(&quot;Hello World!\\n&quot;); return 0;&#125; 详解第一个程序 我们所有的C程序都要有这几行,这是一个框架。 123456#include &lt;stdio.h&gt;int main()&#123; //在这写 return 0;&#125; 对于C语言来说换行不意味着任何事情。 做点计算 计算机刚出现的时候，是使用打字机输入程序的，但打字机上没有乘除的符号所以用*&amp;/代替。 %是俩数做除法，只要余数。 123456#include &lt;stdio.h&gt;int main()&#123; printf(&quot;12+34=%d&quot;, 12+34); //在这写 return 0;&#125; 变量定义 12345678910#include &lt;stdio.h&gt;int main()&#123; int price = 0; printf(&quot;请输入金额(元)&quot;); scanf(&quot;%d&quot;, &amp;price); int change=100-price; printf(&quot;找您%d元\\n&quot;, change); return 0;&#125; 变量的名字叫做price，变量的类型是int，初始值为0. 变量是保存数据的地方。 变量代表一个变化的值。 1int price,amount; 变量的名字是一种标识符，C的关键字/保留字，不能用作标识符，标识符只能由 数字 下划线 字母 组成，数字不能放在开头。 变量赋值与初始化 对于C来说，初始化和赋值的差异不是特别大，但C++的差异大。=表示一个动作故a=b和b=a是两个完全不同的意思，当赋值发生在定义变量时即为初始化，若变量仅仅定义而没有初始化，比如： 1int i; 则在计算机的内存当中，那个变量放在内存的哪个位置，那个位置原来有什么，就是它的值。内存有个特点，即新来旧去，即新的来了，旧的才走。内存上旧的那一块，上面会保留上一个数据，但是会显示free，即可以分配新的数据过去从而覆盖掉旧的，新的来了后会显示busy，表示现在这块内存上正在有数据占用。如果变量没有初始化只是定义，那么这个变量确实会占一块内存并显示free，但是由于我们没有没有给它初值，所以它并不会覆盖掉内存上的旧数据，旧数据还在那，我们打印出来的是旧数据。 传统的ANSI C只允许在代码开头的地方定义变量，C99则不然。 变量VS常量 C99定义常量 1const int AMOUNT = 100; 这里的const是一个修饰符，表示该变量的值一旦被初始化，后面的程序便不能修改之。把某一数字赋予名字，可以增强易读性。 eg,后面再写 AMOUNT=90 便会被编译器发现并报错。 对于一个常量，一般都会把变量名字大写。 对于下面这段代码： 123456789#include &lt;stdio.h&gt;int main()&#123; int a; int b; scanf(&quot;%d %d&quot;, &amp;a,&amp;b); printf(&quot;%d+%d=%d&quot;, a,b,a+b); return 0;&#125; 我们输入1空格2和输入1回车2和输入1回车回车2，结果都是3，但是若输入hello,clion终端便会输出0+0=0，这是因为a和b没有被初始化且没有得到他们想要的值。 浮点数 123456789101112#include &lt;stdio.h&gt;int main()&#123; int foot; int inch; printf(&quot;请分别输入身高的英尺和英寸，&quot; &quot;如输入\\&quot;5 7\\&quot;表示5英尺7英寸：&quot;); scanf(&quot;%d %d&quot;, &amp;foot,&amp;inch); printf(&quot;身高（国际单位）:%f\\n&quot;, (foot+(inch/12))*0.3048); return 0;&#125; 我们首先使用卡西欧计算器计算5英寸7英寸=1.7018米，但是，当我们输入5 7时，程序输出的结果是1.524000，更加奇怪的是，我们输入5 9、5 0、结果均为1.524，但我们如果输入6 7和6 2，则结果均变为1.828。原因是，在C语言中当我们对两个整数进行运算时，它的结果也只能是整数，我们输入5 7 时，其中有7/12这个运算，得到的结果是向下取整后的，即为7/12约等于0，因此inch都不起作用，英尺才起作用。怎么解决呢，方案有俩： 123456#include &lt;stdio.h&gt;int main()&#123; printf(&quot;%f\\n&quot;, 10.0/3); return 0;&#125; 浮点数意思是小数点是浮动的，小数点出现在一个数的第几位，这是可以变的；定点数也有小数点，但它的小数点顾名思义，永远出现在某一位，浮点和定点都是在计算机内部表达有小数点数字的方式，但是我们通常会使用浮点数。运算符两边又有整数又有浮点数，C会强制类型转换，用这种方法改： 123456789101112#include &lt;stdio.h&gt;int main()&#123; int foot; int inch; printf(&quot;请分别输入身高的英尺和英寸，&quot; &quot;如输入\\&quot;5 7\\&quot;表示5英尺7英寸：&quot;); scanf(&quot;%d %d&quot;, &amp;foot,&amp;inch); printf(&quot;身高（国际单位）:%f\\n&quot;, (foot+(inch/12.0))*0.3048); return 0;&#125; 第二种方法是改变量类型： 123456789101112#include &lt;stdio.h&gt;int main()&#123; double foot; double inch; printf(&quot;请分别输入身高的英尺和英寸，&quot; &quot;如输入\\&quot;5 7\\&quot;表示5英尺7英寸：&quot;); scanf(&quot;%lf %lf&quot;, &amp;foot,&amp;inch); printf(&quot;身高（国际单位）:%f\\n&quot;, (foot+(inch/12))*0.3048); return 0;&#125; 对于整型变量，我们输入的时候用%d输出的时候也用%d，但对于double我们输入用%lf输出用%f。 浮点数有两种，一种是 双精度浮点数 double，一种是单精度浮点数 float(不是single)。 那么在计算机里为什么会出现整数这样的东西，其实日常生活中和计算中我们不会特地去想这个数是整数还是小数，但由于计算机只认二进制，整数可以被完整表达，在计算机内部可以比较快地运算，但十进制小数转二进制有时候只能转成近似值，而且计算机计算比较慢。 表达式 ex[ression 一个表达式是一系列算子和运算符的组合。 运算符 比如 + ，- ，= 算子，是指参与运算的值，该值可以是常数也可以是变量也可能是一个方法的返回值。 1234567891011121314#include &lt;stdio.h&gt;#include &lt;math.h&gt;int main()&#123; int hour1, min1; int hour2, min2; scanf(&quot;%d %d&quot;, &amp;hour1,&amp;min1); scanf(&quot;%d %d&quot;, &amp;hour2,&amp;min2); int t1=hour1*60+min1; //不是min1/60是因为避免使用浮点数 int t2=hour2*60+min2; //不是min2/60是因为避免使用浮点数 int t=abs(t2-t1); printf(&quot;时间差是%d小时%d分&quot;, t/60,t%60); return 0;&#125; 表达式：expression 对于C语言来说，表达式是一个非常宽泛的概念，单一的字面量，单一的变量，计算的结果，函数的返回值……都是表达式的范畴。任何表达式都是有返回值的。可以理解为表达式本身也有值。举例：把while（x==10) 写成了 while （x=10)，然后程序就在这里死循环了，永远出不来。编译器不会向我们报错，因为这样的写法其实是合法的，赋值表达式是有（返回）值的。经查询，赋值表达式的返回值是赋值符号右边的值(逗号运算符返回的也是右边的值)。x=10的值就是10，所以while永远不会结束。而关系表达式往往返回bool值。 语句：语句和表达式是两个概念，广义上讲，有;的就是语句，没有分号的就是表达式。C语句可分为以下五类： 表达式语句：表达式语句由表达式加上分号“;”组成。其一般形式为：表达式; 执行表达式语句就是计算表达式的值。例如 c=a+a; 函数调用语句：由函数名、实际参数加上分号“;”组成。其一般形式为：函数名(实际参数表); 例如 printf(“Hello !”); 控制语句：控制语句用于控制程序的流程，以实现程序的各种结构方式。它们由特定的语句定义符组成。C语言有九种控制语句。 可分成以下三类： 条件判断语句：if语句、switch语句；为什么if语句叫语句呢？因为if后面跟一个{}，其实是一个复合语句。 循环执行语句：do while语句、while语句、for语句； 转向语句：break语句、goto语句、continue语句、return语句。 复合语句：把多个语句用括号{}括起来组成的一个语句称复合语句。在程序中应把复合语句看成是单条语句，而不是多条语句。例如：{ x=y+z; a=b+c; printf(&quot;%d%d&quot;, x, a); } 空语句：只有分号“;”组成的语句称为空语句。空语句是什么也不执行的语句。在程序中空语句可用来作空循环体。例如：while( getchar()!=’\\n’ ); 表达式和语句的区别： 功能不同：表达式本身是什么都不做的，只返回值，只是单纯的计算过程。它可以被放在任何需要值的地方。当然赋值表达式是比较特殊的，它虽然也返回值，但主要作用显然是改变变量的值，其实赋值表达式更像一个语句。语句是命令式编程语言的一个语法单元，表示程序要执行的操作。语句则是一个行为，负责执行某种操作，没有返回值。程序就是通过语句来执行功能的。语句由分号(或{})来结尾。 二者本质不同：表达式由操作符（运算符）和操作数(算子)构成的式子。而语句的组成相对复杂，多种多样。 表达式与语句的联系： 表达式语句就是仅有表达式组成的语句（其实就是指赋值语句，或者由赋值语句组成的逗号表达式，如if()里的那些逗号表达式，不然根本没有意义） 很多语句需要用到值，也就是表达式。比如while（）的括号中需要一个值来告诉它循环是否结束且我们一般都会用关系表达式，关系表达式往往返回bool值。 其实深究表达式与语句的区别并没有什么意义。我们只需要记住，表达式是值，而语句是操作。有;的就是语句，没有分号的就是表达式，即可。 Day 3 运算符优先级 单目运算符：一个运算符如果需要两个算子则为双目运算符，仅有一个算子则为单目运算符，单目运算符优先级比乘除高，取余和乘除平级。单目运算符一定出现在算子左边。有的语言赋值是一个语句，但C来说赋值是运算符，赋值这个运算符是自右向左结合，比如a=b=6计算机理解为a=(b=6)。赋值的优先级是最低的。不要做嵌入式赋值，不易读。 取余运算符 % 是双目运算符，该运算符的两边均必须是整型，不能是浮点，否则取什么余呢？ 交换变量 程序表达的是要执行的动作，而不是表达关系。 123456789101112#include &lt;stdio.h&gt;int main()&#123; int a=5; int b=6; int t; t=a; a=b; b=t; printf(&quot;a=%d, b=%d&quot;, a,b); return 0;&#125; 我们想看到程序运行过程中5和6是怎么换的，需要用到调试功能，需要设断点，作用是当程序走到这一行时它会停下来，停在这一行表示这一行还没有执行即将要执行。 编程中一些套路要多阅读别人的程序来获得。 复合赋值和递增递减 四则运算符和取余符号都可以和赋值运算符结合形成复合运算符 eg,a+=5即a=a+5，之所以会出现这种复合运算符，是因为C当时想做成一个底层的编程语言，所以设计C是有一个思想即，能用C表达出机器语言所有的指令，又在PDP-11上做出的C，而PDP-11上刚好有一条机器指令专门去做这样的事情，所以便出现了这个东西。 a+=b+5即为a=a+(b+5) 和–都是单目运算符，其算子必须是变量不可是常量， count即count+=1即count=count+1。运算符都有结果，a++的结果是a加1以前的原值，++a是a加了1以后的值，但无论哪个，a的值都是加1以后的值，这两种运算符的出现与复合运算符一样，对于复合运算符和递增递减运算符可以单独使用但不要组合进表达式，否则很难读， practice 1234567891011#include &lt;stdio.h&gt;int main()&#123; int a; printf(&quot;请输入一个正整数，单位是厘米：&quot;); scanf(&quot;%d&quot;,&amp;a); int foot=a/30.48; int inch=((a/30.48)-foot)*12; printf(&quot;%d %d&quot;, foot,inch); return 0;&#125; 怎么把一个四位数从中间分开呢，比如1120，我们用int a=1120/100得到11，用1120%100得20. 123456789101112#include &lt;stdio.h&gt;int main()&#123; int a; printf(&quot;请输入一个3位正整数：&quot;); scanf(&quot;%d&quot;,&amp;a); int b=a/100; int c=a%10; int d=a%100/10; printf(&quot;%d&quot;, c*100+d*10+b); return 0;&#125; 程序中如果想要表达一个二进制数，直接写二进制会显得太长，所以人们一般使用十六进制来表达， 十进制：18 二进制：0001 0010 十六进制：0x12 BCD：12 0的故事 十九世纪末二十世纪初有电报时开始，英文的O和0很像不容易区分，所以电报里的0不是空心的，中间多了一条斜杠，这个做法延续到计算机出现，最初的程序是程序员手写的，然后交给操作员打在穿孔卡片上，手写程序也有这种字体，到后来终端出现，专门为0设置这种字体. 做判断 if(条件成立){ … } 判断的条件 if 语句后面的小括号里的东西也是一种运算，叫关系运算，以下是关系运算符(比较运算符)，不是逻辑运算符： 运算符 意义 == 相等 ！= 不相等 &gt;= 大于或等于 &lt;= 小于或等于 运算符都有结果，关系运算的结果要么是0要么是1， 12345678#include &lt;stdio.h&gt;int main()&#123; printf(&quot;%d\\n&quot;, 5==3); printf(&quot;%d\\n&quot;, 5&gt;=3); printf(&quot;%d\\n&quot;, 5&lt;=3); return 0;&#125; 关系运算符的优先级比算术运算符优先级低，但是比赋值运算符优先级高，而在关系运算符中，==和！=的优先级又比其它比较运算符低，连续的关系运算符是从左到右进行的， Day 4 找零计算器 //(comment)是C99的注释，ANSIC不支持，//是单行注释，/* */是多行注释。多行注释是C传统的形式，单行注释是C99独有的。 1234567891011121314#include &lt;stdio.h&gt;int main()&#123; const int MINOR=35; int age=0; printf(&quot;请输入您的年龄：&quot;); scanf(&quot;%d&quot;, &amp;age); printf(&quot;您输入的年龄是：%d\\n&quot;, age); //人机交互常用手段 if (age&lt;MINOR)&#123; printf(&quot;青春不常在，抓紧谈恋爱！\\n&quot;); &#125; printf(&quot;三十而立，四十而不惑，五十而知天命，六十而耳顺，七十而从心所欲，不逾矩。\\n&quot;); return 0;&#125; 否则的话 else 123456789101112131415#include &lt;stdio.h&gt;int main()&#123; int a,b; printf(&quot;请输入两个整数：&quot;); scanf(&quot;%d %d&quot;, &amp;a,&amp;b); int max; if (a&lt;b)&#123; max=b; &#125; else&#123; max=a; &#125; printf(&quot;%d大&quot;, max); return 0;&#125; 12345678910111213#include &lt;stdio.h&gt;int main()&#123; int a,b; printf(&quot;请输入两个整数：&quot;); scanf(&quot;%d %d&quot;, &amp;a,&amp;b); int max=a; if (a&lt;b)&#123; max=b; &#125; printf(&quot;%d大&quot;, max); return 0;&#125; 以上两段代码，虽然第二段耍了一下小聪明，更简洁，但第一段更傻，易读性更强，翁恺哥哥更偏爱第一段。 注意else后面不能跟表达式，即 else (a &gt; b) {} 是不行的，编译器会报错。 if语句再探 虽然C语言要求每一句语句结尾要有一个分号，但if的圆括号后面不是if语句结束的地方，若if的圆括号后面不加{}，则紧跟在if后面的那一句话，是if条件成立时要执行的那句话，但没有大括号时也仅限这一句话。 12if (a&gt;b) c=a+b; //这两行才是一个完整的if语句，第二行后面才跟分号 嵌套的if-else 计算机最不会做的就是一眼看出来结果， 1234567891011121314151617181920212223#include &lt;stdio.h&gt;int main()&#123; int a,b,c; printf(&quot;请输入三个正整数：&quot;); scanf(&quot;%d %d %d&quot;, &amp;a,&amp;b,&amp;c); int max=0; if (a&gt;b)&#123; if (a&gt;c)&#123; max = a; &#125; else&#123; max=c; &#125; &#125; else&#123; if (b&gt;c)&#123; max=b; &#125; else&#123; max=c; &#125; &#125; printf(&quot;%d最大\\n&quot;, max); return 0;&#125; tips: 在if或者else后面总是用{} 即使只有一条语句的时候 为何？ 如果不加{}，那么else总是和距离它最近的那个if匹配，与缩进无关(这一点与python不同)，而且这样很容易看错谁跟谁匹配，加了{}，else就不再遵守总是和距离它最近的那个if匹配这条规则，而是根据{}来判断谁跟它匹配。 级联的if-else 1234567891011121314151617181920212223#include &lt;stdio.h&gt;int main()&#123; //写一个分段函数 double x,f; scanf(&quot;%lf&quot;,&amp;x); if (x&lt;0)&#123; f=-1; &#125; else&#123; if (x==0)&#123; f=0; &#125; else&#123; if ((0&lt;x)&amp;&amp;(x&lt;=5))&#123; f=1; &#125; else&#123; f=3*x; &#125; &#125; &#125; printf(&quot;%d&quot;, f); return 0;&#125; 这样看起来代码会越来越往右边偏，最终会超出屏幕，早年这样很麻烦，所以想出来下面的编排方式，把所有else对齐，这样的编排方式叫做级联的if-else。 123456789101112131415161718#include &lt;stdio.h&gt;int main()&#123; //写一个分段函数 double x,f; scanf(&quot;%lf&quot;,&amp;x); if (x&lt;0)&#123; f=-1; &#125; else if (x==0)&#123; f=0; &#125; else if ((0&lt;x)&amp;&amp;(x&lt;=5))&#123; f=1; &#125; else&#123; f=3*x; &#125; printf(&quot;%f&quot;, f); return 0;&#125; 这一段代码再对比下面一段代码有个明显的优点就是单一出口，下面一段代码是多出口，计算得到的结果不能用作他用只能printf,是写死了的.(出口不一定离开代码,printf给用户看也叫出口) 1234567891011121314151617#include &lt;stdio.h&gt;int main()&#123; //写一个分段函数 double x; scanf(&quot;%lf&quot;,&amp;x); if (x&lt;0)&#123; printf(&quot;%d&quot;, -1); &#125; else if (x==0)&#123; printf(&quot;%d&quot;, 0); &#125; else if ((0&lt;x)&amp;&amp;(x&lt;=5))&#123; printf(&quot;%d&quot;, 1); &#125; else&#123; printf(&quot;%f&quot;, 3*x); &#125; return 0;&#125; 在run上述代码时，我发现整型数据以%f输出时，以及浮点数以%d输出时，会产生unexpected的结果，这个涉及底层类型转换，后面细说。 if-else常见错误 忘了大括号 if的括号加了; 如 if(age&gt;60); z则C的编译器理解为 if(age&gt;60) ; a=b是一个表达式，它也有一个结果就是b，因此，if(a=b)只要b不是0就为真。 编译器在看到你的程序有问题时，会给出两种类型的提示，一种时error，一种是warning。出现error编译器认为你的程序是错的因此不会产生可执行的东西，但warning，编译器不确定你的程序是不是出错了，最后还是做出来了可执行程序。一则笑话“从悬崖边立一块牌子——warning，则程序员都会掉下去。”所以我们要尊重warning。 虽然C语言的编译器它不管缩进，但是我们该加的要加，该规范的规范， 多路分支 级联的if-els一般用来判断在一定范围内我要怎么做，在另一范围内我要怎么做，但有时我们会碰到这样的问题，当我们这个变量等于一个特定值的时候，我们要这样做，等于另一个特定值时我们要那样做，我们用级联可以做到： 123456789101112131415161718192021222324#include &lt;stdio.h&gt;int main()&#123; //写一个分段函数 int type; scanf(&quot;%d&quot;,&amp;type); if (type==1) &#123; printf(&quot;你好&quot;); &#125; else if (type==2) &#123; printf(&quot;早上好&quot;); &#125; else if (type==3) &#123; printf(&quot;晚上好&quot;); &#125; else &#123; printf(&quot;啊对对对对&quot;); &#125; return 0;&#125; 但这样写有一个坏处，比如我输入3，程序先要比较前type是否等于1和2，才轮到和3比较，于是我们可以用switch-case写，当我们需要输入一些按键来做分支结构时，switch-case很实用，比如做电商项目时，需要用户输入数字来决定下一步程序做什么，用switch-case效率很高。 12345678910111213141516171819202122#include &lt;stdio.h&gt;int main()&#123; //写一个分段函数 int type; scanf(&quot;%d&quot;,&amp;type); switch (type) &#123; case 1: printf(&quot;你好&quot;); break; case 2: printf(&quot;早上好&quot;); break; case 3: printf(&quot;晚上好&quot;); break; default: printf(&quot;啊对对对对&quot;); break; &#125; return 0;&#125; 用switch-case比if语句的好处是，比如我输入3，程序会直接跳到case 3，它不会再慢慢比较上面的1和2。 而且，C语言里，switch()后面括号里的只能是整数型结果或枚举型结果，否则会error，比如double就不行。但是JAVA里，switch()括号里面可以不是整数，可以是字符串什么的，只要是具体的值就行。 其中case后面要跟一个常量(也可以是常量表达式 C99支持)，且case 的 constant-expression必须与 switch 中的变量具有相同的数据类型。JAVA里面case后面也是跟常量，比如具体的数字9，比如具体的字符串“hello”。 一个switch语句中只能有一个default语句，而且default语句可以省略。 如果把上面一段代码中的break全部删去，输入1，则会执行下面所有的printf语句，case并没有把代码分成一个个互斥的代码块，它只是从哪开始执行的入口，遇到break或者switch结束才会结束。switch里的break只跳出switch。 case后面的语句不需要加大括号，只要别忘了break就行。不过有的编程规范上会建议用大括号把case后面的语句括起来。“不能通过编译”，可能是下面这个原因。C/C++里规定，不能在case语句里定义局部变量。例如： 1234567891011int a = 2; switch (a) &#123; case 1: int c = 10; break; case 2: break; default: break; &#125; 编译就会出错，原因是在case 1里定义了局部变量c。而C/C++还有一个很有意思的规定，用｛｝包括的语句，认为是一个”语句块“，而在语句块里就能想干什么就干什么。 比如： 123456789101112switch (a) &#123; case 1: &#123; int c = 10; break; &#125; case 2: break; default: break; &#125; 这样就能通过编译了。 Day 5 while 循环 计算机最不擅长的就是一眼看出来，但这是人最擅长的，人对文字的处理能力要优于对数字的处理能力，计算机相反。比如要得到某一个4位数以下数字的位数，人一眼就看出来的事计算机要写一段代码。 123456789101112131415161718#include &lt;stdio.h&gt;int main()&#123; int x, n; printf(&quot;请输入一个4位以下的正整数：&quot;); scanf(&quot;%d&quot;, &amp;x); if (x&gt;999)&#123; n=4; &#125;else if (x&gt;99)&#123; n=3; &#125; else if (x&gt;9)&#123; n=2; &#125; else &#123; n=1; &#125; printf(&quot;%d位数&quot;, n); return 0;&#125; 再比较下面一段代码： 123456789101112131415161718#include &lt;stdio.h&gt;int main()&#123; int x, n; printf(&quot;请输入一个4位以下的正整数：&quot;); scanf(&quot;%d&quot;, &amp;x); if (x&gt;999)&#123; n=4; &#125;if (x&gt;99)&#123; n=3; &#125;if (x&gt;9)&#123; n=2; &#125;if (x&gt;0)&#123; n=1; &#125; printf(&quot;%d位数&quot;, n); return 0;&#125; 这样会发现无论怎么输结果都是1位数，这是因为，我们写程序时写的是步骤，而非说明。 对于上面的程序，判断4位以下的数字位数是没毛病的，但是要判断5位数呢，6位数呢，要一直加分支吗？那多麻烦啊， 1234567891011121314#include &lt;stdio.h&gt;int main()&#123; int x; int n=0; printf(&quot;请输入一个正整数：\\n&quot;); scanf(&quot;%d&quot;, &amp;x); while (x&gt;0)&#123; x/=10; n++; &#125; printf(&quot;%d位数&quot;, n); return 0;&#125; 问题迎刃而解。但整数在计算机里因为要用二进制表达它，所以是有范围的。 1234567if (x&gt;0)&#123; n++;&#125;while (x&gt;0)&#123; n++;&#125; 可见就是把 if 换成 while。循环体里要有改变条件的机会，否则会出现死循环，但这种出现语法上没有任何错误，但逻辑有错， do-while 循环 do-while在进入循环时先不做检查，而是在执行一轮循环体的代码后再来检查循环的条件是否满足，之前那个while在循环体前面，这个在循环体后面，只不过do-while，最后while()后面要跟一个; 猜数游戏 rand()和printf()一样，是一个系统库里面的函数， x%n的结果是[0, n-1]的一个整数， 1234567891011#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;int main()&#123; //随机输出一个0-100的随机数 srand(time(0)); int a=rand(); printf(&quot;%d\\n&quot;, a%100); return 0;&#125; 以下是猜数游戏源代码 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;int main()&#123; //随机输出一个0-100的随机数 srand(time(0)); int number=rand()%100+1; printf(&quot;我已经想好一个1-100之间的数了！\\n&quot;); int count=0; int a=0; do &#123; printf(&quot;请输入你猜的数吧！\\n&quot;); scanf(&quot;%d&quot;, &amp;a); count++; if (a&gt;number)&#123; printf(&quot;你猜大了哈哈哈\\n&quot;); &#125; else if (a&lt;number)&#123; printf(&quot;你猜小了哈哈哈\\n&quot;); &#125; else&#123; printf(&quot;Bingo!\\n&quot;); &#125; &#125; while (a != number); printf(&quot;哈哈哈哈你猜了%d次终于猜对啦！\\n&quot;, count); return 0;&#125; 算平均数 12345678910111213141516#include &lt;stdio.h&gt;int main()&#123; //计算average int sum=0; int x=0; scanf(&quot;%d&quot;, &amp;x); int n=0; while (x != -1)&#123; sum += x; scanf(&quot;%d&quot;, &amp;x); n++; &#125; printf(&quot;average=%f&quot;, (sum*1.0)/n); return 0;&#125; 整数逆序 分解一个多位数： 对一个整数做%10，得到它的个位数； 对一个整数做/10，去掉它的个位数； 再对第2步得到结果做%10，得到其十位数； 在对第2步得到的结果做/10，则去掉它的十位数； 以此类推。 1234567891011121314151617#include &lt;stdio.h&gt;int main()&#123; //整数逆序1 int x; int digit=0; int ret=0; printf(&quot;请输入一个正整数：&quot;); scanf(&quot;%d&quot;, &amp;x); while (x&gt;0)&#123; digit=x%10; x=x/10; ret=ret*10+digit; printf(&quot;x=%d,digit=%d,ret=%d\\n&quot;, x,digit,ret); &#125; return 0;&#125; 123456789101112131415#include &lt;stdio.h&gt;int main()&#123; //整数逆序2 int x; int digit=0; printf(&quot;请输入一个正整数：&quot;); scanf(&quot;%d&quot;, &amp;x); while (x&gt;0)&#123; digit=x%10; printf(&quot;%d&quot;, digit); x=x/10; &#125; return 0;&#125; for 循环 for (expression1; expression2; expression3) expression1:初始化动作 expression2:循环条件 expression3:循环体做完后要做的动作 for后面括号里的三个表达式都是可以省略的。for(;条件;)==while(条件)。 123456789101112#include &lt;stdio.h&gt;int main()&#123; int n; int factor=1; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; factor*=i; &#125; printf(&quot;%d&quot;,factor); return 0;&#125;//不能int i=2,因为n=1时就不对了 Day 6 循环的计算和选择 for循环和while循环是等价的，任何一个for循环和while循环都可以相互转换。 for 循环，while循环，do-while循环，tips: 有固定次数，用for,如算阶乘; 必须至少执行一次循环体，则do-while； otherwise用while循环； 循环控制 遇到break就会离开这一层循环，不管是for、while、do-while；continue是跳过这一轮循环，这一轮循环余下没做的语句就不做了，但没有出这一层循环，下一轮循环还要做， 1234567891011121314151617181920#include &lt;stdio.h&gt;int main()&#123; int x; int isPrime=1; printf(&quot;请您输入一正整数：\\n&quot;); scanf(&quot;%d&quot;, &amp;x); for (int i = 2; i &lt; x; ++i) &#123; if (x%i==0)&#123; isPrime=0; break; &#125; &#125; if (isPrime==0)&#123; printf(&quot;您输入的数是合数。&quot;); &#125; else&#123; printf(&quot;您输入的数是质数。&quot;); &#125; return 0;&#125; 嵌套的循环 循环的嵌套可以是for&amp;for、for&amp;while、也可以是while&amp;while嵌套，一般情况下。嵌套循环每一层循环使用的控制变量应该是不一样的。 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;int main()&#123; int x=2; int cnt=0; int isPrime=1; //只有当有素数出现时，cnt才加1，每个cnt后面都代表有一个素数输出，0-49即有50个素数输出 while (cnt&lt;50)&#123; // for (int j = 2; j &lt; x; ++j) &#123; if (x%j==0)&#123; isPrime=0; break; &#125; &#125; // if (isPrime==1)&#123; printf(&quot;%d\\t&quot;, x); cnt++; if (cnt%5==0)&#123; printf(&quot;\\n&quot;); &#125; &#125; // x++; isPrime=1; &#125; return 0;&#125; 从嵌套的循环中跳出 break和continue只能跳出它所在那一层循环。如果我想让内层循环满足一定条件后，直接跳出所有循环，可以把break和if联用，需要一个变量表达这个条件，在每一层循环的循环体最后用if判断一个条件，当都满足一定条件时，会相继跳出每层循环，叫做接力break。 123456789101112131415161718192021#include &lt;stdio.h&gt;int main()&#123; //用1角、2角、5角硬币凑出2元硬币 int x=2; int exit=0; for (int one = 0; one &lt;= 20; ++one) &#123; for (int two = 0; two &lt;= 10; ++two) &#123; for (int five = 0; five &lt;= 4; ++five) &#123; if (one+two*2+five*5==20)&#123; printf(&quot;可以用%d个1角,%d个2角,%d个5角凑出2元硬币\\n&quot;, one,two,five); exit=1; break; &#125; &#125; if (exit) break; &#125; if (exit) break; &#125; return 0;&#125; 这是其中一种手段，还有另外一种手段，我们还有一个好朋友叫goto，可以在需要离开循环的地方设置一个goto语句，在要跳的地方做一个标记label:，意味着goto跳到label那里去。 123456789101112131415161718#include &lt;stdio.h&gt;int main()&#123; //用1角、2角、5角硬币凑出2元硬币 int x=2; for (int one = 0; one &lt;= 20; ++one) &#123; for (int two = 0; two &lt;= 10; ++two) &#123; for (int five = 0; five &lt;= 4; ++five) &#123; if (one+two*2+five*5==20)&#123; printf(&quot;可以用%d个1角,%d个2角,%d个5角凑出2元硬币\\n&quot;, one,two,five); goto hell; &#125; &#125; &#125; &#125; hell: return 0;&#125; C语言有哪些基础数据类型 C语言是一种有类型的语言。即变量在使用前要先定义而且要确定类型，C语言之后的语言向两个方向发展： C++/Java 这种强类型语言，对类型的检查比C语言还严格； JavaScript、python、PHP 属于弱类型语言，不看重类型，甚至变量不需事先定义， 学界关于这件事情上划分两派 支持强类型语言的认为明确的类型有助于今早发现程序中的简单错误； 支持弱类型的认为，过于强调类型会迫使程序员面都对底层而非事务逻辑； 并没有说以上观点哪个是对的哪个是错的，总的来说，越早期的语言越强调类型，因为早期的语言面向底层，因为我们可能要用非常明确的类型来表达一些计算机内部的东西，但越面向应用的语言越忽视类型。C语言虽然是强类型语言，但对类型的安全检查相比后面的语言并不足够，C语言的基础数据类型可以分为以下几类： 整数 char、short(短整型)、int(整型)、long(长整型)、long long 浮点数 float、double、long double 逻辑(布尔类型) bool(人为定义)C99才出现布尔类型 指针 除了基础数据类型。C语言还有自定义数据类型等等， 不同类型除了类型名称不同外，* 输入输出的格式化也不同如 %d、%ld、%f， 所表达数的范围不同， char&lt; short&lt; int&lt; float&lt; double 在内存中占据的内存大小不同，char是一个字节，long double是16个字节 不同类型变量在内存中的表现形式不一样，整型变量在内存中是自然二进制码或二进制的补码，而对于浮点数，它是一种编码形式，而不是自然二进制数，这就意味着它不能直接拿来做运算，而两个整数可以直接拿它的二进制码在加法器里面做加法， C语言给出了一个运算符 sizeof()，它可以给出某个类型或者某个变量在内存中占据的字节数，eg,sizeof(int), sizeof(i), 123456789#include &lt;stdio.h&gt;int main()&#123; int a; a=6; printf(&quot;sizeof(long double)=%ld\\n&quot;, sizeof (long double)); printf(&quot;sizeof(a)=%ld\\n&quot;, sizeof (a)); return 0;&#125; 但是sizeof()是一个静态运算符，它的结果在编译时就已经决定了，不要在sizeof里做运算，这些运算不会做，比如下面这串代码 12345678910#include &lt;stdio.h&gt;int main()&#123; int a; a=6; printf(&quot;sizeof(long double)=%ld\\n&quot;, sizeof (long double)); printf(&quot;sizeof(a)=%ld\\n&quot;, sizeof (a++)); printf(&quot;a=%d\\n&quot;, a); return 0;&#125; 输出结果仍是a=6，因为a根本没有做，编译器在编译是看到sizeof，就会看sizeof括号里那个表达式结果会是什么类型的，然后根据这个类型就决定了“sizeof(a)”这个整体后面会被替换成一个什么样的数字，所以当程序编译完后这个6就已经确定下来了，a++并没有产生实际要执行的代码，sizeof是静态运算符并不会真的去做运算。 除了int还有多少种整数类型 char:1字节,用于声明单个字符的关键字。C语言没有专门用于存储字符串的变量类型，字符串都被存储在char类型的数组中。数组由连续的存储单元组成，字符串中的字符被存储在相邻的存储单元中，每个单元存储一个字符。C语言中，一个汉字占据两个char类型。十分注意，JAVA里面char类型占2个字节。 在打印汉字时，它的两个char必须紧跟着。 short:2字节 int:取决于编译器和CPU，通常的意义是“1个字”。字:CPU一次性传输，运算或处理的二进制数据。 long:取决于编译器和CPU，通常的意义是“1个字” long long:8字节 都知道计算机内部有一个东西叫CPU，CPU外面还有个东西叫内存，CPU和内存中间有一个叫总线的东西将两者连接，CPU里面有个东西叫寄存器(Reg.)，当我们说计算机字长时，就是在说寄存器多宽，也就是说这个寄存器是几个比特的，比如寄存器每次能处理32bit的数据，也就是说每次总线从内存向CPU传数据每次能传32bit的数据，那么这个字长也就会在C语言中反映为int，也就是int想要表达的是计算机一个寄存器的大小，所以在不同的电脑什么int会变得不一样大。 CPU位数=CPU中寄存器的位数=CPU能够一次并行处理的数据宽度（位数=数据总线宽度=计算机字长 我们平时用的数据类型，默认是signed，只不过signed缺省了，如果要定义无符号数，只需在前面加unsigned。需要注意的是，unsigned int 和int 是2种数据类型，所能表达的最大值也不同，前者是2的32次方-1，后者是2的31次方-1。 C语言除了基本数据类型，还有其它数据类型： 基本数据类型； 枚举类型enum； 空类型void； 派生类型：(类似JAVA的引用类型) 指针类型； 数组类型； 函数类型； 结构体类型； 整数的内部表达 我们怎么用二进制表达负数呢？ 可以仿照十进制，有一个特殊的标志来表示负数； 取中间数为0，如10000000表示0，比它小的是负数，比它大的是正数； 补码 第一种方案有个问题就是，计算机在做加法减法是，需要特别判断符号位，并且符号位不参与运算，但这样不能像正常的二进制一样做运算，会让计算机做运算更加复杂。 如果采用中间数，那么比如10000000本来表示128，我们如果强制规定这个数是0D，那我们想得到其它数就得都减去10000000，比如我们想得到1D，就得用10000001-10000000，还是太麻烦。 我们希望-1+1=0，假设我们现在只占用1个字节，0是00000000，1是00000001，那么如果我们用11111111+00000001，那么结果是100000000，变成9位，但我们目前只能用8位，所以最高位1被丢弃，结果就是00000000。11111111被当作普通的二进制数看待是255，被当作补码看待是-1，即11111111就是1二进制数的2的补码，补码得意义就是拿补码和源码可以加出一个溢出的0，用补码的好处是，需要做正负运算时，直接用最普通的二进制运算就能得到正确的结果， 整数的范围 对于一个8位的二进制数，表达无符号数的范围是0-255，表达有符号数是-128-127。 前面提到char类型占用1个字节，int占用和字长相同的字节。 123456789101112#include &lt;stdio.h&gt;int main()&#123; printf(&quot;%d\\n&quot;, sizeof(int)); printf(&quot;%d\\n&quot;, sizeof(char)); char a=127; char b=255; int c=255; int d=2147483648; printf(&quot;a=%d,b=%d,c=%d,d=%d&quot;, a,b,c,d); return 0;&#125; 这段代码的输出只有理解《Code》13章才能看懂，代码输出是： 12341a=127,b=-1,c=255,d=-2147483648 我的电脑CPU是X64，也就是： CPU位数=CPU中寄存器的位数=CPU能够一次并行处理的数据宽度（位数=数据总线宽度=计算机字长=64) 不是说int反映是计算机字长吗，sizeof出来怎么是4个字节32位，原因是编译器的问题，编译器也会决定int的空间。然后char占用一个字节的内存众所周知，那么我们明明给a赋值是255，怎么输出变成了-1呢？有个前提，C语言中char short int long等在不指定signed或unsigned时都默认为signed，所以我们默认情况下给b赋值255，255存到b那块内存变成255的二进制数11111111，等到输出是，char默认转成int型，变成11111111 11111111 11111111 11111111按照signed输出，就是按照那两个圈的对应关系输出，11111111 11111111 11111111 1111111对应-1，所以输出-1。而char a=127，127的二进制数是01111111，在那两个圈的前半圈，按照对应关系，输出还是127。 到了int这变也是，int默认输出signed，int也是按照那两个圈，但由于int占用4个字节32位，所以int的圈大的多，4个字节的0int表示的范围是-2(31)-2(31)-1即-2147483648-2147483647，我们赋给d的值是2147483648，存到d那块内存上就是2147483648的二进制数00000000 00000000 00000000 01111111，计算机按照那两个圈圈，输出该二级制数的补码，再转化成该补码的十进制数，即-2147483648。赋给c的数255由于在圈的前半圈，所以同样按照对应规则输出为255。 我们想让计算机输出无符号数，需要加个unsigned，代表输出的十进制数是无符号数即，没有负数部分。我们试试看： 123456789101112#include &lt;stdio.h&gt;int main()&#123; printf(&quot;%d\\n&quot;, sizeof(int)); printf(&quot;%d\\n&quot;, sizeof(char)); char a=127; unsigned char b=255; int c=255; unsigned int d=2147483648; printf(&quot;a=%d,b=%d,c=%d,d=%d&quot;, a,b,c,d); return 0;&#125; 输出结果是： 12341a=127,b=255,c=255,d=-2147483648 哎怎么回事，我们明明unsigned了，int d=2147483648的输出怎么还是负数，char类型倒是没啥问题，输出的看上去和无符号数一样。问题出在%d上，%d 输出有符号10进制整数，所以即使我们unsigned了，但是%d输出还是按照有符号数输出，%u输出无符号10进制整数，所以我们将%d改成%u就没问题了。至于为什么b按照%d输出不是-1而是255，看上去输出的是无符号数呢？其实不是，char short int类型会按照int来输出,当小于int的整型变量传给printf时，编译器会把该整型变量自动转为int，即在unsigned char那里的255，会变成00000000 00000000 00000000 11111111，按照int有符号数来输出的话，也是255。所以b其实输出的也是有符号数。 123456789101112#include &lt;stdio.h&gt;int main()&#123; printf(&quot;%d\\n&quot;, sizeof(int)); printf(&quot;%d\\n&quot;, sizeof(char)); char a=127; unsigned char b=255; int c=255; unsigned int d=2147483648; printf(&quot;a=%u,b=%u,c=%u,d=%u&quot;, a,b,c,d); return 0;&#125; 输出是 12341a=127,b=255,c=255,d=2147483648 看，没问题了，对味了。既然%u能输出无符号十进制数，那我们直接unsigned也不要了单靠%u，试试能不能输出无符号数： 123456789101112131415161718192021#include &lt;stdio.h&gt;int main()&#123; printf(&quot;%d\\n&quot;, sizeof(int)); printf(&quot;%d\\n&quot;, sizeof(char)); char a=127; char b=255; char i=-1; char e=128; //按照%u输出 char h=127; char f=255; char j=-1; char g=128; //按照%d输出 int c=255; int d=2147483648; printf(&quot;a=%u,b=%u,i=%u,e=%u; h=%d,f=%d,j=%d,g=%d; c=%u,d=%u&quot;, a,b,i,e, h,f,j,g, c,d); return 0;&#125; 输出： 12341a=127,b=4294967295,i=4294967295,e=4294967168; h=127,f=-1,j=-1,g=-128; c=255,d=2147483648 哎我们发现不行，这时我们发现先辈用unsigned不是摆设，单靠%u不行，从上文我们知道char short int类型会按照int来输出,当小于int的整型变量传给printf时，编译器会把该整型变量自动转为int，也就是上午中unsigned char b=255，按照%u输出时，内存中的11111111靠编译器传给printf时，编译器会把11111111转为00000000 00000000 00000000 11111111，在输出，输出为255，没问题。那么这里为什么变成了b=4294967295，这是什么东西？我们仔细观察发现，4294967295=2的32次方，即11111111 11111111 11111111 11111111，不是说好的转成00000000 00000000 00000000 11111111吗，怎么转成了11111111 11111111 11111111 11111111？原来，加了unsigned的char，就是无符号数，编译器在转换的时候就当无符号数转，多出来的位补0，但若没加unsigned，则在在转成int时，按照有符号数去转，255的二进制有符号数最高位是1，所以多出的位用1补(按位右移:整个位向右移动，左边补符号位对应的内容，正数补0，负数补1，注意，这是针对有符号数)，转成的11111111 11111111 11111111 11111111按照有符号数输出就是-1，f印证了这一点，按照无符号数输出就是4294967295，b印证了这一点。同理，a在定义时也没加unsigned，但a是01111111，在转成int时虽然也按照有符号数转，但最高位为0，多出的位补0所以转成后是00000000 00000000 00000000 01111111，按照有符号数和无符号数输出都是127，a和h印证了这一点。e的遭遇同理，由于没有加unsigned，在char那一个字节上虽然是10000000，但是转int时按照有符号数去转，多出的位补1，最后转成11111111 11111111 11111111 10000000，这个数按照有符号数输出是-128，按照无符号数输出是4294967168，g和e可以印证这一点。最后看char i=-1和char j=-1，输出结果和char b=255和char f=255一样，可见-1和255赋值给char类型时，都是默认按照11111111赋值。 即计算机内存里的二进制数就在那，输出什么取决于我们怎么看它，是把它按照有符号数的对应关系输出还是按照无符号数的对应关系输出，至于unsigned，它决定char这种小于int的整型在输出转成int型时，多出来的位补0还是补1. 看来还是得unsigned 和 %u一块上。但如果定义unsigned char a=255，再输出++a，得到的结果是0，这不是因为输出的结果是有符号数的原因，输出的还是无符号数，只是100000000最高位的1上溢被计算机扔了。 常量和变量都属于变量，只不过常量是赋过值后不能再改变的变量，而普通的变量可以再进行赋值操作； 字面量是指由字母，数字等构成的字符串或者数值，它只能作为右值出现，所谓右值是指等号右边的值，如：int a=123这里的a为左值，123为右值。字面量是一个具体的值，比如变量的值或者常量的值。 在C中，如果一个字面量常量想表达自己是unsigned，可以在后面加u或U，想表示自己是long类型，可以在后面加l或L，设计unsigned的初衷并不是扩展这块内存所能表达的无符号数的范围，而是为了做纯二进制计算，主要是为了移位。 整数的格式化 虽然我们有很多种不同的整数类型，char short int long longlong，但在做scanf和printf输入和输出时，只有int 和 longlong这两种形式。也就是所有小于等于int的，也就是char short int 这三种，都采用int(%d)来输出，所有比int大的整型，用longlong来输出(%ld)，unsigned用%u输出。 printf中的f是format的意思，意思是格式化打印；同理，scanf是格式化扫描的意思。 % 是格式控制符，%d后面的d是Decimal integer的意思，详见该链接 1个以0开头的数字字面量是8进制；1个以0x开头的数字字面量是16进制。想要输出8进制就用%o，想要输出十六进制，数码是大写的ABCDEF,则用%X，想要输出十六进制，数码是小写的abcdef，则用%x。scanf里面用%o和%x都是表示莪们读进来的数当作八进制数和十六进制数。 12345678#include &lt;stdio.h&gt;int main()&#123; char a=012; char b=0x12; printf(&quot;a十进制=%d，b十进制=%d；a八进制=0%o，b十六进制=0x%x或0X%X,&quot;, a,b, a,b,b); return 0;&#125; 输出 1a十进制=10，b十进制=18；a八进制=012，b十六进制=0x12或0X12, 主要，不管我们给变量赋的值是八进制还是十六进制，存在计算机内存上的只有二进制，比如char a=012，a那里存的其实是八进制12的二进制数00001010，输出就根据00001010看是%d还是%u还是%x还是%o。 因为十六进制和二进制转换4位一换很方便，所以我们常常用16进制数表达二进制数。 选择整数类型 为什么C语言里面有这么多整数类型，是因为早期的语言需要准确地表达计算机内部的硬件，比如有一个输入输出的端口，那个端口就是16bit的，用short来表达刚好。 有些教科书可能会说，用short可以省一些内存什么的。但现在的计算机已经不是当年的计算机了，现在CPU起码是32位的，如果用char，那CPU还是得从内存中一次读32bit出来，然后在把那8bit从32bit中剥出来给你，不见得比能直接反映计算机字长得int更省事，所以我们今天没有特别需求就用int，除非要做硬件，平时也不会用unsigned，比如java它就不区分有符号数和无符号数，因为如果不做底层硬件，这些操作都用不上。 浮点类型 类型 大小(bit) 范围 有效数字 scanf printf float 32 -3.40×10^38 — (-1.20×10^-38) &amp; 0 &amp; 1.20×10^-38 — 3.40×10^38，±inf，nan 7 %f %f, %e double 64 -1.79×10^308 — (-2.20×10^-308) &amp; 0 &amp; 2.20×10^-308 — 1.79×10^308，±inf，nan 15 %lf %f, %e %e是输出科学计数法 1234567#include &lt;stdio.h&gt;int main()&#123; double a=1234.56789; printf(&quot;%e,%E,%f&quot;,a,a,a); return 0;&#125; 输出： 11.234568e+03,1.234568E+03,1234.567890 1234567891011#include &lt;stdio.h&gt;int main()&#123; double a=1E-10; printf(&quot;%e,%E,%f,%.16f&quot;,a,a,a,a); //double的范围可以包含1E-10，因为它有15位的有效数字 return 0;&#125;输出```C1.000000e-10,1.000000E-10,0.000000,0.0000000001000000 在%和f之间加上.n可以指定输出小数点后n位，这样的输出是要做4舍5入，但是我们有时感觉不是四舍五入，比如下面的printf(&quot;%.3f\\n&quot;,-0.0045); 我们本以为是-0.005，输出结果却是-0.004，怎么回事，看上去不是四舍五入。其实就是四舍五入，只不过如果5后面全是0 那么有可能是4999999这种情况，因此很可能后面的全部舍去。总而言之，如果第(n+1)位是5，5后面有非0数则进1，5后均为0则不进1，全舍去。 123456789101112#include &lt;stdio.h&gt;int main()&#123; // 负数四舍五入和正数规则一样 printf(&quot;%.3f\\n&quot;,-0.0045); printf(&quot;%.3f\\n&quot;,-0.0055); printf(&quot;%.3f\\n&quot;,-0.0046); printf(&quot;%.3f\\n&quot;,-0.00451); printf(&quot;%.30f\\n&quot;,-0.0049); printf(&quot;%.3f\\n&quot;,-0.00049); return 0;&#125; 输出： 123456-0.004-0.005-0.005-0.005-0.004899999999999999841793218991-0.000 -0.004899999999999999841793218991这是什么？实际上0.0049在计算机内部不能精确地表达为0.0049，我们在数学上数可以是连续的，但是在计算机内部，数只能被离散地表达，比如我们想表达0.0049，但是计算机不能表达0.0049，只能取0.0049最近的能在计算机内部表达的数代替0.0049，这就是浮点数的精度，当然double比float精度高，这是天然的缺陷。 Day 8 浮点数的范围和精度 printf输出±inf表示超过范围的浮点数：±∞ printf输出nan表示不存在的浮点数 12345678#include &lt;stdio.h&gt;int main()&#123; printf(&quot;%f\\n&quot;,12.0/0.0); printf(&quot;%f\\n&quot;,-12.0/0.0); printf(&quot;%f\\n&quot;,0.0/0.0); return 0;&#125; 输出： 123inf-infnan 上面的代码若用%d输出，则会报错，因为inf无法用整数表达，但可以用浮点数表达。虽然浮点数表达的实数范围是有限的，但可以表达0，±inf，nan这几个特殊的值。 1234567891011121314#include &lt;stdio.h&gt;int main()&#123; float a=1.345f; float b=1.123f; //带小数点但不带f的字面量是double float c=a+b; if (c==2.468)&#123; printf(&quot;相等\\n&quot;); &#125; else&#123; printf(&quot;不相等,c=%.10f或c=%f\\n&quot;,c,c); &#125; return 0;&#125; 输出 1不相等,c=2.4679999352或c=2.468000 float只有7位有效数字，即c=2.4679999352只有前7位c=2.467999是准确的，即在计算机内部它不是2.468，这是有误差的。所以如果要用浮点数做精确运算，最后误差会累计起来，不要用浮点数做精确运算，也不要让两个浮点数去直接判断是否相等，可以让两个浮点数差的绝对值小于某个很小的值来判断是否相等。卡西欧计算机是用整数来做小数运算的。 浮点数：N = M × R^(e) 其中，M称为数N的尾数，决定数的精度。E是数N的阶码(指数)，决定数的范围。 比如12.5×2(3)，和12.51×2(4)，尾数分别是12.5和12.51，显然12.51精度更高；阶码分别是3和4，显然4的范围更大。 浮点数在计算机内部和整数不同，整数可以用纯二进制表示，可以直接拿二进制做运算，但浮点数在计算机内部靠编码的形式表达，第一个bit表达正负号，后面几个bit表达以2为底的阶码(指数)，剩下的位数表示尾数。 类型 占用内存(bit) 内存分配 指数范围 float 32 1符号位,8指数位,23尾数位 [-127,128] double 64 1符号位,11指数位,52尾数位 [-1023,1024] 欲详细了解浮点数在内存中的存储方式，click this来点我呀 现在的CPU都带着专门做浮点计算的硬件，浮点数的编码形式会被该硬件解开，然后做浮点运算，得到结果硬件会把它编码再输出。计算double和计算float所用到的硬件是一样的。 没有特殊需求用double,因为现在CPU能直接对double做硬件运算，性能不会比float差，在64位的机器上速度也不比float慢。 字符类型 char不仅表示一种整数类型，还能表示字符类型，是character的前4个字母 我们给char类型赋值时，赋’1’和赋49是等价的。在计算机内部都是00000001，用%d输出就是49，用%c输出就是’1’，它的二进制就在计算机里，取决于你怎么看它。 12345678910111213141516171819#include &lt;stdio.h&gt;int main()&#123; if (&#x27;1&#x27;==49)&#123; printf(&quot;Then，OK&quot;); &#125; return 0;&#125;···果然输出OK，了解了输出的 %c ，看输入时scanf的作用，```C#include &lt;stdio.h&gt;int main()&#123; char a,b; scanf(&quot;%d %c&quot;, &amp;a,&amp;b); printf(&quot;a=%d,b=%d; a=%c,b=%c&quot;,a,b,a,b); return 0;&#125; 我们输入1 1，输出： 1a=1,b=49; a=╔,b=1 这样可以得出结论，scanf中的%c，会把输入当作字符解读，同样是输入1，%d当作整数1，%c当作‘1’，而输出的 ╔ 是因为根据ASCII码，十进制1对应 ╔ 。 如果同时在scanf里做2个输入，要不要加空格呢？看下面的代码 12345678910#include &lt;stdio.h&gt;int main()&#123; int a; char b; scanf(&quot;%d %c&quot;, &amp;a,&amp;b); //有空格 printf(&quot;a=%d,b=%d,b=%c&quot;,a,b,b); return 0;&#125; 我们分别输入 12a ，12 a，12 a， 输出结果都是 a=12,b=97,b=a 12345678910#include &lt;stdio.h&gt;int main()&#123; int a; char b; scanf(&quot;%d%c&quot;, &amp;a,&amp;b); //没空格 printf(&quot;a=%d,b=%d,b=%c&quot;,a,b,b); return 0;&#125; 我们分别输入 12a ，12 a，12 a， 输出结果分别是 a=12,b=97,b=a a=12,b=32,b= a=12,b=32,b= 为什么呢，注意空格的ASCII码就是32，也就是%d后面没有空格，则老老实实读下一个，即使下一个是空格也要读入，若有空格，则读完第一个，要把第一个后面的空格都读完才读下一个输入。 简单讲&quot;%d %c&quot;可以以0个或多个空白字符（空格、tab键、回车等）作为分隔符，同时%c不会读取空白字符，%c读取的一定是一个非空白字符。 scanf中的%d%d%d 是按十进值格式输入三个数值。输入时，在两个数据之间可以用一个或多个空格、tab 键、回车键分隔。 如果3个%d之间是用空格隔开的，像这样 %d %d %d 那么我们在每输入一个整数后必须输入一个分隔符，分隔符可以是空格、tab、回车。 如果使用 , 来分隔输入的 %d, 相应的输入时也需要添加&quot;,&quot;。 在用 %c%c%c 输入时，空格和&quot;转义字符&quot;均作为有效字符，除非%c之间用空格隔开。 scanf()函数使用空白（换行符、制表符和空格）把输入分成多个字段。 在依次把转换说明和字段匹配时跳过空白。只要在每个输入项之间输入至少一个换行符、空格或制表符即可，可以在一行或多行输入。唯一例外的是%c会读取每个字符，包括空隔符。 scanf()函数允许把普通字符放在格式字符串中，除空格字符外的普通字符必须与输入字符串严格匹配。 注意，scanf()中的 %md 和printf()中的 %md 含义是不同的。 键盘缓冲区残余信息问题： 12345678910111213#include &lt;stdio.h&gt;int main()&#123; int a; char c; do &#123; scanf(&quot;%d&quot;,&amp;a); scanf(&quot;%c&quot;,&amp;c); printf(&quot;a=%d c=%c\\n&quot;,a,c); /*printf(&quot;c=%d/n&quot;,c);*/ &#125;while(c!=&#x27;N&#x27;);&#125; scanf(&quot;%c&quot;,&amp;c);这句不能正常接收字符,什么原因呢？我们用printf(“c=%d\\n”,c);将C用int表示出来，启用printf(“c=%d\\n”,c);这一句，看看scanf()函数赋给C到底是什么，结果是 c=10 ,ASCII值为10是什么？换行即\\n.对了，我们每击打一下”Enter”键，向键盘缓冲区发去一个“回车”(\\r),一个“换行”(\\n),在这里\\r被scanf()函数处理掉，而\\n被scanf()函数“错误”地赋给了c. 解决办法：可以在两个scanf()函数之后加个fflush(stdin);，还有加getch(); getchar();也可以，但是要视具体scanf()语句加那个，这里就不分析了，读者自己去摸索吧。但是加fflush(stdin);不管什么情况都可行。 这种残留情况一般存在与上一个scanf()是%d，下一个scanf()是%c的情况，类似一个scanf()里面有%d%c，两个挨着，%c就会直接读下一个字符，即使下一个是回车。如果改成这样的代码： 123456789#include &lt;stdio.h&gt;int main()&#123; int a, b; scanf(&quot;%d&quot;, &amp;a); scanf(&quot;%d&quot;, &amp;b); printf(&quot;%d,%d&quot;, a, b); return 0;&#125; 输入12(回车)13，或者输入12(空格)13，输出就是12,13，不会读入那个回车，这种情况就类似于一个scanf()里面有%d%d,两个挨着，第2个%d就会认为回车是分隔符，直接跳过去读入下一个整数，也不会有缓冲区残余问题。 C语言的编码系统 C语言是 70 年代的产物，那个时候只有ASCII，各个国家的字符编码都还未成熟，所以C语言不可能从底层支持 GB2312、GBK、Big5、Shift-JIS等国家编码，也不可能支持 Unicode 字符集。 在C语言中字符有两种，一种是窄字符，另一种是宽字符。 只有 char 类型的窄字符才使用 ASCII 编码 char 类型的窄字符串、宽字符和宽字符串都不使用 ASCII 编码！wchar_t 类型的宽字符和宽字符串使用 UTF-16 或者 UTF-32 编码对于窄字符串，C语言并没有规定使用哪一种特定的编码，只要选用的编码能够适应当前的环境即可，所以，窄字符串的编码与操作系统和编译器有关。 可以肯定的说，在现代计算机中，窄字符串已经不再使用 ASCII 编码了，因为 ASCII 编码只能显示字母、数字等英文字符，对汉语、日语、韩语等其它地区的字符无能为力。对于窄字符串，C语言并没有规定使用哪一种特定的编码，只要选用的编码能够适应当前的环境即可，所以，窄字符串的编码与操作系统和编译器有关。 逃逸字符 逃逸字符：又叫转义字符，因为\\后面的字符，都不是它本来的ASCII字符意思了，所以叫转义。用来表达无法打印出来的字符，\\和后面一个字符共两个字符组成一个字符，注意逃逸字符是1个字符。 终端本身是一个别人写好的程序，叫shell，我们写的程序由shell执行，我们的程序只和shell打交道，我们在键盘上输入是被shell接收，然后shell再传给我们的程序，我们的程序输出什么东西，传给shell，shell展示给我们看。在shell充当媒介的过程中并不诚实，它要做一些翻译工作，比如程序里面有逃逸字符，shell要把这些逃逸字符翻译出来展示给我们看。不同的shell会对相同的转义字符作出不同的翻译，比如 “\\b” 在一些终端上是不显示的，在一些终端上显示BS(backslash)， 123456#include &lt;stdio.h&gt;int main()&#123; printf(&quot;123\\bA&quot;); return 0;&#125; 输出是 12A，可见\\b是将后面的字符安排在\\b前一个字符位置上并覆盖之，若\\b后面没有字符，则不覆盖。当然也可能找到其它的shell，其对\\b是不同的解释 \\n : 换行符（newline） 源自打字机，打字机上面的车(carriage)，随着打字，车会逐渐左移，打完1行用手把车拉回最右边叫回车，在这个过程中，要把纸往上抬一行，让打字机的写入位置放到下一行，就是换行。这俩字符在打字机上是两个动作，但我们在printf里面只用一个\\n就实现了回车换行，那是因为shell会把我们程序的\\n翻译成\\n和\\r \\r : 回车符（carriage return） 只有\\r，则光标会跳到这一行的开头去，\\r后面的内容会从头开始覆盖。 \\t : 制表符(tab) 相当于按下一个tab键 表格位是说在每一行中有一些特定的位置，用一个\\t可以让下一个输出从下一个表格位开始，比如当前光标在第3个表格位中间，后面加一个\\t，光标就会跳到下一个表格位始端。\\t不代表固定的字符数量而代表输出的位置，比如： abc | ab | 不管前面有几个字符，敲一个tab键光标都会跳到相同的位置。 1234567#include &lt;stdio.h&gt;int main()&#123; printf(&quot;123\\tA\\n&quot;); printf(&quot;12\\tA&quot;); return 0;&#125; 输出： 12123 A12 A Day 9 类型转换 C语言的运算符2边出现不一致类型时会自动转换成较大的类型。 运算中整数型与浮点型的处理 整数型的除法运算是舍位运算，而不是四舍五入，如 int t; t=20/3;这里的结果t=6；浮点型的运算按精度要求四舍五入。 当运算中的两个数分别是浮点型和整数型是以浮点型的规则进行运算，当出现整数常数时，如3，可以写成3.0来表示浮点型格式。当算式中超过三个数时，从左到右分别按如上两位数的规则进行。 以下举例来说明一些情况： 首先说明各个数值的类型，其次举例说明结果。 整数型=浮点型/整数型： 这个是以浮点型来运算的，但是结果是整数型的，例20.0/3=6.66…，但由于结果是整数型的，进行舍位，结果为6； 浮点型（0.1f）=浮点型/整数型：浮点型规则运算，结果等于6.7； 浮点型=整数型/整数型：整数型运算，计算结果舍位，等于6.0； 整数型/整数型×浮点型，同级运算从左到右，这里先进行整数型的除法，再进行浮点型乘法，如11/4×10.0=20；因为整数除法会舍位，故11/4=2，2×10=20. float/float 进行运算，float自动转为double，所以结果是double; int/float 进行运算，float同样会自动转成double，所以int也会转成double，所以结果是double. 给我们的教训是我们在写程序时应注意变量类型的的定义，以及对精度有要求时尽量先计算浮点型，如果表达式最左边是浮点数，那么后面的算术运算都是最起码以浮点的规则进行计算。出现常数时用3.0这个书写形式定于为浮点型。 所有的浮点运算都是以双精度进行的，即使运算中只有 float 类型，也要先转换为 double 类型，才能进行运算。 字符型数据和short型数据在算术表达式中，一律转换为int型数据后，再参与运算。这一点和JAVA一样。 将一个double赋给float，先将双精度转为单精度，即只取6-7位有效数字，存储到float型变量的4个字节中，当double的数值大小不超出float的数值范围时，编译器也不会报错，只是IDE会给警告。比如： 12345678#include &lt;stdio.h&gt;int main()&#123; double a = 1.0; float b = a; printf(&quot;%f&quot;, b); return 0;&#125; 一样能执行 将一个float赋给double，数值不变，在内存中以8个字节存储，有效位数扩展到15位。 将一个占字节多的整型(不是浮点数)赋给一个占字节少的整型变量时，只将低字节(即低地址)原封不动地送到被赋值地变量(即发送截断)。 当表达式中存在有符号类型和无符号类型时所有的操作数都自动转换为无符号类型。因此，从这个意义上讲，无符号数的运算优先级要高于有符号数，这一点对于应当频繁用到无符号数据类型的嵌入式系统来说是丰常重要的。 对于printf，任何小于int的类型都会自动转为int，float会自动转为double，这也是为什么scanf读入double时需要%lf，读入float%f即可；而printf输出double和float都是%f，，因为输出时不管原来是float还是double，都会自动转为double输出，所以printf里面只有%f没有%lf。在有些系统中printf里用%lf也不会出错，但是尽量还是按照标准来。但scanf就不行，想输入short必须%hd，想输入longlong要%ld。 printf的%f说明符的确既可以输出float型又可以输出double型。 根据&quot;默认参数提升&quot;规则(在printf这样的函数的可变参数列表中 ，不论作用域内有没有原型，都适用这一规则)float型会被提升为double型。因此printf()只会看到双精度数。严格地讲，%lf在printf下是未定义的，但是很多系统可能会接受它。要确保可移植性，就要坚持使用%f。 对于scanf，情况就完全不同了，它接受指针，这里没有类似的类型提升。(通过指针)向float存储和向double存储大不一样，因此，scanf区别%f和%lf。 除了C语言的自动类型转换还有强制类型转换，但一般是大的往小的转才用到强制类型转换。比如 (int)10.2//把浮点数转为整数 (short)32//把int转为short 但是大转小有安全隐患，因为小的表达的数的范围比较小，可能存在溢出。 还要注意一点，类型转换只是临时性的，无论是自动类型转换还是强制类型转换，都只是为了本次运算而进行的临时性转换，转换的结果也会保存到临时的内存空间，不会改变数据本来的类型或者值。强制类型转换不是改变原有变量的值和类型，而是将新值赋给一个新的变量。比如 int i=32768; short s=(short) i; i并不改变 1234double a=2.0;double b=2.0;int i=(int)a/b;int j=(int)(a/b); i和j是不同的，i的意思是先把a转成int再去和b运算得到的结果依然是double。因为强制类型转换的优先级高于四则运算。 逻辑类型 又叫bool类型，实际上在C99之前没有bool类型，做关系运算时得到的结果是整数0或1，C89开始有雏形，C99确定一个类型叫bool，但它不是原生类型，需要包含一个头文件&lt;stdbool.h&gt;，才能使用bool，但是它在计算机内部实际上还是整数。比如： bool b =6&gt;5; bool a =2; //a就=2了 //这些都是合法的 逻辑运算 逻辑运算是对逻辑量进行的运算，结果只有0或1，关系运算是大于小于等于这些，但逻辑运算是或与非； 逻辑；量是逻辑运算的结果。 与(逻辑乘)：0&amp;&amp;1=0；0&amp;&amp;0=0；1&amp;&amp;1=1； 或(逻辑加)：0||0=0；0||1=1；1||1=1； 非：!1=0；!0=1； 表达x∈(4,6)不是4 &lt; x &lt; 6，而是4 &lt; x &amp;&amp; x &lt; 6，判断一个字符是否是大写英文字母则，‘A’ &lt;= x &amp;&amp; x &lt;= ‘Z’,X &lt; 0 || X &gt; 99。 赋值运算优先级永远是最低的，()永远是最高的，！由于是单目运算符所以优先级比加减乘除高，&amp;&amp;和||优先级比关系运算低。 短路；逻辑运算是自左向右进行的，如果左边的结果已经能够决定结果，就不会再执行逻辑运算符右边的计算。譬如： a6&amp;&amp;b1，此时如果a6为true，就不会比较b1。 a–6&amp;&amp;b+=1，此时如果a==6为true，就不会做b+=1。 对于&amp;&amp;左边是false就不做右边了 对于||左边是true右边就不做了 条件和逗号运算 条件运算符(还有关系运算符和逻辑运算符呢)：比如下面一段代码： if (count&gt;20) count=10; else count=11; 可以用下面的条件运算符代替 count=(count&gt;20)?count=10:count=11 这又是一个编程语言早期遗漏下来的问题。现在一般不要用，不易读。 逗号在C语言里是一个运算符，用来连接两个表达式，然后用右边表达式的值作为运算的结果。逗号运算符是所有运算符里面优先级最低的，比 = 还低， i=3+4,5+6 输出i=7, 5+6没有赋给任何变量。逗号运算符确保操作数被顺序地处理：先计算左边的操作数，再计算右边的操作数。右操作数的类型和值作为整个表达式的结果。左操作数只是为了副作用需要而被计算，它其值会被丢弃。 逗号运算符就在for循环里有用武之地。如果想在for的括号里放多个计算就可以用,比如： for (i=0,j=10;i &lt; j;i++,j–) Day 10 初见函数 如果一段程序里面出现很多串重复的代码，那么就叫代码复制，出现代码复制是程序不良的表现，因为将来要修改可能要改很多处才改得完。我们拿出重复的部分封装起来，用到时调用它即可。 函数的定义和调用 函数是一块代码，有一个名字，接收0或多个参数，做一件事情，并返回0或1个值。 注意最多只能返回1个值，这一点与python不同，python函数可以返回多个值。 12345678910#include &lt;stdio.h&gt;void sum(int begin, int end) // 函数头&#123; // 函数体 大括号一定要带 int i; int sum; for ( i = begin; i &lt; end; ++i) &#123; sum += i; &#125; printf(&quot;%d&quot;, sum);&#125; if 语句，while语句 后面只有一条语句时可以不加{}，但是函数体必须要用{}括起来。 sum是函数名，void英文单词是空虚的，顾名思义，就是函数不返回任何东西。sum后面跟的()是参数表，参数和参数之间用逗号分隔，即使函数不需要输入任何参数也要带()， 从函数中返回 return停止函数的执行，return有2种写法： return; return 表达式 //单一变量也是1个表达式 1个函数里面可以有多个return语句，也就是多个出口，但是最终只能返回1个值，但多个出口有个问题就是如果以后要修改，很可能要疲于奔命去修改，所以尽量做成单一出口。 函数返回的值， 我们可以把它赋给1个变量， 也可以把它当作另一个函数的参数放到()里 甚至可以直接调用，返回值丢掉，比如：function(a,b)，因为我们有时只是想要函数在执行本身产生的其它东西但不需要返回值。JAVA里的方法如果有return返回值，这个方法也可以直接调用，返回值不赋给任何变量，直接丢掉，也是没问题的 void 函数名(参数表) 这种不返回值得函数不能使用带值的return，可以是不带值的return; 或者直接不要return。但如果函数有返回类型则必须有返回值的return 可以不写return； 调用的时候不能做返回值的赋值； 如果函数名前面有返回类型，比如int double，**那就必须使用带值的return。**这一点和java一样 函数原型 C语言的编译器是自上而下顺序分析代码，看到main()函数里面的函数调用时，编译器需要知道函数需要输入几个参数，返回什么数，这样才能检查函数调用是否正确，所以函数定义要写在main()函数前面。 LLVM是一个检查严格的编译器，如果你把函数定义放在main()函数底下，会有warning和error。编译器在main()里碰见未被提前声明的函数会去猜那个函数长这样：int 函数名(int, int)，但是编译器继续往下执行一旦碰到后面的函数定义就会发现和前面猜的函数不一样，所以会给error。 但是我们又希望我们一打开这个程序就能看到main()函数，就能看到这个程序的大概，具体的函数定义这些细节我们想放在下面去看，怎么办？我们可以把函数头复制粘贴到main()前面并加上分号，这个叫函数的原型声明，函数定义放在main()下面， 1234567891011121314151617181920#include &lt;stdio.h&gt;void sum(int begin, int end); // 函数的原型声明int main()&#123; printf(&quot;123\\tA\\n&quot;); printf(&quot;12\\tA&quot;); return 0;&#125;// 函数定义void sum(int begin, int end) // 函数头&#123; // 函数体 大括号一定要带 int i; int sum; for (i = begin; i &lt; end; ++i) &#123; sum += i; &#125; printf(&quot;%d&quot;, sum);&#125; 声明不是函数，声明只是在编译器碰到main()之前告诉编译器说，这个函数长这样，有几个参数，参数都是什么类型，要返回什么数，编译器再在main()里碰到这个函数调用时就不自己猜了，而是根据函数原型声明。编译器读到下面的函数定义时，还会判断之前的函数声明和它的函数定义对不对得上，所以函数原型的目的有2： 当编译器在main()里碰见函数调用时，函数原型会告诉编译器这个函数的名称，函数的参数，函数返回的类型 碰到函数定义时，还会检查函数原型和定义能不能对得上。 参数传递 调用函数时，给的参数类型和函数定义的参数类型不匹配，则编译器会偷偷进行类型转换再传递给函数，但这可能不是你所期望的，所以这是C语言传统上最大的漏洞，后续的语言，C++/java 再这方面就很严格。 12345678910111213141516171819#include &lt;stdio.h&gt;void swap(int a, int b); // 函数的原型声明int main()&#123; int a=5; int b=6; swap(a,b); printf(&quot;a=%d,b=%d&quot;, a,b); return 0;&#125;// 函数定义void swap(int a, int b) // 函数头&#123; // 函数体 大括号一定要带 int t=a; a=b; b=t;&#125; 输出是 a=5,b=6，我们发现，这样的函数交换不了a和b的值，这是因为C语言在调用函数时，永远只能传值给函数，虽然函数里面的a和b和函数外面的a和b重名但没有任何关系，只是值一样。每个函数有它自己的变量空间，内部的参数也位于这个独立的空间中，和其它函数没有关系。在main()里头，swap()里面的a和b不存在。 有些教科书里面会说，函数原型和定义的参数表里面，叫形式参数，在函数调用里面我们给它的参数叫实际参数，形参和实参的概念来自于人类第一个高级编程语言FORTRAN，但现在我们一般把形参叫参数，实参叫值，因为C语言函数本质是传值而不是传参数。这一点和JAVA一样，JAVA里，全局变量(比如属性)，可以不赋值直接使用，比如属性不初始化，会默认给0或者null；但是局部变量必须赋值后才能使用。因为没有默认值，否则编译器会报错。 本地变量 函数每一次运行就会产生一个独立的变量空间(比如递归，每重复运行一次就开辟一块变量空间)，在这个变量空间的变量是这一次函数运行所独有的，我们称之为本地变量(局部变量)。函数结束运行，变量空间和它的本地变量消失不见。 定义在函数内部的变量都是本地变量，目前为止我们所学过的变量都是定义在函数内部的变量，参数表里的参数也是本地变量。 生存期：变量出现到消亡的一段时间。 作用域：在什么范围内可以访问这个变量。 对于本地变量而言，其生存期和作用域的答案是统一的，即大括号{}内————块。 本地变量是定义在块内的 它可以是定义在函数的块内； 它也可以是定义在语句的块内，譬如 if (a &lt; b){ int i=10; } printf(&quot;%d&quot;,a); 出了if语句的大括号，i就不存在了。 甚至可以随便拉一对大括号来定义变量 { int i=10; } printf(&quot;%d&quot;,a); 出了大括号，i就不存在了。 基于此，可以在一些程序代码中间平白无故地去添加一个{}，并在其中敲一些可以做当前输出的调试代码，来查看代码运行到此处各个变量什么的状态是什么样的，由于{}存在，所以里面都是本地变量，并不会给外面的变量造成影响， 程序进入这个块之前，其中的变量不存在，离开这个块，其中的变量就消失了。 块外面定义的变量在块里面依然有效，譬如： int a=1; { int i=10; } 或 { int a=10; { int i=1; // 外层的变量对内层就是可访问的 } } 如果在块里面定义一个和外面同名的变量，则编译器在块里面时，碰到块里面的同名变量后，同名变量会把外面变量覆盖掉，但碰到之前，即使是在块内也不会覆盖。出了块，块里面的变量就会消失。JAVA里也一样，java里全局变量在某个局部同名变量的作用域内也会被局部同名变量覆盖。需要注意的是，同一个作用域内不能定义两个同名变量，无论C还是JAVA。 本地变量不会被默认初始化，在 main 函数中定义的变量也一样，如果本地变量不初始化就使用它，它的值就是内存里面原来在的那个值，所以安全的做法是在第一次使用本地变量之前要初始化它。 几点说明: 在 main 函数中定义的变量也是局部变量，只能在 main 函数中使用；同时，main 函数中也不能使用其它函数中定义的变量。main 函数也是一个函数，与其它函数地位平等。 在所有函数外部定义的变量称为全局变量（Global Variable），它的作用域默认是整个程序，也就是所有的源文件，包括 .c 和 .h 文件。 123456789101112int a, b; //全局变量void func1()&#123; //TODO:&#125;float x,y; //全局变量int func2()&#123; //TODO:&#125;int main()&#123; //TODO: return 0;&#125; a、b、x、y 都是在函数外部定义的全局变量。C语言代码是从前往后依次执行的，由于 x、y 定义在函数 func1() 之后，所以在 func1() 内无效；而 a、b 定义在源程序的开头，所以在 func1()、func2() 和 main() 内都有效。 全局变量也有自己的作用域，定义在底下的全局变量，上面不能用； extern 关键字可以把变量的作用域扩展到其他文件。加一个static前缀，则其他文件不能用这个全局变量，只能在本文件用，加了extern也不行。 在函数返回类型前面加一个static前缀，也是只能本文件调用该函数，比如本文件的调试函数。 不建议过多地使用全局变量或者静态本地变量，参考丰田汽车的案子， C语言是一个模块化语言，是由各个功能单一的模块组成的，改一个，其他模块就不用跟着改。如果功能不单一。会让模块之间的耦合度增加，修改一个模块势必造成其他模块跟着修改，造成鲁棒性下降。在划分模块时要求模块的内聚性强，与其它的模块耦合性弱。这是一个原则。但是全局变量会造成模块之间的耦合增强，鲁棒性下降。 如果在函数中引入全局变量，并且把函数移动到另一个文件去，还要考虑把全局变量移过去。并且，即使移动过去了，若该全局变量和新文件中的某一个变量重名，会出问题。这就降低程序的可移植性和通用性。 会长期占用内存，内存浪费； 全局变量的值很容易变的不可控，不知哪个地方就给你改个值，最后你不知道它的值是从哪赋来的。会降低程序的清晰度。 CPU结构 运算器ALU 一组寄存器(PC、IR、PSW、DR、通用寄存器等) 控制器CU 中断系统 存储系统(速度依次递减) 寄存器(一级) cache(二级) Memory(三级) I/O(四级) C的存储类别 static 放全局变量，存储在内存中的静态存储区；比如static int i = 0; 加了这个前缀，在内存上的位置就不同；从分配开始，到程序运行结束，都不释放。静态局部变量只初始化一次，不初始化它，会自动初始化为0。 123456789101112#include &lt;stdio.h&gt;int main()&#123; for (int i = 0; i &lt; 3; ++i) &#123; auto int a = 1; static int b = 1; a++; b++; printf(&quot;a = %d\\nb = %d\\n&quot;, a, b);&#125; return 0;&#125; 输出： 123456a = 2b = 2a = 2b = 3a = 2b = 4 只在第一次进入循环时，b被初始化为1，后面的每一次循环，b都不在初始化为1，而是保留上次离开循环的值，但是a每进入一次循环都会被重新初始化为1 auto 一般放局部变量；定义局部变量可以确缺省Auto，比如 auto int i = 0; 一般都默认auto。 寄存器变量，把变量放在寄存器，这样速度就更快了。一组寄存器，有通用寄存器，专用寄存器，专用寄存器我们一般不能用，普通寄存器太少了，不能占多了，会影响整个系统的运行，所以一般不把变量定义在寄存器 全局的，也放在静态存储区；也可以用static声明，但没必要，因为已经放在静态存储区了。有stastic 全局变量，也有stastic 局部变量。静态本地变量就是特殊的全局变量。 函数庶事 当我们的函数定义时就确定不接收参数了，那我们写成 void 函数名(void)，还是写成 void 函数名() 呢？如果写成void 函数名()，则表示参数表要不要接收参数不知道，并不表示一定不接收参数，所以这样的函数原型声明了个寂寞，到了函数调用的时候，如果我们不小心传了参数，编译器会猜参数的类型是int，很可能给出的结果是错的，所以如果确定函数的参数表里没有东西，就用 void 函数名(void)。 另外函数参数表里如果有多个参数，要用逗号隔开，注意，这里的逗号仅仅是标点符号，不是逗号运算符。f(a,b)中的逗号是标点符号，传了2个值；f((a,b))中的逗号因为有()存在，所以是逗号运算符，最后只传了b一个值进去。 C语言不允许函数嵌套定义，允许在一个函数定义里面放另一个函数的声明，但不允许放另一个函数的body。这一点和java也类似，JAVA里的方法体里也不能再嵌套放另一个方法体。 return (表达式) 这么写也不错，表达式加个()也是表达式，但是这么写会有人误解这是一个函数，所以不要这么写。 好了，学了函数，我们突然想起来了一开始学C接触到的int main()，我们一直不知道它是干嘛的，现在越看它越像个函数，其实，它就是个函数。写出int main(void) 也没有问题。 main()函数虽然是我们写的代码当中第一个被执行的代码(C语言从main()函数开始执行)，但不是这个程序第一个运行的代码，在main()之前还运行了其它东西，这些东西为程序能成功运行而做准备，准备完后会来调用main()函数。所以main()结尾的 return 0，是有意义的，它要把这个0返回给调用它的地方，返回给一小段代码，那一小段代码会检查并报告给你的操作系统，报给Windows,报告给Unix。传统上，一个应用程序如果返回0则表示正常的运行结束，如果返回任何非0值则表示这个运行过程中出现错误。如果main 函数的最后没有写return 语句的话，C99 规定编译器要自动在生成的目标文件中(如exe 文件)加入return 0; ，表示程序正常退出。 Day 11 初试数组 我们之前做了这样一个程序，如何写一个程序计算用户输入的数字的平均数。代码见下： 12345678910111213141516#include &lt;stdio.h&gt;int main()&#123; //计算average int sum=0; int x=0; scanf(&quot;%d&quot;, &amp;x); int n=0; while (x != -1)&#123; sum += x; scanf(&quot;%d&quot;, &amp;x); n++; &#125; printf(&quot;average=%f&quot;, (sum*1.0)/n); return 0;&#125; 每输入一个数就加起来，这样我们不需要记录每一个数，但是如果问题改成，写一个程序计算用户输入的数字的平均数，并输出所有大于平均数的数，我们就不得不存下每一个输入的数，但是我们需要定义多少个int变量才能记录下每一个数，是不是觉得太麻烦了？所以引入新的数据类型——数组。数组顾名思义就是很多数的组合。 int number[100]; 定义了一个新的变量，这个变量是一个数组(不是int)，这个变量名字叫做number，这个数组里的每一个单元都是一个int，该数组大小是100即可以放100个int。 123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;int main()&#123; int x; double sum=0; int cnt=0; int number[100]; scanf(&quot;%d&quot;, &amp;x); while (x!=-1)&#123; number[cnt]=x; // &#123; printf(&quot;cnt=%d\\n&quot;, cnt); for (int i = 0; i &lt;= cnt ; ++i) &#123; printf(&quot;%d\\t&quot;, number[i]); &#125; printf(&quot;\\n&quot;); &#125; // sum++; cnt++; scanf(&quot;%d&quot;, &amp;x); &#125; if (cnt&gt;0)&#123; printf(&quot;%f&quot;, sum/cnt); for (int i = 0; i &lt; cnt; ++i) &#123; if (number[i]&gt;sum/cnt)&#123; printf(&quot;%d\\n&quot;, number[i]); &#125; &#125; &#125; return 0;&#125; 字符型数组是数组元素为char类型的一种数组。凡是适合数组的定义和赋值，也都适合于字符数组。由于C语言没有提供字符串类型(JAVA有String类型)，字符串一般用一维字符数组来存放，而二维字符数组可以存放多个字符串。 数组的使用 数组这样定义：&lt;类型&gt; 变量名称[元素数量]，类型是指元素的类型，必须有[]，没有方括号就是普通的变量。元素数量必须是整数。C99之前，元素数量必须是编译时确定的字面量，但C99以后就可以用变量来定义数组大小了，比如 int number[a] 但数组大小一旦确定下来大小就不能再变。 容器是一个放东西的东西，即容器。容器是现代编程语言中非常重要的一个基本概念，现代的编程语言都应该提供某种形式的容器。 数组就是一种容器，其特点是： 其中所有的元素具有相同的数据类型； 数组大小一旦确定就不能改变； 在内存里，数组的元素是紧密连续依次排列的； 数组不是C语言才有的，FORTRAN就有数组了，但是数组的索引从0开始编号是从C语言开始的，之所以这么干是因为希望当年C语言的编译器可以做的很简单，从0开始编译器可以省很多事情，从那以后，C-like语言都是从0开始索引。 C语言的编译器和运行环境都不会检查下标是否越界，无论是对数组单元读还是写。一旦数组越界，可以会导致程序崩溃，也可能无事发生，这也就是有时候在我的电脑上程序运行成功，在你的电脑上就不行了。有效下标就是0-(数组大小-1)，int a[0] 可以存在但无用。 数组和本地变量一样，不会被默认初始化，所以为了安全，一定要在使用它之前初始化它，初始化方法比较麻烦，写循环遍历每一个元素给它赋值。 数组运算 我们在定义数组时有2种方案： int number[a] 我们这种定义不能去初始化它，它也不会被默认初始化，所以后面我们想使用它还得写个循环去初始化它。 int a[]={1,2,2,4,5}; 这是第2种方案，叫数组的集成初始化，我们没有给数组的大小，我们让编译器替我们去数。如果改成：int a[10]={2}; 则数组的第一个元素为2，剩下9个元素均为0，所以我们使用 int a[10]={0}; 来初始化一个数组让其所有元素均为0，就不用再写循环初始化了。 另外我们还可以这样，int a[10]={[0]=2,[2]=3,6}; 这样的意思是创建一个10个元素的数组，索引为0的元素赋2，索引为2的元素赋为3，索引为4的元素赋为6，其余元素均为0，但这种方式仅C99以后才支持. a[0] (a是一个数组) 这就是一个变量，和正常的变量一样去使用它。 运算符 sizeof()，它可以给出某个类型或者某个变量在内存中占据的字节数,这个运算符也适合数组。 int a[10]; 则 sizeof(a)得到的是40，即一个int占4个字节，10个元素共占40个字节。这样的话，我们就可以用 sizeof(a)/sizeof(a[0]) 来表达数组a的元素个数，这么做的好处是一旦我们修改数组中初始的数据，我们不需要修改遍历的代码。 int a[10]={0}; int b[]=a; 数组变量不能直接这样赋值，讲指针的时候再细讲。所以如果想把一个数组的所有元素交给另一个数组则必须采用遍历，a[i]=b[i] 是可行的，这也是唯一一个把一个数组完全赋给另一个数组的方法，别无他法。 程序员在写循环时通常都是从0开始到 &lt; 某个数，很少能够看到 &lt;= ， 特别需要注意的是，数组作为函数参数时，我们往往需要另一个参数来传入数组的大小，为什么呢？因为数组一旦传入参数，我们便不能再用 sizeof() 来计算数组元素的个数了，至于为什么要到指针再扯。 int a[10]={0}; int cnt=0; a[cnt++]=i; 最后一句的意思是，我们把当前的i赋给cnt所在位置的元素，同时cnt本身+1，下一次的 a[cnt] 已经是下一个位置的元素，下一次再赋值自动的就是赋给下一个位置的元素。 二维数组 我们上面讲的都是一维数组，C语言除了做一维数组还能做二维三维更往上的。 二维数组通常理解为一个矩阵，对于二维数组的索引，C语言和线代里面对矩阵的索引是一样的，int a[3][5] 是指第3行第5列的元素。int a[3,5] 此时逗号是个运算符，即等价为 int a[5] ，所以这样写并不是一个正确的索引二维数组的方式。 二维数组也可以做集成初始化，例如： int a[][5]={ {0,1,2,3,4}, {5,6,7,8,9} }; 编译器只能数一维的个数，所以列数不能省，和一维数组一样，如果有省略的则补0。有些人用不带{}的一连串的数字也能定义二维数组，因为内存中就是这样存的，实际存储是一维的，线性的。二维数组是按行连续存放的，第一行存完，接着存下一行。 二维数组初始化： int a[3][3] = {1，2，3，4，5，6，7，9，5}; 编译器会根据列数去自动划分。 int a[][3] = {1，2，3，4，5，6，7，9，5}; 编译器会根据列数去自动划分行。 int a[3][3] ={ {1}, {5}, {9} }; 则等价于 int a[3][3] ={ {1, 0, 0}, {5, 0, 0}, {9, 0, 0} }; int a[3][3] ={ {1}, {5} }; 则等价于 int a[3][3] ={ {1, 0, 0}, {5, 0, 0}, {0, 0, 0} }; int a[3][3] ={ {1}, {}, {5} }; 则等价于 int a[3][3] ={ {1, 0, 0}, {0, 0, 0}, {5, 0, 0} }; int arr1[2][3] = {0}; /* 所有元素都初始化为0 */ int arr1[2][3] = {1}; /* 只有arr1[0][0]为1，其他所有元素都初始化为0 */ char b[10][5] = { //这是一个二维数组,所以第2个[]里的数不能省,编译器不会替我们去数. b[][5]是可以的, 但b[10][]不行 “ling”, “yi”, “er”, “san”, “si”, “wu”, “liu”, “qi”, “ba”, “jiu” &#125;; 二维字符型数组也可以这样初始化, 'ling'后面默认补个'\\0', 'yi'后面补仨这样, 输出的话直接,printf(&quot;%s&quot;, b[0]); 即可 char *b[] = { //这是一个一维数组,所以[]里面不用加数字,编译器会替我们去数. “ling”, “yi”, “er”, “san”, “si”, “wu”, “liu”, “qi”, “ba”, “jiu” &#125;; 这不是二维字符型数组,这是一个一维指针数组, 其中每一个指针指向 常量池的一个字符串.定义字符串有用数组定义和指针定义两种方式, 一个const在 * 号前,一个在 * 号后,上一种定义二维字符型数组,就是把字符串放在这里, 与数组名放在一起, 9这种方式就是把字符串放在常量池,这里只放指针. 输出的话也是直接,printf(&quot;%s&quot;, b[0]); 即可 取地址运算 scanf里面必须要加 &amp; ，否则运行会报错，&amp; 其实是C语言的一个运算符，它运算什么呢？它用来获得变量的地址，因此它的操作数必须是变量。&amp;(i++) &amp;(a+b)，这都会报错，必须是一个确定的变量才行。变量地址是什么？我们对变量的定义是：变量是保存数据的地方，C语言的变量是放在内存里的，比如定义一个 int 变量，它存在内存里并占用4个字节，它存在那个地方，那个地方就有个地址，所以 &amp; 运算符就是把变量的那个地址拿出来告诉你。 我们想看看这个地址长什么样，于是我们用这样的代码： 1234567891011#include &lt;stdio.h&gt;int main()&#123; int i=0; printf(&quot;0x%x\\n&quot;, &amp;i); printf(&quot;%p\\n&quot;, &amp;i); int p; p=(int)&amp;i; printf(&quot;0x%x\\n&quot;, p); return 0;&#125; 输出结果是： 1230xd99ffa98000000c2d99ffa980xd99ffa98 我们发现用 %p 和转成int型再用 %x 输出结果是一样的，这是因为我们用32位架构编译，如果我们换成64位架构再来一遍，则转成int输出和%p输出便不一样了，因为在64位架构下编译，int占4个字节，&amp;i占8个字节。但是在32位架构下编译，int占4个字节，&amp;i也占4个字节。所以这个变量的地址的大小，它的数据类型，和int是否相等，取决于编译器，取决于64位还是32位架构，地址和整数并不是永远相同的，所以我们要用printf输出一个地址，我们要用%p而不是当成int型输出。 scanf里面必须要加 &amp; ，否则运行会报错，但是我们调用scanf时忘记加&amp;，传入int型编译也能过，比如 int i=6; scanf(&quot;%d&quot;,i); 虽然编译不报错但是运行会报错，是因为在32位架构下，int和地址一样，scanf把你传入的int值当作了地址，所以编译不出错，之所以运行会报错是因为，向错误的地址6(i值而不是i的地址)写入了你输入的东西，6那个地方很小，那个地方有很重要的东西，不可能被写入。 123456789#include &lt;stdio.h&gt;int main()&#123; int i=0; int p; printf(&quot;%p\\n&quot;, &amp;i); printf(&quot;%p\\n&quot;, &amp;p); return 0;&#125; 输出是： 000000abc29ff6fc 000000abc29ff6f8 在十六进制中，上面两个地址之间差了4，而我们知道在32位架构下，int就是4个字节，因此我们得知，两个变量i和p在内存中存放的位置是挨着的，所以两个变量的地址之间相差了4个字节，但是我们注意到 i 是fc，p 是f8,也就是说i是先定义的变量但所储存的位置在后定义的p上面，i在更高的地方，这俩变量都是本地变量，它们分配在堆栈里(stack)，在stack里分配变量是自顶向下分配，所以先写的变量地址更高，但它俩是紧挨着的。 1234567891011#include &lt;stdio.h&gt;int main()&#123; int a[10]; printf(&quot;%p\\n&quot;, &amp;a); printf(&quot;%p\\n&quot;, a); printf(&quot;%p\\n&quot;, &amp;a[0]); printf(&quot;%p\\n&quot;, &amp;a[1]); printf(&quot;%p\\n&quot;, &amp;a[2]); return 0;&#125; 输出： 12345000000af869ffb90000000af869ffb90000000af869ffb90000000af869ffb94000000af869ffb98 我们直接拿数组a当作地址输出，编译是过的。我们做了一个数组，里面有10个int，从输出来看 &amp;a=a=&amp;a[0]，而&amp;a[2]和&amp;a[1]和&amp;a[0]之间逐步差4个字节。 指针 我们前面看到取地址符&amp;这么花，可以看到数组里面元素的地址怎么排列的等等，有什么用呢？我们想一想scanf()，它作为一个函数，需要在参数表里传入变量的地址，说明scanf内部有一个东西可以接收外部传入的地址并保存之。我们前面试过，如果你把一个地址交给一个整数，这个方法不靠谱，因为整数和地址不见得永远都是相同类型的，那么什么类型可以接收取地址运算得到的那个地址呢？答案是指针。一个指针类型的变量，就是用来保存地址的变量。我们通常用p来命名指针变量因为，p可以看作pointer的缩写， int* p = &amp;i int*表示后面的变量p是一个指针，且指向一个int变量。我们原本有个int型变量i，然后又定义一个指针变量p，假设i放在0x2000的地方，则通过上面的表达式，p的值就被赋为0x2000，此时我们称这种情况为：p指向i。所以当我们在说p指向i时，我们实际的意思就是p的值是i那个变量的地址。 int* p,q; int *p,q; 这两行是等价的，都表示p是一个指针指向一个int，q是一个普通的int型变量。所以实际上，*是加给p，p才成为指针的，而不是加在int上的。不管 * 靠近p还是靠近int，我们说 *p 是指向一个int于是p成为一个指针，而不是说p是 int * 这种类型。如果想表达p和q都是指向int的指针，则应该按下面表达： int * p,* q 当然，千万别解引用未初始化的指针，否则会引起严重错误。 普通的变量，放的内容就是实际的值，但指针变量里不会放实际的值，我们只会放别的变量的地址，int* p，里面只会有别的int型变量的地址。 当我们想往函数里传入&amp;i的值时，我们在参数表里只能用指针类型接收，而不能用int型接收，因为不同架构下，地址不一定等于int。 当参数表里需要指针作为参数时，e.g. void f(int* p); 当我们调用这个函数时，我们要交给它一个地址，比如&amp;i，而非变量，这就意味着在函数里面我们便可以掌握外层变量的地址，我们如果只往函数里传普通变量，则函数只能掌握外层变量的值，和外层变量没什么关系了，所以通过传外层变量的地址进函数，就使函数拥有访问外层变量的能力了，访问意味着读和写。*时一个单目运算符，用来访问指针的值所表示的地址上的变量， *p可以做左值也可以做右值， 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;void f(int *p);void g(int k);int main()&#123; int i=6; printf(&quot;&amp;i=%p\\n&quot;, &amp;i); //不能调用g()，因为g()不能接收&amp;i f(&amp;i); g(i); return 0;&#125;void f(int *p)&#123; printf(&quot;p=%p\\n&quot;, p); printf(&quot;*p=%p\\n&quot;, *p); *p=26;&#125;void g(int k)&#123; printf(&quot;%d\\n&quot;, k);&#125; 输出： &amp;i=0000001a671ff71c p=0000001a671ff71c *p=0000000000000006 26 C语言函数调用时发生的永远是值的传递，虽然能通过指针改外层的变量，但是依然是传递的地址的值。 赋值号左边的叫左值，之所以不叫变量，那是因为赋值号左边的那一坨，是表达式计算的结果，而不是变量，比如： a[0]=2; *p=3; *是个运算符， *p表示我要取得p上面存的地址所代表的那个变量，所以这是一个表达式运算结果，数组的那个[]，也是一个运算符，取里面元素的一个运算符，所以a [0]不是变量， *p也不是变量，他们是表达式运算的结果，它本质上是值，所以叫左值。同理，出现在赋值号右边的叫右值。 *和&amp;是一对相互反作用的运算符。比如 ： 12345int a, b;int *p, *p1;p = &amp;a;b = *(&amp;a); // 等价于 b = ap1 = &amp;(*p); //等价于 p1 = p 因此我们可以看到这是互逆的一对运算符； 用变量名直接方法叫直接访问；用指针去访问叫间接访问；* 号又叫间接访问运算符。在定义指针的时候加 * 号，并不会间接访问它指向的变量，在后面加 * 号才会表现出间接访问的功能。 指针变量不能直接赋值，比如： int *ptr; ptr = 0x111111 必然是错误的 只有在强制转换右值为指针所声明类型后才能赋值，如ptr = (int *)0x111111 如果是char *ptr，赋值的时候注意用ptr = (char *)0x111111就好了。 指针的使用 讲了那么多指针，有什么用呢？ 指针应用场景一： 还记得之前我们写的swap()函数吗，我们企图写个函数能交换两个变量的值，但是发现函数永远只能传值，不能改变外面的变量的值，所以失败了，但现在我们能用指针去实现。 1234567891011121314151617#include &lt;stdio.h&gt;void swap(int *pa, int *pb);int main()&#123; int a=1; int b=2; swap(&amp;a,&amp;b); printf(&quot;a=%d, b=%d&quot;, a,b); return 0;&#125;void swap(int *pa, int *pb)&#123; int t=*pa; *pa=*pb; *pb=t;&#125; 指针应用场景二： 我们前面学到，C语言函数不像python函数可以返回多个值，C语言函数最多return 1个值或者不返回值。我们如果想用C语言函数返回2个或2个以上的值，可以用指针做到。JAVA里面一个方法也是最多返回一个值，JAVA里面如果想返回多个值，可以返回一个数组，一个List等。其实python函数表面上可以返回多个值，本质上也是最多返回一个值，只不过利用了tuple的自动打包，将多个值打包成单个tuple返回。 指针应用场景三： 函数返回运算的状态，结果通过指针返回。 函数在运算中可能会出错，常用的套路是让函数返回特殊的不属于有效范围内的值来表示出错。在C语言的标准库里，和文件相关的操作我们会看到大量的例子：这些函数要么返回-1，要么返回0，用来表示说这些操作没成功，但是如果你构造的函数，返回任何数值都是有效的结果，都表示函数成功运行下来了，那么就没办法通过返回值来表达运行是否出问题了，此时需要分开返回，往往采用运行状态用return返回，需要返回的值通过指针来返回。在C我们只能用这种方式来做，但是在后续语言比如C++、Java，可以通过异常的机制来解决这样的问题。 指针应用场景四： 需要传入较大数据时，比如向函数传数组，可以传指针节省空间和时间。 指针应用场景五： 需要动态申请内存时。 使用指针最常见的错误是，定义了指针变量，还没有指向任何变量，就开始使用指针。例如： int *p; int k=12; *p=12; 所有的本地变量都不会有默认的初始值，所以p里面现在是一些乱七八糟的值，可能会指向一片莫名其妙的地方，所以再说 *p=12 时是在说向那片莫名其妙的地方写入12，那个地方侥幸可以被写入就不会出错。那个地方如果是个不能被写入的地方，那程序就会崩溃， 指针与数组 数组是具有相同类型的结合。 字符型数组在计算机内部用其对应的ASCII码值进行存储。 一般用&quot;&quot;引起的字符串，不用数组保存时，一般都被直接编译到字符常量区，并且不可被修改，这一点和JAVA的String类一样 int a[5]; 我们前面已经知道，对于数组a，有 &amp;a=a=&amp;a[0] ，数组名 a 一般情况下代表数组首元素的地址(除非是sizeof(a)等特殊情况)，即 &amp;a[0]==a，而整个数组的地址需要取地址运算符&amp;才能得到，为 &amp;a 。数组名和数组首元素地址一般情况下可以视为相同，但是，数组的地址虽然和前面两个数值上相同，但概念不同，代表的不是同一个东西，&amp;a 代表整个数组在内存中的地址。a 与 &amp;a 的步长不一样，a代表的是数组首元素的地址，也是数组的首地址，a加1等价于加一个数组元素类型的长度；&amp;a代表的是整个数组的地址，加1等价于加整个数组的长度。首地址+1得到的是跳过整个数组的地址，首元素地址+1得到的是下一个元素的地址。 下面的几行代码可以清楚地看出数组名就是该数组首元素的地址。 1234567891011121314151617181920212223242526272829303132333435363738394041int main()&#123; int a[5] = &#123;1, 2, 3, 4, 5&#125;; int *p = &amp;a[0]; printf(&quot;%p\\n&quot;, a); printf(&quot;%p\\n&quot;, a + 0); printf(&quot;%p\\n&quot;, a + 1); printf(&quot;%p\\n&quot;, a + 2); printf(&quot;%p\\n&quot;, a + 3); printf(&quot;%p\\n&quot;, a + 4); printf(&quot;\\n&quot;); printf(&quot;%p\\n&quot;, p); printf(&quot;%p\\n&quot;, p + 0); printf(&quot;%p\\n&quot;, p + 1); printf(&quot;%p\\n&quot;, p + 2); printf(&quot;%p\\n&quot;, p + 3); printf(&quot;%p\\n&quot;, p + 4); printf(&quot;\\n&quot;); printf(&quot;%d\\n&quot;, *a); printf(&quot;%d\\n&quot;, *(a + 0)); printf(&quot;%d\\n&quot;, *(a + 1)); printf(&quot;%d\\n&quot;, *(a + 2)); printf(&quot;%d\\n&quot;, *(a + 3)); printf(&quot;%d\\n&quot;, *(a + 4)); printf(&quot;\\n&quot;); printf(&quot;%d\\n&quot;, *p); printf(&quot;%d\\n&quot;, *(p + 0)); printf(&quot;%d\\n&quot;, *(p + 1)); printf(&quot;%d\\n&quot;, *(p + 2)); printf(&quot;%d\\n&quot;, *(p + 3)); printf(&quot;%d\\n&quot;, *(p + 4)); return 0;&#125; 输出： 1234567891011121314151617181920212223242526270000003c957ff7800000003c957ff7800000003c957ff7840000003c957ff7880000003c957ff78c0000003c957ff7900000003c957ff7800000003c957ff7800000003c957ff7840000003c957ff7880000003c957ff78c0000003c957ff790112345112345 但是万万不可做 a++ 或者 a += 1；这种游戏，因为数组名是const指针，不可被改变。 a[n] 本质上就是 *(a + n) 数组名一般可以看作一个常量指针，即决定了在表达式中数组名只能作为右值使用。但数组名始终不是指针。 只有在下面2种场合中数组名不能看作常量指针： 数组名作为sizeof()操作符的参数时，得到的是整个数组在内存中占用的空间。 数组名作为&amp;运算符的参数。 以上两种情况，a 被看作整个数组(整个连续的空间)，而非数组名。 所以我们之前说： int a[10]={0}; int b[]; int p=a; b=a; b=a之所以不行，就是因为数组名 b 是一个const指针，即b创建出来代表这个数组，就不能被改变了。因此赋值号左边永远不可能是已经固定了长度的数组，只能使用int。int *p=a; 正常的指针还是可以被赋予数组名的。 数组名不包含数组的长度信息。 我们都知道，C语言函数永远传的是值，那么我们把一维数组传到函数里，那函数接收到的是什么东西？答案是，函数会接收到一个整型指针。其中的原因多数教科书都有做解释。因为数组占用的空间往往很大，如果要拷贝赋值到形参中，每次调用函数都需要很长时间做传参拷贝，因此C语言做了妥协，只传递数组的首元素地址给形参。可见，func(arr)和func(&amp;arr[0])是等价的。对于形参声明，int a[]和int* a也是等价的，只不过int a[]的写法更容易让人看出是个数组。此外，若写int a[5]，这里的5也没用，哪怕写100也没用，都与int*a等价，因为编译器只传递了首地址，它会无视这里的长度。因此数组作为函数参数时，我们往往需要另一个参数来传入数组的大小，数组一旦传入参数，我们便不能再用 sizeof() 来计算数组元素的个数了，现在我们知道了原因，因为传入数组的是数组名也就是数组首元素的地址也就是一个常量指针，sizeof()出来的是一个地址的大小是一个指针的大小而不是整个数组的大小。 所以如果您想要在函数中传递一个一维数组作为参数，您必须以下面三种方式来声明函数形式参数，这三种声明方式的结果是一样的，因为每种方式都会告诉编译器将要接收一个整型指针。 void function(int *arr) void function(int a[]) // 使用方括号 [] 声明函数数组参数的一个优点就是可读性好，它可以显著地标识出函数将该参数作为指向数组的指针。 void function(int a[5]) // 当使用数组来声明函数参数时，方括号 [] 内的任何常量表达式都会被忽略。就函数而言，数组的长度是无关紧要的，因为 C 不会对形式参数执行边界检查。也就是a[5] 中的5，改成6改成7随便改成其它正整数都可以。这个[]括号仅仅比表明这是一个指针。 我们在函数外定义一个数组： int a[10]; 然后在底下写个函数： void function(int a[]); { a[0]=1000; } 再将a数组传给函数，则我们发现在函数里面改函数的元素的值，对函数外面的a生效，这与我们前面了解到的普通变量不一样，我们很容易想到，数组传给函数，传进去的其实是个地址，接收这个地址的是个指针，就等价于：把 &amp;a 传给： void function(int *a); { a[0]=1000; } 但是我们疑惑的是，根据我们之前学的int型变量的指针传入函数，不应该是这样才能在函数体里操纵指针来改外面的值吗？ void function(int *a); { *a[0]=1000; // 我们想用 *a来表示外面的那个数组，现在为什么不加 * 号就行？ } 原因是 [] 这个运算符可以对数组做也可以对指针做，就是这么规定的，不加 * 就可以这么干。而 *a，是数组 a 的首元素。 int min=1000; int *p= &amp; min; printf(&quot;%d&quot;, *p); printf(&quot;%d&quot;, p[0]); 输出都是1000，因此我们得知，p[0]实际上就是相当于 p[0]，就是(p + 0)，在有[]出现时， * 可以省略，只是把它所指的地方当作一个长度为1的数组。 至于多维数组和指针，看懂下面的判断题就基本搞定了，详见《C Primer Plus (第6版)》第10章10.7，指针和多维数组。 123456789101112131415int arr[5] = &#123;0&#125;;int *p3 = &amp;arr; // 错int (*p2)[5] = arr; // 错int (*p1)[5] = &amp;arr; // 对int zippo[4][2] = &#123;0&#125;;int (*pointer1)[2] = &amp;zippo[0]; // 对int (*pointer7)[2] = zippo; // 对 zippo是个基类型为一维数组的指针，把它赋给另一个指针pointer7，很合理int (*pointer2)[3] = &amp;zippo[0]; // 错int (*pointer3)[2] = &amp;zippo[0][0]; // 错int *pointer4 = &amp;zippo[0][0]; // 对int (*pointer5)[2] = &amp;zippo; // 错int (*pointer6)[4][2] = &amp;zippo; // 对int (*pointer8)[2] = zippo; // 对 指针与const 下面说的仅适用于C99. int * const q = &amp;i ; 意思是q里面的值不能再变，即q指向i的内存那块地，这个关系不能再变， *q = 26 OK q++ 因为q时const，不能变。 const int p = &amp;i ; 此时，i的值可以变，p的值也可以变，不能变的是，不能通过p去改变i的值， i = 26; OK p = &amp;j ; OK *p = 26; 不可以 int i; const int* p1 = &amp;i ; int const* p2 = &amp;i ; int const p3 = &amp;i ; 判断那个被const了的标准是const在的前面还是后面，所以前两个是等价的，即不能通过 *p修改i的值。最后一个表示指针p的值不能被修改。 我们可以借助const指针这个特性，去做一些方便的事情，比如把一个非const的值转成const，比如下面这些代码： 123void f(const int* x);int a = 15;f(&amp;a); 这样的话就可以确保这个函数f不会对外面的a值作出修改。当传递的参数类型比地址大时，这是常用的手段，既能用较少的字节数传递值给参数，又能避免函数对外面的变量进行修改。 既然数组已经是一个const指针了，已经是 *const数组名 了，不能再指向别的内存了，那么 * 号前面再加一个const是什么意思呢？ const int a[] = {1,2,3,4,5}; 意味着这个数组里面所有的元素都是const，都不能再改变了。 指针运算 对于四则运算，a+1就是比a多了1而已，但是对于指针运算不是如此。 12345678910111213#include &lt;stdio.h&gt;int main()&#123; char ac[] = &#123;0, 1, 2, 3, 4, 5, 6, 7,8, 9&#125;; char *p = ac; printf(&quot;p=%p\\n&quot;, p); printf(&quot;p+1=%p\\n&quot;, p + 1); int ai[] = &#123;0, 1, 2, 3, 4, 5, 6, 7,8, 9&#125;; int *q = ai; printf(&quot;q=%p\\n&quot;, q); printf(&quot;q+1=%p\\n&quot;, q + 1); return 0;&#125; 输出： 1234p=0000009ff63ffbe6p+1=0000009ff63ffbe7q=0000009ff63ffbb0q+1=0000009ff63ffbb4 sizeof(char)=1,sizeof(int)=4,可见，指针+1，不是真的加1，而是在地址值上加一个sizeof(该指针所指的类型)，加了4个字节。对指针做一个+1的动作，意味着，指到下一个单元去。如果真的让地址+1，比如让q=0000009ff63ffbb0+1=0000009ff63ffbb1，那对int数组就没有什么意义了。 另外，如果指针不是指向一片连续分配的空间，如数组，那么这种运算也是没有意义的。 在上面的代码中，*p 等价于 ac[0], *(p+1)等价于ac[1], *是单目运算符，优先级高，即， *(p+n)等价于ac[n]。 不仅+可以，-也可以。++或–也行。也可以做比较，就是地址的大小比较。但是没有乘除，指针做乘除没有意义 数组名不能++，因为数组名是一个常量指针，不能变。 在上面那段代码后面加上这段： 12345char *p1 = &amp;ac[5];printf(&quot;p1-p=%d&quot;, p1-p);int *q1=&amp;ai[6];printf(&quot;q1=%p&quot;, q1);printf(&quot;q1-q=%d&quot;, q1-q); 输出： 123p1-p=5q1=0000008b949ffac8q1-q=6 q1-q=6，而q1的值和q的值差24，一个int型又是4字节，因此，指针之间的减法减出来的是中间差几个元素。如果 p 和 q1 不是指向同一个数组，那么这样相减是没有意义的。 *p++ ,的运算符优先级和 * 同级，但是是自右向左，所以后面不用带()，但是加括号更易读。p的结果是以前的结果，先做p，再由 * 取出p++ 的值，也就是说，取出p所指的那个暑数据来，完事顺便把p移到下一个位置去，常用于数组这样连续空间的遍历操作，以前我们想遍历数组，往往使用for循环，现在我们可以用这个技巧来遍历数组。 其实 *p++ ，在最开始的CPU上可以直接被翻译成一条汇编指令，这样跑得快，后续的很多CPU延续了这种，但是现在也有些CPU没有延续这种指令，遇到这种机器， *p++就不会跑得特别快。 使用 *p++ 时特别要注意， 123while (*p != 6)&#123; printf(&quot;%d\\t%.0f\\t%.0f\\t\\n&quot;, *p++, pow(*p++, 2), pow(*p++, 3)); &#125; 我们想让p在下次循环是+1，但在块里p实际上加了3次，不要这么干，很蠢。应该是： 123while (*p != 6)&#123; printf(&quot;%d\\t%.0f\\t%.0f\\t\\n&quot;, *p++, pow(*p, 2), pow(*p, 3)); &#125; 123456789101112131415#include &lt;stdio.h&gt;int main()&#123; int a[10] = &#123;0&#125;; int i, j; for (i = 0; i &lt; 10; ++i) &#123; scanf(&quot;%d&quot;, &amp;a[i]); &#125; int *p = &amp;a[9]; for (i = 0; i &lt; 10; ++i) &#123; printf(&quot;%d &quot;, *p--); // i = 9 这个循环做完以后，p已经减出数组的地址范围了，只不过此时p--还是a[0]的地址。 &#125; return 0;&#125; 0地址： 现代OS都是多进程的OS，基本管理单元都是进程，对于一个进程，OS会给它一个虚拟的地址空间，也就是说所有的程序在运行时都以为自己拥有一片从0地址开始的一片连续的空间，如果是32位的机器，顶就是4G。通常0地址是不能乱碰的，也就是说你的指针不应该具有0值，因此可以借助0地址碰不得这个特性来做一些事情，比如让返回的指针等于0，程序就会崩溃，借此来提示我们程序有错。 NULL大小写敏感，是C语言预定义的一个符号，表示0地址，所以我们以后用到0地址时，用NULL即可，有的编译器不喜欢你用0来表示0地址。 无论指向什么类型，指针的大小都是相同的，因为都是地址。但是指向不同类型的指针是不能相互赋值的，虽然这个值是能放得下去的，如果强行这样做，比如还是上面代码举例，q=p，但是q是指向int型的指针，现在指向了一个char数组，它会把char数组当作int数组，如果我们用 *q = 0; 则char数组前四个元素都会变成0，所以为了规避用错指针，指向不同类型的指针之间不能互相赋值。 我们印象中C语言的指针都有类型，实际上也存在一种例外。这里涉及到通用指针，它可以指向任何类型的变量。通用指针的类型用（void *）表示，因此也称为void 指针。 void* 表示不知道指向什么东西的指针，计算规则与char* 相同，但是不相通，也就是不能混合去用。 指针也能强制类型转换， int* p=%i; void* q=(void*)p; 第二句的意思就是：p还是指向int，但是我们通过q去看向i，q现在不拿i当int了，拿i那片内存上的值当void了，当它什么都不是了。 动态内存分配 数组长度一旦确定下来，就不能变了。C99可以用变量做数组定义的大小，这样我们刚定义数组的时候就没必要搞清它的长度。那C99之前呢？比如C语言二级考试，人们那时必须使用动态内存分配，调用malloc() 必须include &lt;stdlib.h&gt;，返回类型是void*，void* 即我有一个指针，指向一块内存，但是我也不知道那块内存上的类型是什么。 C99可以这么干： 123456789#include &lt;stdio.h&gt;int main()&#123; int number; scanf(&quot;%d&quot;, &amp;number); int a[number]; return 0;&#125; C99以前只能这么干： 12345678910111213#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; int number; int *a; // C99以前定义变量只能去头部定义 scanf(&quot;%d&quot;, &amp;number); a = (int *) malloc(number * sizeof(int)); //number就是数组的大小 // 之所以能将malloc的结果赋给 a，是因为malloc函数本来返回的就是一个void*，强制类型转换一下。 // 剩下的，a就能直接当数组去用了，什么a[10]……因为数组名就是一个常量指针 free(a); return 0;&#125; 在计算机看来，它才不care这片内存上存的是int还是double，它只知道那是一片连续的空间。 如果系统给我们的内存空间用完了，再去mallcoc()的时候，就会返回0或者NULL。 free()是和malloc()配套的一个函数。切记malloc()后，要free()，有借有还，再借不难。在还的时候，只能还申请来的空间的原始首地址，不能申请来了以后做指针运算，比如a++，最后free的时候也不管三七二十一，直接free(a)，这样程序会异常终止。或者不管p的地址是不是malloc得来的，比如让指针去指向一个int变量，然后去free§，也会终止程序。就是人家会记住你借走的原地址，所以还也要还原地址。但是，free(NULL)没问题，因为反正0地址是你不可能malloc()得到的地址，所以在free函数里面先判断，如果传进去的是个NULL，那就不做事情了。可是，有什么必要要去做这样的事情呢？因为有一个良好的习惯，定义一个指针，就初始化它为0，所以为了配合这种好习惯，就做出了这样一个机制，就在free()的函数定义里面，先做判断是不是NULL，即使是NULL，也不让它出错。如果因为一些原因，你没有去malloc§，(此时p因为初始化过，所以是NULL)就free§，这样不会出现问题. 指针初始化为0或NULL，表示其目前还未指向任何对象，就是说：不存放任何变量的内存地址。NULL 是一个在 stdio.h 中定义为零值的宏 double * pd=NULL; /* 等价于 pd=0 */ 空指针是一个特殊的指针值，也是唯一一个对任何指针类型都合法的指针值。指针变量具有空指针值，表示它当时处于闲置状态，没有指向有意义的东西。空指针用 0 表示，C语言保证这个值不会是任何对象的地址。给指针值赋零则使它不再指向任何有意义的东西。为了提高程序的可读性，标准库定义了一个与 0 等价的符号常量NULL。程序里可以写 p = 0; 或者 p = NULL; 两种写法都把p置为空指针值。相对而言，前一种写法更容易使读程序的人意识到这里是一个指针赋值。 如果malloc()以后不free()，就走掉了，就会留下内存漏洞，或者叫内存垃圾。但这不会对任何人造成伤害，因为，程序结束后，OS有机制会保证，曾经用过的内存会全部清楚干净，所以留下没有free的内存对于小程序来说没有问题，因为有OS擦屁股。但是做大程序就会遭殃，比如一个服务器程序，它一直在运行，那么malloc()不free()，就很容易把内存用完。 野指针，也就是指向不可用内存区域的指针。通常对这种指针进行操作的话，将会使程序发生不可预知的错误。 “野指针”不是NULL指针，是指向“垃圾”内存的指针。 如果程序定义了一个指针，就必须要立即让它指向一个我们设定的空间或者把它设为NULL，如果没有这么做，那么这个指针里的内容是不可预知的，即不知道它指向内存中的哪个空间（即野指针），它有可能指向的是一个空白的内存区域，可能指向的是已经受保护的区域，甚至可能指向系统的关键内存，如果是那样就糟了，也许我们后面不小心对指针进行操作就有可能让系统出现紊乱，死机了。所以我们必须设定一个空间让指针指向它，或者把指针设为NULL， 还应该注意的是，free和delete只是把指针所指的内存给释放掉，但并没有把指针本身干掉。指针p被free以后其地址仍然不变（非NULL），只是该地址对应的内存是垃圾，p成了“野指针”。如果此时不把p设置为NULL，会让人误以为p是个合法的指针。用free或delete释放了内存之后，就应立即将指针设置为NULL，防止产生“野指针”。内存被释放了，并不表示指针会消亡或者成了NULL指针（而且指针消亡了，也并不表示它所指的内存会被自动释放） 动态内存分配中， malloc()获得的指针，要判断一下是否为NULL，来检测是否malloc成功，因为malloc可能申请内存失败(内存有可能不够)，比如 if (p = (int *)malloc(4 * 100)){} malloc()获得的指针默认是 void * 类型，如果不强制转成 int * ,则 p++ 一次跳1个字节，如果强制转成 double * 则一次跳8个字节。 函数指针 先问一下,函数是怎么被调用的? 一个C语言程序的执行过程可以认为是多个函数之间的相互调用过程，它们形成了一个或简单或复杂的调用链条。这个链条的起点是 main()，终点也是 main()。当 main() 调用完了所有的函数，它会返回一个值（例如return 0;）来结束自己的生命，从而结束整个程序。 当主调函数遇到被调函数时，主调函数会暂停，CPU 转而执行被调函数的代码；被调函数执行完毕后再返回主调函数，主调函数根据刚才的状态继续往下执行。 函数是一个可以重复使用的代码块，CPU 会一条一条地挨着执行其中的代码，当遇到函数调用时，CPU 首先要记录下当前代码块中下一条代码的地址（假设地址为 0X1000），然后跳转到另外一个代码块，执行完毕后再回来继续执行 0X1000 处的代码。整个过程相当于 CPU 开了一个小差，暂时放下手中的工作去做点别的事情，做完了再继续刚才的工作。 从上面的分析可以推断出，在所有函数之外进行加减乘除运算、使用 if…else 语句、调用一个函数等都是没有意义的，这些代码位于整个函数调用链条之外，永远都不会被执行到。C语言也禁止出现这种情况，会报语法错误. 如果在程序中定义一个函数,在编译时会把函数的源代码转换为可执行代码,并为其分配一段存储空间,这段内存空间有一个起始地址,也称函数的入口地址,每次调用函数时都从该地址入口开始执行此函数代码. 函数名就是函数的指针,它代表函数的起始地址. 可以定义一个指向函数的指针变量，用于存放某一函数的起始地址，这就意味着该指针变量指向该函数，例如： 1int (*p)(int, int); p是一个指向函数的指针变量，它可以指向一个返回类型为整型，且形参是两个int型的函数。因为()的优先级比 * 高，所以必须给 *p 加括号，否则p会先和后面的(int, int)结合，这就变成函数p的声明了。 指向函数的指针，不能随便指，只能指向在定义时指定的类型的函数 在给函数指针赋值时，只需给出函数名即可，因为函数名也是函数指针。 在用函数指针调用函数时，只需将 (* p) 代替函数名即可，p为指针变量名，在 (* p) 后面需要写上实参。注意得加 * 号。 对于指向函数的指针进行自加自减等指针运算是毫无意义的， 函数指针和多维数组的指针定义方式，在于(* p)后面的是[]还是()，int (* p)[4] 和 int (* p)(int); 其实函数指针和PHP里面的可变函数比较像，但是在C里面用的不多。 Day 12 字符串 char word[] = {‘H’,‘e’,‘l’,‘l’,‘o’,’!’}，这不是C语言的字符串，因为不能用字符串的方式去做计算，只是一个字符数组。如果要定义一个C语言的字符串，需要在字符数组的最后一位加上 ‘\\0’，’\\0’就是表示0，就是表示整数值的0，也可也把单引号去掉，把\\去掉，就放一个0，也一样的意思，但是一般还是用’\\0’，因为’\\0’一定只占1个字节，0可能是个int，占4个字节。一定不要用’0’，这是个字符，内部用ASCII码值48。 因为有这个0，也就使得该字符数组变成了可以参与字符串运算的字符串。 这个0标志字符串的结束，但它不是字符串的一部分，计算字符串长度的时候不包括0。为什么要加0，是因为后面很多C语言的字符串函数需要这个0来表示字符串结束。 C语言字符串在内存中存在的形式，就是数组。访问的形式可以是数组也可以是指针。 C语言中用单引号引起的，表示一个char类型，即表示字符类型常量，当在单引号中出现两个及以上字符时或没有字符时，编译出错。双引号引起表示一个字符串常量，可以表示0到多个字符组成的字符串。 字符常量使用单引号，字符串常量使用双引号表示； 两者均支持转义字符表示； ‘A’ 表示单个字符大写字母A，占用1个字节空间 “A” 表示字符串，该字符串只有1个大写字母A组成，占用2个字节空间，每个字符串末尾自动会加上一个空字符 ‘\\0’ 空字符常量使用转义符号 '\\0’表示，空白字符串使用双引号表示 “”，单引号中不能没有东西。 char buffer[] = “”; 这个数组的长度只有1 char buffer[100] = “”;则buffer[] = ‘\\0’ C语言中的单引号和双引号含义迥异，用单引号引起的一个字符实际上代表一个整数，整数值对应于该字符在编译器采用的字符集中的序列值，因此，采用ASCII字符集的编译器而言，‘a’的含义与0141或97严格一致。 而用双引号引起的字符串，代表的却是一个指向无名数组起始字符的指针，该无名数组被双引号之间的字符以及一个额外的二进制值为零的字符‘\\0’初始化。比如“Hello”，这个字符串字面量，编译器看到它，会把它变成一个字符数组(无名数组)，并在末尾替你加上一个’\\0’，并把它放在某个地方。 要定义字符串变量可以有以下3种形式： char* str = “Hello” 这种形式的意思是有个叫str的指针，它指向一个字符数组，字符数组里面放的内容是&quot;Hello&quot;。双引号引起的字符串，代表的本来就是一个指向无名数组起始字符的指针，相当于把这个指向无名字符数组的指针赋给str。 char word[] = “Hello”,这种形式就是我自己就定义了一个字符数组，这个数组就在这，我给它初始化了。 char line[10] = “Helllo”，和第2个差不多，只不过定义这个字符数组时给了10个字节，然后“Hello”在这里占据6个字节，编译器会自动生成一个结尾的’\\0’，并且，剩下的空位都会自动补’\\0’ 注意: char c[] = {“I am”}; 等价于 char c[] = {‘I’, ’ ', ‘a’, ‘m’}; char c[] = “I am”; 等价于 char c[] = {‘I’, ’ ', ‘a’, ‘m’, ‘\\0’}; char b[10][5] = { //这是一个二维字符数组,所以第2个[]里的数字不能省,编译器不会替我们去数. b[][5]是可以的, 但b[10][]不行 “ling”, “yi”, “er”, “san”, “si”, “wu”, “liu”, “qi”, “ba”, “jiu” &#125;; 二维字符型数组也可以这样初始化, 'ling'后面默认补个'\\0', 'yi'后面补仨这样, 输出的话直接,printf(&quot;%s&quot;, b[0]); 即可 char *b[] = { //这是一个一维数组,所以[]里面不用加数字,编译器会替我们去数. “ling”, “yi”, “er”, “san”, “si”, “wu”, “liu”, “qi”, “ba”, “jiu” &#125;; 这不是二维字符型数组,这是一个一维指针数组, 其中每一个指针指向常量池的一个字符串.定义字符串有用数组定义和指针定义两种方式, 一个const在 * 号前,一个在 * 号后,上一种定义二维字符型数组,就是把字符串放在这里, 与数组名放在一起, 这一种方式就是把字符串放在常量池,这里只放指针. 输出的话也是直接,printf(&quot;%s&quot;, b[0]); 即可 C语言中，如果有2个相邻的字符串，中间没有任何其它东西，编译器会自动把两个字符串连接起来成为1个字符串。 C语言的字符串，是以字符数组的形式存在的，所以： 不能用加减乘除这样的运算符对字符串做运算，后来的语言，比如JAVA，比如python,比如php，提供一些简单的运算符处理字符串。C语言出现在上世纪70年代的早期，那时计算机更多的是做数值运算，80 年代才更多地去做信息处理，信息处理和数值运算最大的不同就是前者处理的是文字，后者处理的是数字。所以新的语言会更关注处理文字也就是处理字符串的能力。 字符串唯一特殊的地方就是字符串字面量可以用来初始字符数组。这是C语言唯一表现它懂字符串的地方。 字符串常量 我们定义一个字符串常量。并让指针s指向它，我们有： 123456789#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; char *s = &quot;Hello World&quot;; s[0] = &#x27;B&#x27;; printf(&quot;Here!s[0]=%c\\n&quot;, s[0]); return 0;&#125; 编译能过，但是运行会报错。这是为什么呢？我们想看看这个无名数组存在哪了，于是我们写： 12345678910111213#include &lt;stdio.h&gt;int main()&#123; char *s = &quot;Hello World&quot;; char *s2 = &quot;Hello World&quot;; int i = 0; printf(&quot;&amp;i=%p\\n&quot;, &amp;i); printf(&quot;s=%p\\n&quot;, s); printf(&quot;s2=%p\\n&quot;, s2);// s[0] = &#x27;B&#x27;;// printf(&quot;Here!s[0]=%c\\n&quot;, s[0]); return 0;&#125; 输出： 123&amp;i=00000059247ffa8cs=00007ff6e247a000s2=00007ff6e247a000 我们发现，i这个本地变量和这个无名数组存放位置的地址相差很大，现在的情况就是，i和s和s2都存在一块，但是s和s2所指向的那个无名字符数组存放的很远，它其实存放在程序的代码段，而且是只读的，如果对代码段的东西进行改写，OS会有一个保护机制会让你的程序崩溃掉，因为OS怕你做坏事情，所以实际上char *s在char前面有一个const，即等价于const char *s，由于历史原因，编译器接受缺省const的写法。 代码段这个东西在我们学PHP的时候接触过，讲内存有以下几个分区： 栈区 代码段 数据段 堆区 如果你想定义一个能修改的字符串，那应该用数组去定义，如： char s[] = “Hello World” 区别就是，上一个是指针，指针说它要去指向存在代码段的一个无名字符数组。这个是一个数组，它把存在遥远的代码段的字符数组拷贝过来，存在自己这，和本地变量存在一起。于是我们写： 12345678910111213141516171819#include &lt;stdio.h&gt;int main()&#123; char *s = &quot;Hello World&quot;; char *s2 = &quot;Hello World&quot;; char s3[] = &quot;Hello World&quot;; int i = 0; printf(&quot;s=%p\\n&quot;, s); printf(&quot;s2=%p\\n&quot;, s2); printf(&quot;&amp;i=%p\\n&quot;, &amp;i); printf(&quot;s3=%p\\n&quot;, s3); s3[0] = &#x27;B&#x27;; printf(&quot;s3[0]=%c&quot;, s3[0]);// s[0] = &#x27;B&#x27;;// printf(&quot;Here!s[0]=%c\\n&quot;, s[0]); return 0;&#125; 输出： 12345s=00007ff74d15a000s2=00007ff74d15a000&amp;i=000000a3e25ffcd0s3=000000a3e25ffcd4s3[0]=B 可以看到s3存放的地址和i的地址很近。也能去修改字符串。 那么当我们定义一个字符串时，我们用哪一种形式呢？ 如果要构造一个字符串，用数组； 如果要处理一个字符串，用指针； 有的教科书说C语言的字符串是char*，这个说法不对，字符串可以表达为char*的形式，但是char *不一定是字符串，本意是指向字符类型的指针。只有它指向的字符数组结尾有’\\0’才能说它所指的是字符串。 字符串输入输出 123char *t = &quot;title&quot;;char *s;s = t; 我们是可以这样赋值的，我们之前说过，已经定义好的数组之间不能相互赋值，因为数组名通常是一个常量指针。但是指向字符数组的指针可以这样相互赋值 12345678#include &lt;stdio.h&gt;int main()&#123; char t[] = &quot;title&quot;; char s[10]; s = t; return 0;&#125; 这样编译就会报错，但是下面这样依然是可行的： 123456int main()&#123; char t[] = &quot;title&quot;; char *s; s = t; return 0; 可以见得，用字符数组的方式定义字符串有个坏处，就是不能相互赋值，因为数组名是一个常量指针。同时我们也得知， 用指针去定义字符串，默认是一个const char*s，不能再去修改字符串的值。因为这种方式其实是一个指向常量池中一个字符串的指针。但是不能用指针去定义其他类型的数组，虽然数组名是指针，但是定义数组时还是要老老实实地用 &lt;类型&gt; 变量名称[元素数量] 去定义数组，用指针定义数组的方法仅对字符串适用。 用数组定义字符串，默认是char *const s，不能去更改s上面存放的地址。这个特征不限于字符型数组，别的数据类型的数组也有这个特征。 char b[10][5] = { //这是一个二维字符数组,所以第2个[]里的数字不能省,编译器不会替我们去数. b[][5]是可以的, 但b[10][]不行 “ling”, “yi”, “er”, “san”, “si”, “wu”, “liu”, “qi”, “ba”, “jiu” &#125;; 二维字符型数组也可以这样初始化, 'ling'后面默认补个'\\0', 'yi'后面补仨这样, 输出的话直接,printf(&quot;%s&quot;, b[0]); 即可, b[0]也是个指向一维字符数组的指针. 但这个一维字符数组它就在这,和b[0]在一起,所以我们可以去修改二维数组中元素的值 char *b[] = { //这是一个一维数组,所以[]里面不用加数字,编译器会替我们去数. “ling”, “yi”, “er”, “san”, “si”, “wu”, “liu”, “qi”, “ba”, “jiu” &#125;; 这不是二维字符型数组,这是一个一维指针数组, 其中每一个指针指向常量池的一个字符串.定义字符串有用数组定义和指针定义两种方式, 一个const在 * 号前,一个在 * 号后,上一种定义二维字符型数组,就是把字符串放在这里, 与数组名放在一起, 这一种方式就是把字符串放在常量池,这里只放指针. 输出的话也是直接,printf(&quot;%s&quot;, b[0]); 即可. 用这种方法, 我们不能通过指针去修改常量池中字符串的值 char *a = “0”; gets(a); 这样是不行的, 你在控制台输入一个新字符串比如&quot;China&quot;, a还是会指向&quot;0&quot;, 即不能通过a试图去把&quot;0&quot;改成&quot;China&quot;, 因为是const char *a = “0”; 但是这样是可行的: char a[100] = {&quot;\\0&quot;}; gets(a); 我们可以通过数组定义的方式去定义字符串, 这样就可以通过a去修改a指向的字符串,让其等于我们输入的字符串. 用指针和数组的方式分别定义字符串,还有个差异,比如 char *a = “China”; 我们通过 ++a,再输出, 123456int main()&#123; char *a = &quot;China&quot;; printf(&quot;%s&quot;, ++a); return 0;&#125; 输出 “hina” ,a指针上的值存放的是 “China” 字符串的首地址, ++a指向常量池中&quot;China&quot;第2个元素, 把它的地址当作首地址.虽然不能通过a去修改字符数组的值,但是a自己的值可以换成别的地址. 但是用数组定义的字符串不能通过自加运算符输出,因为那是 * const 指针,比如: 123456int main()&#123; char a[6] = &quot;China&quot;; printf(&quot;%s&quot;, ++a); return 0;&#125; 这样写就会报错,但是可以这么写: 123456int main()&#123; char a[6] = &quot;China&quot;; printf(&quot;%s&quot;, a + 1); return 0;&#125; 输出也是 “hina”, 因为a的值并能没有被改变, a + 1是个表达式 用指针定义字符串(字符型数组)的方法，不能延申到其他类型的数组，比如定义一个double类型的数组，不能写成 double *a = {0, 1, 2}; 这样写是错误的，非字符串的字符数组也不行，如char *a = {‘1’, ‘2’}; 这样写也是错的。char *a = {‘1’, ‘2’, ‘\\0’}; 这样写也是错的，但是！但是！但是！ 这样写是对的：char *a = “12”; 但是用指针定义指针数组的方法可以延申到其他类型，比如，double *a[] = {0, 1, 2}; 这样是定义了一个指针数组，第一个元素是一个指针，存放的值是NULL，即0地址，第二个元素是一个指针，存放的值是0x1，第三个元素是一个指针，存放的值是0x2 printf和scanf也能去输入或输出字符串，用格式控制符%s。 如果printf()用%s去输出一个字符数组且这个字符数组末尾没有’\\0’，也就是想让它输出不是字符串的字符数组，那么它会在结尾处输出乱码。 我们想了解scanf()中%s的问题，那么先看下面的一段代码： 12345678#include &lt;stdio.h&gt;int main()&#123; int a; scanf(&quot;%d&quot;, &amp;a); printf(&quot;%d&quot;, a); return 0;&#125; 我们输入 12 13，中间有一个空格或这一个tab。输出只有12，那是因为scanf()读到空格就不往下读了。那么再看下面这段代码： 123456789#include &lt;stdio.h&gt;int main()&#123; int a, b; scanf(&quot;%d&quot;, &amp;a); scanf(&quot;%d&quot;, &amp;b); printf(&quot;%d,%d&quot;, a, b); return 0;&#125; 我们输入12 13，则输出12,13，并不会读入空格并输出之，那是因为%d自动把空格或者回车当初分隔符不会读入。这种规则对于%s也同样适用。我们看下面的代码： 12345678#include &lt;stdio.h&gt;int main()&#123; char word[8]; scanf(&quot;%s&quot;, word); printf(&quot;%s##\\n&quot;, word); //这个word虽然是个指针，但是指向那个无名字符数组，%s可以把这个字符型指针指向的无名数组打印出来 return 0;&#125; 我们输入Hello World，结果输出： Hello## 可见和%d是一样的，都以空格回车TAB为分隔符，读到这三个字符就不读了。 12345678910#include &lt;stdio.h&gt;int main()&#123; char word[8]; char word2[8]; scanf(&quot;%s&quot;, word); scanf(&quot;%s&quot;, word2); printf(&quot;%s##%s##\\n&quot;, word, word2); return 0;&#125; 我们输入Hello World，结果输出： Hello##World## 和%d一样，也不会读入空格。 scanf()函数使用空白（换行符、制表符和空格）把输入分成多个字段。 在依次把转换说明和字段匹配时跳过空白。只要在每个输入项之间输入至少一个换行符、空格或制表符即可，可以在一行或多行输入。唯一例外的是%c会读取每个字符，包括空隔符。 但是scanf()里面仅仅用%s是不安全的，可能我们输入的字符串长度比那个字符数组长度大，可能会造成数组越界，因此我们可以用%[width]s来控制读入字符的长度，比如%7d， 12345678910#include &lt;stdio.h&gt;int main()&#123; char word[8]; char word2[8]; scanf(&quot;%7s&quot;, word); scanf(&quot;%7s&quot;, word2); printf(&quot;%s##%s##\\n&quot;, word, word2); return 0;&#125; 我们输入12345678，输出： 1234567##8## 我们并没有输入空格TAB或者回车，一旦有width存在，就不是根据空格，回车，TAB作为分隔符了，而是根据width 12char *stringscanf(&quot;%s&quot;, string); 这么写往往都误以为char*是字符串类型，其实是错的，string是一个指向字符类型的指针，由于没有对它初始化，所以string上面存的是那块内存原来遗留的值，我们后面把那个遗留的值当成地址传入scanf()，并输入，因此改写的是其它的内存上的值，如果那块内存上的值可以被改写，没问题，如果不能，就会报错。 12char *string;printf(&quot;%s&quot;, string); 这样写，也不对。string只是一个字符型指针，%s做的是把string指向的字符串打印下来。如果string没有指向任何字符串，那么%s就无能为力。 字符串数组 如果想写一个数组来表达很多个字符串，该怎么写呢？ char **a; 表示a是一个指针，该指针指向另一个指针，那个指针指向一个字符(串)，这显然不是我们想要的。 char a[][n]; 表示a是一个数组，a这里面的每一个单元都是一个char[n]，每一个单元都是一个字符数组。 char *a[] = {“Hello”, “World”, “你好”}； 意思是，a数组里面的每一个元素都是一个指针，比如a[0]指向外面一块内存，那块内存上存放着&quot;Hello&quot;……，注意a并不是一个指向二维数组的指针. char *s = “Hello World”; 这是一个指向一个一维字符串数组的指针. char t[] = “title”; 一个实际长度为6的字符数组, 最后一个元素是’\\0’ 字符串数组，在main()函数的参数表里也有应用，其实main函数参数表里有2个参数，一个是整数，一个是字符串数组，整数来告诉我们后面那个字符串数组里面到底有多少个字符串 int main(int argc, char const *argv[]) 字符串数组里面这些字符串是执行这个程序是，在名字后面所跟上的东西，argv[0]就是执行时所输入的可执行程序的名字，这一点在Unix里面很有用。 单字符输入输出 int putchar(int c); 它接收的参数虽然是int类型，但是它只能接受char范围内的int，它的返回类型也是int，表示这次它写出去了几个字符，正常情况下都是返回1，如果一些问题，它会返回EOF(End Of File)，EOF是C语言里面定义的一个宏，这个宏的值是-1，表示不能再输出东西了。 int getchar(void) 不需要有参数，返回int是因为需要返回EOF(-1)来表示输入结束了，看下面一串代码： 12345678910#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int ch; while ((ch = getchar()) != EOF)&#123; putchar(ch); &#125; printf(&quot;EOF\\n&quot;); return 0;&#125; 我们输入一串数字，按下回车，终端原封不动地输出我们刚刚输入的字符，getchar()只读一个字符，但是为什么我按下回车才给我回答呢？用户键盘显示器和你的程序之间还有一个程序，叫做shell。shell要做的非常基本的一件事情是，你在键盘上按的所有东西，它给你形成一个&quot;行编辑&quot;的工作，也就是说你在键盘上输入1 2 3 4 5 6……，在你按下回车之前，这些东西还没有送到你的程序那里去，都还停留在shell那里，直到你按下回车，这也是为什么我们之前使用scanf的时候，也要按下回车才行。按下回车之后，shell那里会有一个很大的缓冲区，把按下回车后送进去的东西都依次填在缓冲区。比如我们在键盘上输入的是123最后敲回车，那么缓冲区里就是123回车，接下来就是你程序的事了，如果你的程序用的是getchar()，那么getchar会一个字符一个字符地读，先读1再读2再读3。如果你的程序用到scanf(%d)，那么scanf()会把123变成一个整数一次性读入。 函数strlen 所有的字符串函数都是str开头,&quot;Hello&quot;占据6个字节，但是用strlen()得到的长度是5， 函数strcmp 顾名思义，cmp是compare，比较两个字符串。为什么要用函数去比较呢？能不能直接比较两个字符串？比如我们写s1 == s2，编译会给warning，提示数组之间的比较永远是false。为什么，因为这两个字符数组虽然上面存的值一样，但一定不是同一个地址，我们用==去比较的时候其实是在比较地址是否相同。 用大于小于号，比较的是字符串的首地址大小，而不是字符串的大小。 char arr1[] = “abcdef”; char arr2[] = “abc”; 比较的是&quot;abcdef&quot;中a的地址和&quot;abc&quot;中a的地址。 字符串变量比较不能直接用==，但是可以用变量地址和字符串用==比较，如果地址相同，字符串会相等。char *str1 = “hello”;和”hello”的地址是相同的，所以返回结果相等。 但是字符型变量char可以直接拿比较运算符比较大小，因为它本质是整型。 int strcmp(const char *s1, const char *s2) C语言标准并没有具体规定 strcmp() 函数的返回值是多少，大多数编译器选择了以下两种方案： 返回两个字符串的差值，即找到两个字符串中首个不相等的字符，然后返回这两个字符的差值； 返回 -1、0 或者 +1；-1表示s1 &lt; s2；+1表示s1 &gt; s2 返回0表明两个字符串是相等的， 两个字符串自左向右逐个字符相比（按 ASCII 值大小相比较），直到出现不同的字符或遇 \\0 为止 函数strcpy char *strcpy(char *restrict dst, const char *restrict src) 第一个参数是目的，第二个参数是源。 返回一个字符指针，这个返回的字符指针就是dst 在源字符串还未确定下来时，我们想提前在程序里面写好一个复制一个字符串的语句，常见的操作是： char* dst = (char*) malloc(strlen(src)+1) stcpy(dst, src); 这个函数参数表里面有C99新的关键字restrict，意思是两个字符串不能重叠，什么是重叠？比如我想把s1拷贝给s2，重叠的话就是，s1和s2在内存上存储的位置有部分是重合的。原因是现代函数的设计不光要考虑功能实现，还要考虑很多额外因素，strcpy()是处理字符串中使用及其广泛的函数，在这个函数上面如果有一点点性能的小改进，可能对整个程序，整个系统，甚至对整个互联网都有巨大的提升，因此人们在这上面做了很多的努力来使得这个函数效率的提升，其中一个努力就是，当你的计算机是多核的，它可能把这个拷贝工作分成好几段，让每一个核做其中一段，此时必须要求拷贝出来的字符串不能和原来的字符串重叠，否则分段拷贝就会有冲突。 函数strcat char* strcat(char *restrict s1, const char *restict s2); 把s2拷贝到s1的后面去，接成一个长字符串，并返回s1，前提是s1必须要有足够的空间。 strcpy 和 strcat 都有可能出现安全问题，因为我们不知道目标字符串的大小是多少，会不会越界，所以我们要用它俩的升级版本，strncpy和strncat，同时在参数表里多了一个n，这个n表示能够拷贝或连接过去多少个字符，如果多了怎么办？掐掉，越界是不可能越界的。 对于strcmp()也有带n的版本，strncmp()，这个n并不是解决安全问题的，这个n表示，我只想比较前n个字符串是否相等。 字符串搜索函数 char* strchr(const char s, int c); 我要在这个字符串中，从左边寻找c第一次出现的位置。 char strrchr(const char *s, int c); 我要在这个字符串中，从右边寻找c第一次出现的位置。 返回NULL表示没找到，返回非NULL，则返回一个指针，指向你要找的那个字符。 我们如何寻找一个字符串中的第二个字符呢？可以用一个小套路： 1234567891011#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(int argc, char const *argv[])&#123; char s[] = &quot;Hello&quot;; char *p = strchr(s, &#x27;l&#x27;); char *q = strchr(p+1, &#x27;l&#x27;); printf(&quot;%s\\n&quot;, p); printf(&quot;%s\\n&quot;, q); return 0;&#125; 我们运行，输出： 12llolo 我们实现了找到一个字符串其中一个字符第2次出现位置。同时我们也明白了printf()中的%s输出字符串的原理，字符串的输出是通过字符数组名找到其字符数组起始地址,然后逐个输出其中的字符，遇到字符’\\0’就停止输出。字符型指针p指向一个字符数组(字符串)，p的值就是这个字符数组首元素的地址，然后%s根据p的值找到p所指向的字符数组，并输出之。我们在找第2个字符位置时就利用了这个原理，先把p+1，此时通过指针运算，p+1的值就是&quot;llo&quot;第二个’l’的地址，让字符指针q的值等于第2个’l’的地址，那么下一个%s在输出时，就是根据q的值找到q所指向的字符数组&quot;lo&quot;，并输出之。%s是把指针上的地址当作所要输出的字符串的第一个元素的地址。 %s输出字符串是这个原理我们很能理解，因为数组传进函数只能传进它的指针(字符串就是一个数组)，函数再通过指针来找到外面的数组。scanf()也是一个函数，也不能例外。 我们如果想把&quot;Hello&quot;后面的&quot;llo&quot;复制给另一个字符数组，这样干： 12345678910111213#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char const *argv[])&#123; char s[] = &quot;Hello&quot;; char *p = strchr(s, &#x27;l&#x27;); char *t = (char *) malloc(strlen(p)+1); strcpy(t, p); printf(&quot;%s\\n&quot;, t); free(t); return 0;&#125; 还有一个小技巧，就是我们想截取&quot;Hello&quot;前面的&quot;He&quot;，这么干： 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char const *argv[])&#123; char s[] = &quot;Hello&quot;; char *p = strchr(s, &#x27;l&#x27;); char c = *p; *p = &#x27;\\0&#x27;; char *t = (char*) malloc(strlen(s)+1); strcpy(t, s); printf(&quot;%s\\n&quot;, t); free(t); printf(&quot;%s\\n&quot;, s); *p = c; printf(&quot;%s&quot;, s); return 0;&#125; 输出： 123HeHeHello 字符指针p指向&quot;llo&quot;，p的值是该字符串首元素的地址，所以*p即第一个’l’。通过 *p把’l’换成’\\0’，就把字符串s&quot;Hello&quot;从’\\0’那里截断了，所以s现在是&quot;He&quot;，再将s拷贝给t，事成之后，利用 *p将还原。 strstr()是在一个字符串中寻找一个字符串的。 strcasestr()也是在一个字符串中寻找一个字符串，只不过会忽略大小写。 Day13 枚举 如果莪们程序当中出现一些数字，那么我们应该尽量用一些符号来表达这些数字，这样做会增加可读性。 如果常量一多，定义起来就很麻烦可以用枚举，它是一个用户定义的数据类型，它用关键字enum声明： enum 枚举类型名字{名字0，名字1，……}; 有时候也会把枚举类型名字忽略掉，因为有时候名字不重要。我们通常要的是大括号{}里面的名字，他们就是常量符号，他们的类型只能是int。 当我们需要一些可以排列起来的常量值时，比如月份，日期等等，定义枚举的意义就是给了这些常量值的名字。 enum color {red, yellow, green}; 这是在声明一种新的数据类型，这种数据类型叫做color，我们可以把它像int float类型一样去用，当然，用的时候要带上enum(后面的语言有的可以不带enum)，比如： enum color {red, yellow, green}; void f(eum color c); 实际上，C语言内部，enum就是int型，所以每一个枚举变量是可以当作int型输入输出的，比如： enum color {red, yellow, green}; void f(eum color c); enum color t = red; enum color d = 100; scanf(&quot;%d&quot;, &amp;t); f(t); 关于枚举有一个小套路，看看下面代码： 1enum COLOR &#123;RED, YELLOW, GREEN, NumCOLORS&#125;; NumCOLORS 恰好是3，因此我们发现，这个常量可以表达它的前面有多少个常量。可以用这个东西定义数组，可以用来遍历，等等。 声明枚举量时也能指定值。 我们在C语言里面用枚举，主要的需求是需要定义一些排比的常量，比用const方便。而不太会用它去做数据类型的事。 枚举有类型，宏没有类型， C语言之前的语言和C语言之后的语言，都有枚举，但是做的都比C语言好，枚举在C语言里面不是那么成功的东西。 结构类型 一个结构就是一个复合的数据类型，类似JAVA和python中的类。比如： 12345678910#include &lt;stdio.h&gt;int main(void) &#123; struct data&#123; int month; int day; int day; &#125;; return 0;&#125; 和本地变量一样，在函数内部声明的结构类型，只能在函数内部使用。所以通常在函数外部声明结构类型，函数只要在在这个结构体声明下面，就可以使用这个结构体类型。 声明结构的形式： struct date today; 变量名叫today，类型是struct date，struct不可缺省。 1234struct &#123; int x; int y;&#125; p1, p2; 这种情况下，p1和p2并不是结构类型的名字，它们就是前面这种结构类型的2个变量。这个结构类型没有名字。其实这种做法就是想要两个变量，p1和p2，后面不会再用到这种结构类型了、 更常见的是这种形式： 1234 struct point &#123; int x; int y;&#125; p1, p2; 在声明新的结结构类型point的同时，还定义了2个这种类型的变量。 结构类型和结构变量是2个东西，声明一个结构类型后，我们可以定义出很多结构变量来。 类型不分配内存，但是变量分配内存。 结构体的成员名可以与程序中的变量名相同，不会混淆。但不建议。 结构体数组不是一个二维数组。 2个结构体变量不能直接用比较运算符去做比较。 sizeof()是个静态运算符，不是一个函数，它也可以测量结构体类型和结构体变量的大小。 结构的初始化： 有下面一个结构体： 12345678910#include &lt;stdio.h&gt;int main(void) &#123; struct data&#123; int month; int day; int day; &#125;; return 0;&#125; struct date today = {07, 31, 2014}; struct date today = {.month = 07, .year = 2014}; 这种方式和数组初始化一样，没有被初始化的字段day自动填0。这种机制和JAVA也是一样的。 用.访问成员变量，这一点和JAVA也一样。出现在.左边的一定是一个结构变量，而不是一个结构类型，结构类型的虚体，结构变量才是实体。 数组里面有很多的单元，结构里面有很多的成员。数组的单元的必须是相同类型的，结构不必。 也可以直接，date.month = 7; 这样初始化。和JAVA一样。 结构有一点和数组不同，对于整个结构，可以直接做赋值，取地址，也可以传递给函数参数。 1234567struct point&#123; int x; int y; &#125; p1, p2; p1 = (struct point)&#123;5, 10&#125;; p1 = p2; 数组无法做上面2中运算，数组自带const。 如果把p2的字段的值改了，那么p1不会跟着改，这是两个不同的结构变量，这一点和数组也不一样。 另外一个和数组非常不一样的地方就是，结构变量的名字，并不是结构变量的地址。数组的变量名就是数组的地址。对结构变量取地址必须使用&amp;运算符。eg. struct data *pData = &amp;today; 如果把&amp;去掉，则编译报错。 结构与函数 结构体类型和普通的数据类型用法一样，比如： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;int SumEven(const int *a, int len);int SumOdd(const int *a, int len);int SumOverall(const int *a, int len);int main()&#123; int a[1000] = &#123;0&#125;; int n = 0; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt;= n; ++i) &#123; a[i] = i; &#125; printf(&quot;%d\\n%d\\n%d&quot;, SumEven(a, 1000), SumOdd(a, 1000), SumOverall(a, 1000)); return 0;&#125;int SumEven(const int *a, int len)&#123; int sum = 0; for (int i = 0; i &lt; len; i += 2) &#123; sum += a[i]; &#125; return sum;&#125;int SumOdd(const int *a, int len)&#123; int sum = 0; for (int i = 1; i &lt; len; i += 2) &#123; sum += a[i]; &#125; return sum;&#125;int SumOverall(const int *a, int len)&#123; int sum = 0; for (int i = 0; i &lt; len; ++i) &#123; sum += a[i]; &#125; return sum;&#125; 取成员运算符 . 的优先级一定大于取地址运算符 &amp; 的优先级。 结构体变量传入函数传的都是值，一个字段一个字段复制给函数内部，想修改外部的结构体，最好传指针的值。 没有直接的方式可以一次scanf一个结构。函数怎么把函数里面的结构体传出去呢？可以return出去，也就是让函数返回类型是该结构类型。 如果有一个大的结构变量要传进函数，则通常的做法是传结构指针，否则既费空间，又费时间， 12345678910struct date &#123; int month; int day; int year;&#125;;struct date myday;struct date *p = &amp;myday;(*p).month = 12;p-&gt;month = 12; 最后两行是等价的，-&gt; 是一个新的运算符，和 . 的运算符地位一样，在这个运算符的左边一定是个指针，取成员运算符(指针) -&gt; 和取成员运算符(对象) .一样，优先级都高于 &amp; 和 * ,常见到 &amp;p-&gt;month 和 (*p).month 。 * 和 &amp; 运算符是平级的。 结构中的结构 结构里面的变量可以是普通数据类型，比如int float double，也可以是其他结构体类型，比如： 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;struct point&#123; int x; int y;&#125;;struct rectangle&#123; struct point pt1; struct point pt2;&#125;;int main()&#123; struct rectangle r; r.pt1.x = 0; r.pt1.y = 0; r.pt2.x = 1; r.pt2.y = 1; struct rectangle *rp; rp = &amp;r; (*rp).pt1.x = 2; rp-&gt;pt1.x = 2; return 0;&#125; (*rp).pt1.x = 2; rp-&gt;pt1.x = 2; 这两句是等价的，但是注意，间接访问运算符 * 的优先级低于取成员变量运算符 . ，(*rp).pt1.x = 2; 不加()会报错，rp-&gt;pt1.x = 2; 这句话中 -&gt; 和 . 是平级的，自左向右运算的，所以无需加括号。 有结构数组，即数组的元素都是结构，也可以做数组结构，即结构里面有个数组。 类型定义 我们定义一个结构体变量时，总是要加上 struct 很不方便，用 typedef关键字可以摆脱 struct，它可以来声明一个已有数据类型的新名字。比如：typedef int Length; Length a, b, c; 1234 struct point &#123; int x; int y;&#125; p1, p2; 在声明新的结结构类型point的同时，还定义了2个这种类型的变量。 1234 typedef struct point &#123; int x; int y;&#125; p1; 重载已有结构类型 point 的名字，重载为 p1 ,并没有定义新的结构变量出来。 typedef 可以定义数组类型 typedef struct TableEntry Table[ NunVertex ]; 这条语句把含有 NunVertex 个元素的结构体数组类型 重载为 Table。再比如： 12typedef int arr[100];arr a, b, c; 其中第2句相当于a[100],b[100],c[100] ，即 arr就是 int [100] ”类型“的重载。 typedef *char[10] Strings 这句话的意思是将一个字符型指针数组，重载为Strings 联合","categories":[],"tags":[]},{"title":"陈姥姥_数据结构(1)","slug":"Data-Structure-learning","date":"2022-07-24T02:35:10.000Z","updated":"2022-07-25T09:25:10.133Z","comments":true,"path":"2022/07/24/Data-Structure-learning/","link":"","permalink":"http://example.com/2022/07/24/Data-Structure-learning/","excerpt":"","text":"Day 1 关于数据组织 解决问题方法的效率，跟数据的组织方式有关。 比如，存书和查书问题。","categories":[],"tags":[]},{"title":"C语言学习tips","slug":"C_Learn_Tips","date":"2022-07-22T07:42:10.000Z","updated":"2023-02-28T01:22:14.345Z","comments":true,"path":"2022/07/22/C_Learn_Tips/","link":"","permalink":"http://example.com/2022/07/22/C_Learn_Tips/","excerpt":"","text":"2022.9.21 输入长度不小于20的字符串，则定义数组是一定要不小于21，因为有’\\0’； 字符型比较相等时一定要用 == ，千万别用 = 。 冒泡排序，可以只排你想让排序的行数，余下行数可以不排，比如有一个长度为10的一维数组，则我们可以用冒泡排序只去排前2行，前3行，前4行等等。 逗号运算符优先级是C语言所有运算符里面最低的。 1,200 不是一个合法常量； C语言是由函数组成的，函数是C语言的基本单位。所以说C语言主要是借助定义函数来实现程序模块化，函数把程序分成一个个模块。 注意，我们写for循环时，改变条件的语句，比如i++，一般就写在for的括号里面，但是在写while循环时，while 的括号里面没有i++，循环体里面需要加能改变条件的语句，否则是死循环。 C语言中goto语句，不仅可以终止循环，还能跳过你不想执行的语句。 程序从main()函数开始执行，也从main()函数结束。 直接递归:递归函数的函数体中存在显式的自我调用时，被称为直接递归。例如，函数foo中包含自我调用，因此是直接递归。 123456int foo(int x) &#123; if (x &lt;= 0) return x; return foo(x - 1); &#125; 间接递归:函数foo被称为间接递归，如果它包含对另一个函数的调用，而另一个函数最终会调用回函数foo。 1234567891011 int foo(int x) &#123;if (x &lt;= 0) return x;return bar(x); &#125; int bar(int y) &#123; return foo(y - 1); &#125; c语言中小的数对大的数取余，就商0，余数就等于被除数。3%7=3，7%10=7，10%20=10。 运算符：又叫操作符，表示对数据操作的符号，操作的数称为操作数，也称算子； 格式化字符串（Format String）是在编程过程中，允许编码人员通过特殊的占位符，将相关对应的信息整合或提取的规则字符串。格式化字符串包括格式化输入和格式化输出。一般格式：%[标志][输出最小宽度][.精度][长度][格式字符] 当 switch-case 的判断条件是一串连续的正整数时，其实是不用写冗长的switch语句的，写成数组简短很多，比如： 1234567891011121314151617181920212223242526272829303132333435switch (residue) &#123; case 0: outcome = 1; break; case 1: outcome = 0; break; case 2: outcome = 88; break; case 3: outcome = 9; break; case 4: outcome = 8; break; case 5: outcome = 7; break; case 6: outcome = 6; break; case 7: outcome = 5; break; case 8: outcome = 4; break; case 9: outcome = 3; break; case 10: outcome = 2; break; &#125; 我们把outcome写成一个数组，case的值用数组下标好了。 C语言中如何输出指定长度的整数，不够的用0填充。&quot;%0ad&quot;中的a是几就代表输出固定长度为几的整数，0代表的就是不够的位数用0填充，一般为向左填充不够的位数。比如这个%04d的0就是指在前面补0占位，4代表位宽。一般这两个要一起用。当然，当数字本身宽度比位宽大的话，那这就不起作用了，如a=12345;那么输出也是 a=12345 12int a=1;printf(&quot;a=%04d\\n&quot;, a); 输出：a=0001 但是不能补其他符号，比如： 12int a=1;printf(&quot;%*4d\\n&quot;, a); 我想用 * 号来补前面的空位，这样是行不通的，语法过不去。 如果不加0，只有%4d，则不够的只会补空格，比如： 12int a=1;printf(&quot;%4d\\n&quot;, a); 输出： 1，4前面加符号，则左对齐，比如： 12int a=1;printf(&quot;%-4d##\\n&quot;, a); 输出：1 ##，但是超出范围，左对齐也不起作用了，比如 12int a=100000;printf(&quot;%-4d##\\n&quot;, a); 输出100000## printf如果仅仅输出一个字符串，则可以省略转化字符 %s。比如： 123printf(&quot;%s&quot;,&quot;Hello World!&quot;);可简写为：printf(&quot;Hello World!&quot;); 但如果输出与其他数据组合的字符串时，必须用转化字符 %s 1printf(&quot;%s 一斤 %f 元，%s 一斤 %d 元&quot;,&quot;苹果&quot;,2.5,&quot;西瓜&quot;，2); puts()是用来输出字符串的，可以直接输出字符串常/变量，也可以输出指针变量 printf（）的输出格式很多，可以根据不同的需要加转义字符，达到格式化输出。 区别: puts()和printf()都能够用来输出字符串，但是两者有些许不同。puts()在输出字符串后，会自动换行，而printf不会自动换行。 puts(s)等价于printf(“%s\\n”,s); 0 &lt; 余数 &lt; 商 辗转相除法求最大公因数原理1 辗转相除法求最大公因数原理2 由于 m ÷ n = q…r 这个关系式子的存在，我们很容易得到 m 和 n 的公约数集合就等于 n 和 r 的公约数集合。所以 m 和 n 的最大公因数一定也是 n 和 r 的最大公因数，所以我们就可以用递归去求了。求 m 和 n 的最大公因数也就是求 n 和 r 的最大公因数，以此类推，可以开始递归了，直至找到那个最大公约数。 指针的变量命名别和普通变量名一样，否则会报错。 if 和 else if 语句后的判断条件从上到下依次判定，遇到第一个满足条件的则进入执行语句执行 执行完毕后无视其他 else if 和 else 语句判断和其执行语句，往下执行。如果最后一个判断条件才满足，则前面的判断条件肯定都判断过了。 字符数组，在scanf gets时自动加\\0，在用双引号初始化时也自动加\\0 函数名是指向函数的指针,代表函数的起始地址. puts()函数只能输出字符串 如果想从一个字符串的第n个位置往后输出,则可以这样, 比如:123456int main()&#123; char *a = &quot;China&quot;; printf(&quot;%s&quot;, a + n); return 0;&#125; 对于指针来说，p + 1 比 p++ 好，因为 前者不会改变p的值，后面如果要再用到p，还是原值，不容易出错误。 缓冲区（Buffer）又称为缓存（Cache），是内存空间的一部分。 使用 gets() 时，系统会将最后“敲”的换行符从缓冲区中取出来，然后丢弃，所以缓冲区中不会遗留换行符。这就意味着，如果前面使用过 gets()，而后面又要从键盘给字符变量赋值的话就不需要吸收回车清空缓冲区了，因为缓冲区的回车已经被 gets() 取出来扔掉了。 关于指针作为函数返回值的一些思考： 先看下面一段代码引出问题： 12345678910111213141516#include &lt;stdio.h&gt;int * function();int main()&#123; int *b = 0; b = function(); for (int i = 0; i &lt; 2; ++i) &#123; printf(&quot;%d\\n&quot;, b[i]); &#125; return 0;&#125;int * function()&#123; int a[2] = &#123;1, 2&#125;; return a;&#125; 我们运行输出，发现什么都没有输出，调试一下，发现 b 是NULL，哦，我们恍然大悟，a是一个指向一个int数组的指针，该数组名就是a，但是这个数组是一个本地变量，作用域和生存期都是在函数内部。返回的是一个指向这个本地变量的指针，那么到了main()以后，返回的这个指针还在，并且赋给了b，我们想让b指向a数组，但是a数组已经不在了，所以b指向空。所以我们如果想让数组返回一个指向数组的指针，那么该数组最好定义在main()函数里面，并且传入函数内部。 如果函数返回的是普通类型，比如返回int型，看下面这个代码： 1234567891011121314#include &lt;stdio.h&gt;int function();int main()&#123; int b = 0; b = function(); printf(&quot;%d&quot;, b); return 0;&#125;int function()&#123; int a = 2; return a;&#125; 运行输出是2，返回int型就不会出现这种问题，因为 a 确实会被消灭，但是 a 把值及时传给了 b ，上面那个返回指针的直接返回NULL，b 的值就是NULL 再看一组例子: 12345678910111213#include &lt;stdio.h&gt;int *func()&#123; int n = 100; return &amp;n;&#125;int main()&#123; int *p = func(), n; n = *p; printf(&quot;value = %d\\n&quot;, n); return 0;&#125; 运行后也是什么也不输出。返回的是NULL。 2个挨在一起的scanf()，第2个scnaf往往会去读输入第一个scanf留下了的换行符，用两个连续的gets()函数可以解决这个问题。 C语言字符型数组初始化，不够的自动补’\\0’ 我们想连着用scanf()读入字符串，可以这么写： 123char a[20] = &#123;&#x27;\\0&#x27;&#125;;char b[20] = &#123;&#x27;\\0&#x27;&#125;;scanf(&quot;%s %s&quot;, &amp;a, &amp;b); 原因是scanf()中%s读到空格就不往下读了。刚好可以利用这个空格来分割输入的字符。 想让两个变量交换值，可以用 异或 位运算符(两个值相异结果为真，两个值相同结果为假)，比如： 12345a = 10; // 1010b = 11; // 1011a = a ^ b; // 0001b = b ^ a; // 1010a = a ^ b; // 1011 输出 a = 11; b = 10; 这样做比用临时变量来保存的a的值，可以节省一个用来保存临时变量的寄存器。 左移1位，相当于该数乘2，左移比乘法运算快得多，有些编译器会把 * 2自动转为左移1位； 文本文件：这类文件以文本的ASCII码形式存储在计算机中。它是以&quot;行&quot;为基本结构的一种信息组织和存储方式。 二进制文件：这类文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂它们，只有通过相应的软件才能将其显示出来。二进制文件一般是可执行程序、图形、图像、声音等等。 然而，可能与你的想象不同的是，这里的二进制或者文本与文件的格式并没有任何关系，而是文件流操作时对数据的表达方式。因为文本文件与二进制文件的区别仅仅是编码上不同. 大家都知道计算机的存储在物理上是二进制的，所以文本文件与二进制文件的区别并不是物理上的，而是逻辑上的。这两者只是在编码层次上有差异。简单来说，文本文件是基于字符编码的文件，常见的编码有ASCII编码，UNICODE编码等等。二进制文件是基于值编码的文件，你可以根据具体应用，指定某个值是什么意思(这样一个过程，可以看作是自定义编码)。 从上面可以看出文本文件基本上是定长编码的(也有非定长的编码如UTF-8)。而二进制文件可看成是变长编码的，因为是值编码嘛，多少个比特代表一个值，完全由你决定。大家可能对BMP文件比较熟悉，就拿它举例子吧，其头部是较为固定长度的文件头信息，前2字节用来记录文件为BMP格式，接下来的8个字节用来记录文件长度，再接下来的4字节用来记录bmp文件头的长度。 文本工具打开一个文件的过程是怎样的呢？拿记事本来说，它首先读取文件物理上所对应的二进制比特流，然后按照你所选择的解码方式来解释这个流，然后将解释结果显示出来。一般来说，你选取的解码方式会是ASCII码形式（ASCII码的一个字符是８个比特），接下来，它8个比特8个比特地来解释这个文件流。例如对于这么一个文件流&quot;01000000_01000001_01000010_01000011&quot;(下划线’’_’’，为了增强可读性手动添加的)，第一个8比特’‘01000000’‘按ASCII码来解码的话，所对应的字符是字符’‘A’’，同理其它3个8比特可分别解码为’‘BCD’’，即这个文件流可解释成“ABCD”，然后记事本就将这个“ABCD”显示在屏幕上。 事实上，世界上任何东西要与其他东西通信会话，都存在一个既定的协议，既定的编码。人与人之间通过文字联络，汉字“妈”代表生你的那个人，这就是一种既定的编码。但注意到这样一种情况，汉字“妈”在日本文字里有可能是你生下的那个人，所以当一个中国人Ａ与日本Ｂ之间用“妈”这个字进行交流，出现误解就很正常的。用记事本打开二进制文件与上面的情况类似。记事本无论打开什么文件都按既定的字符编码工作（如ASCII码），所以当他打开二进制文件时，出现乱码也是很必然的一件事情了，解码和译码不对应嘛。例如文件流’‘00000000_00000000_00000000_00000001’'可能在二进制文件中对应的是一个四字节的整数int 1，在记事本里解释就变成了&quot;NULL_NULL_NULL_SOH&quot;这四个控制符。 因为文本文件与二进制文件的区别仅仅是编码上不同，所以他们的优缺点就是编码的优缺点，这个找本编码的书来看看就比较清楚了。一般认为，文本文件编码基于字符定长，译码容易些；二进制文件编码是变长的，所以它灵活，存储利用率要高些，译码难一些（不同的二进制文件格式，有不同的译码方式）。关于空间利用率，想想看，二进制文件甚至可以用一个比特来代表一个意思(位操作)，而文本文件任何一个意思至少是一个字符． 在windows下,文本文件不一定是一ASCII来存贮的,因为ASCII码只能表示128的标识,你打开一个txt文档,然后另存为,有个选项是编码,可以选择存贮格式,一般来说UTF-8编码格式兼容性要好一些.而二进制用的计算机原始语言,不存贮兼容性. 很多书上还认为，文本文件的可读性要好些，存储要花费转换时间(读写要编译码)，而二进制文件可读性差，存储不存在转换时间（读写不要编解码，直接写值）．这里的可读性是从软件使用者角度来说的，因为我们用通用的记事本工具就几乎可以浏览所有文本文件，所以说文本文件可读性好；而读写一个具体的二进制文件需要一个具体的文件解码器，所以说二进制文件可读性差，比如读BMP文件，必须用读图软件。 详见 注意在写递归函数时，特别要谨慎使用全局变量或者静态局部部便变量，因为在进入下一层函数时，你不好把控这个全局变量或者静态局部变量的值，看下面两段代码： 1234567891011121314double f(int a, int n)&#123; double this_item = 0; int n2 = n - 1; if (n == 1) &#123; this_item = a; return this_item; &#125; else &#123; while (n2 &gt;= 0) &#123; this_item += (a * pow(10, n2--)); &#125; return this_item + f(a, n - 1); &#125;&#125; 和 1234567891011121314double this_item = 0;double f(int a, int n)&#123; int n2 = n - 1; if (n == 1) &#123; this_item = a; return this_item; &#125; else &#123; while (n2 &gt;= 0) &#123; this_item += (a * pow(10, n2--)); &#125; return this_item + f(a, n - 1); &#125;&#125; 第2段代码，每进入下一次函数，this_item的值积累了外层函数得到的值，所以每一层函数得到的this_item会被重复加。 回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。把一段可执行的代码像参数传递那样传给其他代码，而这段代码会在某个时刻被调用执行，这就叫做回调。如果代码立即被执行就称为同步回调，如果在之后晚点的某个时间再执行，则称之为异步回调。为什么不像普通函数调用那样，在回调的地方直接写函数的名字呢？这样不也可以吗？为什么非得用回调函数呢？有这个想法很好，因为在网上看到解析回调函数的很多例子，其实完全可以用普通函数调用来实现的。要回答这个问题，我们先来了解一下回到函数的好处和作用，那就是解耦，对，就是这么简单的答案，就是因为这个特点，普通函数代替不了回调函数。所以，在我眼里，这才是回调函数最大的特点。(其实普通函数的函数名也是一个函数指针) 关于判断素数的一个技巧：判断一个整数m是否是素数，只需把 m 被 2 ~ m-1 之间的每一个整数去除，如果都不能被整除，那么 m 就是一个素数。m 不必被 2 ~ m-1 之间的每一个整数去除，只需被 2 ~ sqrt(m)之间的每一个整数去除就可以了。如果 m 不能被 2 ~ sqrt(m)间任一整数整除，m 必定是素数。，但是sqrt(m)，如果是小数怎么办？是判断 2 ~ (int)(sqrt(m)) + 1 还是 2 ~ (int)(sqrt(m)) 就行了呢？后者。因为 (int)(sqrt(m)) + 1 比 (sqrt(m)) 大了，如果 m 能被 (int)(sqrt(m)) + 1 整除，那么m也一定能被一个小于(int)(sqrt(m))的整除，我们只需判断那个比(int)(sqrt(m))小的数即可，因此判断 2 ~ (int)(sqrt(m)) 就行了。 编写一个程序，可以编一点，运行一下，看看有没有错误，如果全部写完再来运行，出错了不容易找出在哪个位置。 for (i = 0; s[i] != ‘\\0’; ++i) 这个for循环可以代替 int i = 0; while(s[i] != ‘\\0’) {++i;} while 循环常用于不知道到底要循环多少次的循环，for 循环适合知道循环次数的循环，但也不绝对，比如： for (int i = 0; a[i] != 0; ++i) {} C++能完全兼容C 编码规范不仅能让代码更易读，也可以提高代码的运行效率 面向过程: 就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。典型的C语言，C语言是由函数组成的，函数是C语言的基本单位。所以说C语言主要是借助定义函数来实现程序模块化，函数把程序分成一个个模块，C语言程序执行的过程就是从主函数依次调用函数的过程； 面向对象：是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描述某个事物在整个解决问题的步骤中的行为。解决问题并不是一步一步地写函数去完成的 现在C语言的编译器都是发源于GCC(GNU Compiler Collection) C语言编译过程 C/C++源文件 预处理程序 (头文件) 预处理后文件 编译程序 汇编代码 汇编程序 目标文件/目标代码 连接程序 (库函数文件) 可执行程序 每种机器的汇编语言还不同 CPU内部有指令集，因此可以知道目标代码里的每个01指令该做什么 .lib是静态连接库文件，.dll是动态连接库文件 C是C语言的继承，它既可以进行C语言的过程化程序设计，又可以进行以抽象数据类型为特点的基于对象的程序设计，还可以进行以继承和多态为特点的面向对象的程序设计。C擅长面向对象程序设计的同时，还可以进行基于过程的程序设计，因而C++就适应的问题规模而论，大小由之。 C语言编译过程： 预处理程序（Preprocessor）读取C语言源文件，对其中以“#”开头的指令（伪指令）和特殊符号进行处理。伪指令主要包括文件包含、宏定义和条件编译指令。 生成预处理文件 编译程序（Compiler）对预处理之后的预处理文件进行词法分析和语法分析，试图找出所有不符合语法规则的部分。在确定各成分都符合语法规则后，将其“翻译”为功能等价的中间代码表示或者汇编代码。 生成汇编代码 汇编程序（Assembler）把汇编语言代码翻译成目标机器代码的过程。 生成目标文件 连接程序将一个文件中引用的符号（如变量或函数调用）与该符号在另外一个文件(如函数文件)中的定义连接起来，从而使有关的目标文件连成一个整体，最终成为可被操作系统执行的可执行文件。 生成可执行文件 gcc 与 g++ 分别是 gnu 的 c &amp; c++ 编译器 gcc/g++ 在执行编译工作的时候，总共需要4步：按照gcc的选项作用所对应的编译阶段，可将gcc的选项分为四组：预处理选项、编译选项、优化选项和连接选项。详细见下: 预处理,生成 .i 的文件 将预处理后的文件转换成汇编语言, 生成文件 .s 有汇编变为目标代码(机器代码)生成 .o 的文件 连接目标代码, 生成可执行程序 $ gcc f1.c f2.c （针对C语言源程序）执行完成后，生成默认的可执行文件a.out。-o 可以指定连接程序最后生成的可执行文件名称为file，而不是默认的a.out 一个有趣的事实就是，就本质而言，gcc和g并不是编译器，也不是编译器的集合，它们只是一种驱动器，根据参数中要编译的文件的类型，调用对应的GUN编译器而已，更准确的说法是：gcc调用了C编译器，而g调用了C++编译器。比如，用gcc编译一个c文件的话，会有以下几个步骤： 调用预处理器 调用编译器 调用汇编器 调用连接 进程是已启动的可执行程序的运行实例。进程有以下组成部分： 已分配内存的地址空间； 安全属性，包括所有权凭据和特权； 程序代码的一个或多个执行线程； 进程状态 程序： 二进制文件，静态。进程： 是程序运行的过程， 动态，有生命周期及运行状态。 ps 和 top 的区别： ps看到的是命令执行瞬间的进程信息,而top可以持续的监视 ps只是查看进程,而top还可以监视系统性能,如平均负载,cpu和内存的消耗 top还可以操作进程,如改变优先级(命令r)和关闭进程(命令k) ps主要是查看进程的，关注点在于查看需要查看的进程。top主要看cpu,内存使用情况，及占用资源最多的进程由高到低排序，关注点在于资源占用情况 C/C++包含头文件中&lt;&gt;和&quot;“的区别: 有的程序用&lt;&gt;，有的却用”&quot;，那么二者到底什么区别呢，什么情况下使用呢？&lt;&gt;和&quot;“表示编译器在搜索头文件时的顺序不同，&lt;&gt;表示从系统目录下开始搜索，然后再搜索PATH环境变量所列出的目录，不搜索当前目录，”“是表示从当前目录开始搜索，然后是系统目录和PATH环境变量所列出的目录。所以，系统头文件一般用&lt;&gt;，用户自己定义的则可以使用”&quot;，加快搜索速度。两者之间是没有多大差别的，只是为了提高查找效率而区分的.但有的编译器比较严格，因此会作严格区分 -Ldir 制定编译的时候，搜索库的路径。比如你自己的库，可以用它制定目录，不然编译器将只在标准库的目录找。这个dir就是目录的名称。 -Idir 在你是用 #include “file” 的时候, gcc/g++ 会先在当前目录查找你所制定的头文件, 如果没有找到, 他回到默认的头文件目录找, 如果使用 -I 制定了目录,他会先在你所制定的目录查找, 然后再按常规的顺序去找。对于 #include, gcc/g++ 会到 -I 制定的目录查找, 查找不到, 然后将到系统的默认的头文件目录查找 。 动态库和静态库一样也是函数的二进制的集合，但动态库在程序运行的时候动态加载到内存，而静态库在编译时期就整合到最后的可执行文件中 C++允许定义形参个数和类型不确定的函数。例如，C语言中的标准函数printf便使用这种机制。在声明不确定形参的函数时，形参部分可以使用省略号“…”代替。“…”告诉编译器，在函数调用时不检查形参类型是否与实参类型相同，也不检查参数个数。例如： 1void ConnectData(int i,...) 在上面的代码中，编译器只检查第一个参数是否为整型，而不对其他参数进行检查。 对于可变参数的函数，需要进行特殊的处理。首先需要引用 &lt;stdarg.h&gt; 头文件，然后利用va_list类型和va_start、va_arg、va_end 3个宏读取传递到函数中的参数值。 该方法是极不安全的，宏本身无法提供任何安全性保证，他总是按照既定代码“自作多情”的认为实参就应该是那么多，即使实参并不是那么多。这就要求所有安全性必须由程序员来保证。例如，在以上的示例代码中，如果调用时指定count为10，但实际上只给出9个可变形参，那么函数还是会读取10个参数，显然第十次读取是多余的，多余的操作一般不会有什么好结果，当然如果实参过多，多余的实参也不会被读取而是被忽略。 使用这种方法的一个实例是printf()函数。printf()函数通过分析第一个字符串参数中的占位符个数来确定形参的个数；通过占位符的不同来确定参数类型（%d表示int类型、%s表示char *）；它也有上述提到的安全问题，如果不小心少提供了个实参，那么越界访问就会发生。 想要将指针数组作为函数的参数进行传递就类似于一位普通数组的传递方法，将数组名作为数组的首元素地址进行实参传递，在形参接实参的时候要注意指针数组的类型是二级指针，所以要用二级指针","categories":[],"tags":[]},{"title":"贾老师的离散数学","slug":"Discrete_mathematics","date":"2022-07-22T07:42:10.000Z","updated":"2022-11-04T05:26:23.513Z","comments":true,"path":"2022/07/22/Discrete_mathematics/","link":"","permalink":"http://example.com/2022/07/22/Discrete_mathematics/","excerpt":"","text":"微信是无向图；微博是有向图 初级通路一定是简单通路； 简单通路不一定是初级通路；比如带环的简单通路 最大连通分支和极大连通分支不一样； 只有K2才有桥，其他的完全图都没有桥。 只要存在一个点出度或者入度为0，就一定不是强连通 关于邻接矩阵中 (aij) ^l 为有向图D中长度为l的通路的理解： 首先l=1时，表示行顶点到列顶点有没有长度为1的路到达，没有则为0，有一条则为1，有2条则为2.那么l=2的话，矩阵相乘，举例，n=3，(a13) ^2，根据矩阵乘法规则，其实际意义就是找顶点1到3之间长度为2的通路数，长度为1不行，因为 (a13) ^2 = a11 * a13 + a12 * a23 + a13 * a33 ，a11为0，代表它没有连自己的路，a13为1，代表1到3之间长度为1的路有1条。a13=2代表1到3之间长度为1的路有2条，(一个l=1的邻接矩阵里面的路长度只能为1)，那么a11 * a13 的意义在于，1到3之间长度为2的路为 0 * 1 = 0 个。 同理，a12 * a23 的实际意义就是，先看1到2的长度为1的路有几条，再看2到3的长度为1的路有几条，相乘即为1到2再到3之间长度为2的路的个数。 a13 * a33 同理，这样把 1到3之间所有可能连接的情况列出来，然后再找每种情况下长度为2的路再找出来即可。 长度为1的回路一定是环。 完全图一定是简单图，无向完全图中任意两个顶点之间都一定有且仅有一条边连接 欧拉图中可以有割点，只要这个割点不是奇度顶点即可，但是欧拉图中不能有桥，因为欧拉回路要求不能有重边； 如果这个哈密顿图是无向简单连通图，那么它一定没有割点或桥 n阶极大平面图，n &gt;= 3，则该图不可能存在割点和桥 Kn都没有点割集，Kn有且仅有K2有桥，但是其他Kn可以有边割集 Kn，当n &gt;= 3, Kn 一定是哈密顿图；当n为奇数时，Kn一定为欧拉图，当 n &gt;= 5, 则Kn是非平面图，n &lt;= 4 则Kn一定是极大平面图 Kr,s 当s != r 时，一定不是哈密顿图，特别地，当 s = r+1 时，是半哈密顿图 Kr,r 当r &gt;= 2时，一定是哈密顿图，r = 1 则是K2 Kr,s 当r = s时，一定存在完美匹配，否则不存在，用定义证明就行 Kr,s 当r. s &gt;= 3时，一定是非平面图 Kr,s 当r. s 均为偶数时，一定是欧拉图，否则一定不是欧拉图 在平面嵌入中可以把任何面当作外部面 同构图的对偶图不一定同构 连通图的对偶图的对偶图和该连通图也不一定同构 任何平面图都是可以4着色的 欧拉图：避桥法、逐步插入回路算法 生成树：破圈法 最小生成树：避圈法","categories":[],"tags":[]},{"title":"初尝Git","slug":"Git_Learn","date":"2022-07-22T07:42:10.000Z","updated":"2022-11-16T13:39:16.563Z","comments":true,"path":"2022/07/22/Git_Learn/","link":"","permalink":"http://example.com/2022/07/22/Git_Learn/","excerpt":"","text":"在idea上Git push 提示hint: not have locally. This is usually caused by another repository push原因： 在 GitHub上创建一个仓库A，并且初始化了readme.md这个文档. 在本地用 Git Bash初始化仓库A(一开始没有从GitHub上拉下来). 本地仓库跟远程仓库的版本不一样导致的,因为执行在 步骤1的时候，远程的版本库会有个 “commit readme.md”这个操作记录,本地仓库是不知道你有这个提交的，也就是说这个记录没在本地仓库是不存在的，所以俩个版本是不一致的. 两个不同的本地仓是可以提交到同一个远程仓的，这也是git可以多人协作开发的原因，但是切记，push前一定要pull远程仓到本地仓，防止远程仓和本地仓不一致导致push被rejected 即使仓库是public，也只有被邀请的成员可以commit，随便来个人是不能push过去的 总之一句话，基于A分支创建B分支，在B分支会将A分支里面所有内容都都带过来来，如果你在B分支里面，不需要维护A分支过来的文件，就不要对这些你不要维护的文件进行任何操作，否则合并的时候就会改变A里面你不该改动的文件，可以把B看作A的一个子类 如果在本地仓删除或增加一个文件，那么push后，远程仓也会删除或增加相应文件 远程仓增加或删除一个文件，那么pull到本地，会把那个增加或删除的文件pull下来 如果远程仓增加或者删除一个文件或者增加删除一个分支，但是我本地仓没有及时pull下来，我本地仓在想push时，会报错，这时需要先pull,再push，所以在开发的时候，需要及时pull，再push 在本地仓用 git switch -c dev 新建dev分支后，一定要用 git push --set-upstream origin dev 或者 git push origin dev 把本地分支push到远程仓，远程仓才能出现新建的分支，修改分支内容并push到远程仓的分支才不会报错 如果本地文件夹新增的文件没有commit到本地仓，那么push过去的还是老文件夹 本地仓选择不同的分支，本地文件夹的内容会随着本地仓分支的不同而改变 本地分支合并后，一定要push到远程才能让远程分支也合并 不合并之前，分支的任何增删操作不会影响到主分支，但是合并后就会 一个本地仓可以对应两个或者多个远程仓操作 远程仓删除一个文件，本地仓pull之后，本地仓对应的文件也会被删除 本地新建一个dev分支后，推送到远程仓1，那么远程仓1就多一个dev分支，推送到远程仓2，远程仓2就多一个dev分支 idea上修改文件以后不能直接push，要先commit再push，或者commit&amp;push一起，否则push的还是老文件 IDEA上上分支有书签代表是当前分支，只有处于当前分支，才能把其他分支合并到当前分支，比如A处于当前分支，那么B分支此时可以合并到A分支，不能A分支合并到B分支，除非B分支处在当前分支 git 命令行有所动作，idea也会跟着变，比如切换分支","categories":[],"tags":[]},{"title":"速通JSP","slug":"JSP_Learn","date":"2022-07-22T07:42:10.000Z","updated":"2022-11-27T06:35:46.839Z","comments":true,"path":"2022/07/22/JSP_Learn/","link":"","permalink":"http://example.com/2022/07/22/JSP_Learn/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"握手定理推论证明","slug":"Handshake lemma_Deduction","date":"2022-07-22T07:42:10.000Z","updated":"2022-10-17T08:48:06.350Z","comments":true,"path":"2022/07/22/Handshake lemma_Deduction/","link":"","permalink":"http://example.com/2022/07/22/Handshake%20lemma_Deduction/","excerpt":"","text":"握手定理推论：任意无向图或有向图的奇度顶点个数必为偶数 pf. 首先握手定理有：无论是有向图还是无向图，其所有顶点度数之和必为偶数(所有边数的2倍) 然后我们有n个奇数， 当n为偶数时，这n个奇数相加结果必为偶数，eg.3+9=12； 当n为奇数时，这n个奇数相加结果必然为奇数，eg.3+9+11=23； 其次我们有： 任意个偶数相加，其结果必为偶数； 偶数+奇数，其结果必为奇数，eg.9+4=13； 有了上面这三个结论，我们假设任意有向图或者无向图的奇度顶点个数为偶数个，则：n为奇数时，这n个奇数相加结果必然为奇数。 因此我们得出这 奇数个 奇度顶点 的 总度数 一定是奇数。 我们又知道：图的总度数一定为偶数； 我们还知道，剩下的顶点都是偶度顶点，所有偶度顶点的总度数一定是偶数； 最后我们得到这样的结果：所有偶度顶点的总度数是偶数， 奇数个 奇度顶点 的 总度数 是奇数，而奇数+偶数=奇数，因此我们得出所有顶点总度数是奇数。 这与握手定理相悖，故假设不成立。 故奇度顶点的个数一定为偶数，即证出。","categories":[],"tags":[]},{"title":"Linux操作系统","slug":"Linux_Learn","date":"2022-07-22T07:42:10.000Z","updated":"2023-03-21T09:32:20.101Z","comments":true,"path":"2022/07/22/Linux_Learn/","link":"","permalink":"http://example.com/2022/07/22/Linux_Learn/","excerpt":"","text":"win系统上cmd是DOS系统的影子 OS是裸机之上的第一层软件，与硬件关系极为密切 从技术上来说，Linus Benedict Torvalds开发的 Linux 只是一个内核。内核指的是一个提供设备驱动、文件系统、进程管理、网络通信等功能的系统软件，内核并不是一套完整的操作系统，它只是操作系统的核心。一些组织或厂商将 Linux 内核与各种软件和文档包装起来，并提供系统安装界面和系统配置、设定与管理工具，就构成了 Linux 的发行版本。 X Windows 和 Windows 很像，但是不是一个结构 $ 代表普通用户， # 号代表超级用户 unix是一个多用户多任务的操作系统。早期电脑昂贵，所以当时使用便宜的设备连接到电脑上(当时还没有键盘和显示器，使用纸带和卡片来输入输出)来使用操作系统，这个便宜的设备就是终端，也可以认为终端是一种控制台。所以可以认为电脑本身是console终端，便宜的连接设备是物理终端pty。 Linux是类unix系统，所以也继承了终端的特性。但是后来电脑逐渐便宜，也出现了显示器和键盘，所以可以使用键盘当作输入终端，显示器当作输出终端，这些终端就是虚拟终端，虚拟终端其实就是虚拟控制台，或者说是一个虚拟设备。 clear命令清除屏幕上的信息，它类似于DOS中的CLS命令 一般命令格式的命令名、选项、参数之间用空格或者制表符隔开，否则会被认为是一坨 bash是终端的名字 文件是被命名的相关信息的集合体 文件的成分： 索引节点 数据：文件的实际内容 Linux的文件名和Windows的文件名命名规则一样 Linux只有目录，没有硬盘的分区 和Windows一样，Linux所有的目录都是从根目录开始，&quot;/&quot; 利用扩展名可以区分文件的属性 以圆点 . 开头的文件名是隐含文件 文件名通配符 :0-inf 个字符，匹配当前目录下所有文件，除了.文件 ？:1个字符 [] :与[]中的任意一个匹配，比如 letter[123], 可以是letter1、letter2…… “&gt;” 是重定向，是覆盖原有文件的内容，&gt;&gt;是追加，不会删除源文件的内容 root下面的子目录 root的父目录是自己，/ 代表根目录 home 文件夹是所有用户的主目录，里面每个用户有自己的文件夹 bin放可以执行的二进制文件 sbin放的管理系统命令的文件 boot存放启动系统时引导的文件 etc文件放配置文件，子文件有password 、 root超级用户的工作目录 lib 存放共享库 dev 存放标识设备的目录 lost+found 系统非正常关闭的目录 mnt 存放安装系统的安装点 tmp存放临时文件 usr可供所有用户共享 var系统运行时要改变的数据 绝对路径名总是以 / 开头，它代表根目录 rmdir 只能删除空目录，有东西的目录不能删 链接：一个文件起多个名字的功能 硬链接：如果一个文件有硬链接，那么在其中一个目录中删除该文件，但是别的地方还有文件名指向该文件，那么在别的地方还能通过另一个文件名访问到该文件，类似程序设计中的引用机制和垃圾回收机制，只要该变量还被指针指着，那么就不会被回收。 软链接(符号链接)：建立一个快捷方式，是一个新的文件。 进程来反映程序在计算机里面动态执行的过程，一个程序可以对应几个进程 现代OS都是多任务OS，即同一时刻，里面有多个程序在执行 CPU的运算非常快，但是程序运行中，可能出现很多等待资源加载，等待输入，等待输出的状态(比如要输入密码才能继续执行，此时应该放弃对CPU的占用)，此时CPU会空转，这样CPU利用效率不高，因此人们设置多道程序。比如A程序运行，A在等待输入，那么CPU就会跑过去执行B程序。等到A输入完了，CPU再回来执行A程序。 多道程序设计：内存中同时存放多道程序，交替地在CPU中运行 程序写完保存下来是静态的，但是并发执行时，由于要和其他程序共用内存，CPU等，所以会处于一种执行、暂停执行、执行的状态。此时需要一个新的动态概念来描述这种动态的状态。为了描述程序地动态执行过程，就引入了进程的概念。 进程的特征 动态性 并发性： 调度性：调度的基本单位就是进程 异步性：各个进程向前推进的速度是不可预知的 结构性：程序段，数据段，控制结构组成 进程的基本状态： 运行态：在CPU上执行的状态 就绪态 阻塞态：程序执行着，突然要等待一个输入停下来了。 进程可以作为资源分配的单位，资源包括硬件(CPU,GPU,内存……)、软件。最紧张的资源是CPU，有专门的调度算法用来调度进程。 PID是进程的编号，在OS里面是唯一的，用PID识别进程 OS会先调度优先级高的进程，现代OS一般只允许普通用户降低进程优先级，而不允许升高进程优先级。除非root用户 shell是包裹linux内核的壳，用户可以通过shell和linux内核交互 ubuntu 安装日历 sudo apt install ncal ubuntu 修改系统时间无效，参见 ubuntu 修改系统时间无效 info命令是Linux下info格式的帮助指令。阅读 info 格式的文档，和help命令具有相同的功能 在linux中，“ll”命令指的是“ls -l”命令，它是“ls -l”命令的一个别名，但也不完全相同。ll会列出该文件下的所有文件信息，包括隐藏的文件，而ls -l只列出显式文件，说明这两个命令还是不等同的！ Cat命令(concatenate的缩写)是Linux操作系统中使用最广泛的命令行实用工具之一。它是一个标准的Linux实用程序，用于查看文件的内容，而不需要在任何文本编辑器中打开它。cat命令的另一个主要用法是将多个文件串联到一个文件中。 在LINUX中如何把2个文件中的内容合到另一个文件中 使用cat命令从文件中读入两个文件，然后将重定向到一个新的文件。这种方法可以一次性合并任意多个文件。 12将file1.txt和file2.txt合并到file.txt$ cat file1.txt file2.txt &gt; file.txt 只使用cat命令读入一个文件，然后使用&gt;&gt;将文本流追加到另一个文件的末位。 12将file1.txt追加到file2.txt的末尾$ cat file1.txt &gt;&gt; file2.txt Linux head 命令, -n&lt;行数&gt; 显示的行数。head [-n num] | [-num] [-v] filename 当 -n 后面跟正数时，会打印正数行，若跟负数，则则显示除了最后|num|(绝对值)行的其余所有行，即显示前“总行数-|num|”。例如-100，打印除最后100行外所有行 tail命令类似head，但是num前面加+号时，表示前面num-1行都不打印，然后打印剩下的 Linux 中同时使用 head 和 tail 命令。由于tail和head命令打印文件的不同部分，我们可以将这两者结合起来打印一些文件内容的高级过滤。例如，如果要从任何文件的中间读取内容，则必须同时使用这两个命令。假设我们想要读文件的第 5 行到第 10 行/etc/passwd。首先， head command 将检索前 10 行， tail command 再从 head command 检索的前 10 行中检索最后 5 行 head 。 head -n 10 /etc/passwd | tail -n 5 ‘&gt;’ 是覆盖原有内容, ‘&gt;&gt;’ 是追加内容。二者均表示 将一条命令执行结果（标准输出，或者错误输出，本来都要打印到屏幕上面的）重定向其它输出设备（文件，打开文件操作符，或打印机等等）。就是这个输出本来是要输出到屏幕上的，现在重定向输出到某个文件等 &lt;和&lt;&lt;：命令默认从键盘获得的输入，改成从文件，或者其它打开文件以及设备输入 rgrep命令用于递归查找文件里符合条件的字符串。rgrep指令的功能和grep指令类似。类似 grep -r 当重复的行并不相邻时，uniq 命令是不起作用的。这时我们就可以使用 sort cat命令法向文件添加内容的几种方法, 结尾的EOF要顶格，成对出现，可以其它字符代替。否则会报错 comm 命令用于比较两个已排过序的文件。 diff可以直接输出比较结果，不要求事先对文件进行排序。对第一个文件提出修改建议使得第一个文件与第二个文件一致。 将文件排序结果保存到原文件 不能只 sort 文件名 还得加上 -o 例如 sort testfile3 -o testfile3 cd 若目录名称省略，则变换至使用者的 home 目录 (也就是刚 login 时所在的目录) ~ 也表示为 home 目录 的意思， . 则是表示目前所在的目录， … 则表示目前目录位置的上一层目录。 ln（英文全拼：link files）命令是一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个同步的链接。当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在 其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。 Linux文件系统中，有所谓的链接(link)，我们可以将其视为档案的别名，而链接又可分为两种 : 硬链接(hard link)与软链接(symbolic link)，硬链接的意思是一个档案可以有多个名称，而软链接的方式则是产生一个特殊的档案，该档案的内容是指向另一个档案的位置。硬链接是存在同一个文件系统中，而软链接却可以跨越不同的文件系统。不论是硬链接或软链接都不会将原本的档案复制一份，只会占用非常少量的磁碟空间。 软链接： 软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式 软链接可以 跨文件系统 ，硬链接不可以 软链接可以对一个不存在的文件名进行链接 软链接可以对目录进行链接 给文件创建软链接，为log2013.log文件创建软链接link2013，如果log2013.log丢失，link2013将失效： 硬链接： 硬链接，以文件副本的形式存在。但不占用实际空间。 不允许给目录创建硬链接 硬链接只有在同一个文件系统中才能创建 硬链接，ln 源文件名 符号链接文件名，源文件名和符号链接文件名是并列关系，源被删了，符号链接依然有效。硬链接实际上和源文件在硬盘中是同一个东西，效果类似于硬盘上的一个文件，在文件系统上，在我们看来有好多个文件一样。每次删除一个文件时，只要他还有其他的硬链接存在，这个文件就不会被真正删除。只有等所有的链接文件都删除掉了，这个文件才会被真正从硬盘上删除 chmod（英文全拼：change mode）命令是控制用户对文件的权限的命令 chmod命令可以使用八进制数来指定权限。文件或目录的权限位是由9个权限位来控制，每三位为一组，它们分别是文件所有者（User）的读、写、执行，用户组（Group）的读、写、执行以及其它用户（Other）的读、写、执行。历史上，文件权限被放在一个比特掩码中，掩码中指定的比特位设为1，用来说明一个类具有相应的优先级。这样的操作与[ugoa…][[±=][rwxX]的效果等价，比如 chmod a=rwx file 和 chmod 777 file 效果相同 [权限掩码]是由3个八进制的数字所组成，比如721，721并不是一个数字，而是3个八进制数字组成的一串数字。 umask可用来设定[权限掩码]。[权限掩码]是由3个八进制的数字所组成，将现有的存取权限减掉权限掩码后，即可产生建立文件时预设的权限。比如新建一个目录，其预设权限就是 777-022=755 等价于 drwxr-xr-x 。 drwxr-xr-x 这样读：d rwx r-x r-x d:表示文件类型； rwx：表示文件所有者的对该文件所拥有的权限； r-x：表示文件所属组对该文件所拥有的权限； umask -S u=rwx,g=rx,o=rx 和 umask 0022 等价 sudo命令以系统管理者的身份执行指令，也就是说，经由 sudo 所执行的指令就好像是 root 亲自执行。 chown 需要超级用户 root 的权限才能执行此命令。 ps 命令有些与众不同，它的部分选项不能加入&quot;-&quot;，比如命令&quot;ps aux&quot;，其中&quot;aux&quot;是选项，但是前面不能带“-”。出现这样的情况，还要归咎于 UNIX 悠久的历史和庞大的派系。在不同的 Linux 发行版上，ps 命令的语法各不相同，为此，Linux 采取了一个折中的方法，即融合各种不同的风格，兼顾那些已经习惯了其它系统上使用 ps 命令的用户。 当 Linux 内核尝试决定哪些运行中的进程可以访问 CPU 时，其中一个需要考虑的因素就是进程优先级的值（也称为 nice 值）。每个进程都有一个介于 -20 到 19 之间的 nice 值。默认情况下，进程的 nice 值为 0。-20（最高优先序）到 19（最低优先序）。进程的 nice 值，可以通过 nice 命令和 renice 命令修改，进而调整进程的运行顺序。nice 命令可以给要启动的进程赋予 NI 值，但是不能修改已运行进程的 NI 值。同 nice 命令恰恰相反，renice 命令可以在进程运行时修改其 NI 值，从而调整优先级。 使用 nice 命令为一个进程设置 nice 值。记住一个普通用户可以给他拥有的进程设置 0 到 20 的 nice 值。只有 root 用户可以使用负的 nice 值。 Linux 命令是使用终端与系统交互的好方法。但是，有时可能需要一段时间才能完成手头的任务。这迫使用户等待相当长的时间。这时可以让当前事务在后台运行。运行 Linux 后台命令的最简单方法是在命令后添加与号 (&amp;)。例如，如果从终端启动 gedit 文本编辑器，则在关闭编辑器之前无法使用 shell。但是，当您在命令中添加额外的 &amp; 时，您将能够立即使用 shell。比如：$ gedit &amp; 对于需要长时间执行的任务，&amp;符号可以使当前终端窗口不被占用，这样就能继续在同一个终端上工作，甚至关闭终端窗口也不会影响任务的正常执行。不过需要注意的是，如果要求这个任务输出内容到标准输出中（例如 echo 或 ls），即便使用了 &amp;，也会等待这些输出任务在前台运行完毕；当使用 &amp;将一个进程放置到后台运行的时候，Bash 会提示这个进程的进程 ID。在 Linux 系统中运行的每一个进程都有一个唯一的进程 ID，我们可以使用进程 ID 来暂停、恢复或者终止对应的进程。 nohup 英文全称 no hang up（不挂起）。用于在系统后台不挂断地运行命令，退出终端不会影响程序的运行。如果要停止运行，你需要使用以下命令查找到 nohup 运行脚本到 PID，然后使用 kill 命令来删除：ps -aux jobs命令：查看当前终端放入后台的工作 wait是一个shell命令，它能保持等待状态， 直到指定进程运行完成，而且返回进程的退出状态值。 而且Wait命令还可以用于等待特定的进程ID和作业ID并返回其终止状态。在什么情况下需要使用Wait命令呢？​ 在执行较大的自动化脚本时，某些命令或者模块的运行依赖于其它命令或者模块的运行结果， 这时我们需要使这些依赖别的模块结果的模块一直等待， 直到被依赖的模块完成并返回， 然后执行后续的模块或命令，在这种情况下，我们可以使用Wait命令保持等待状态直到上一个模块结束。​ Wait命令可以用于监视先前的过程，根据被等待的命令的运行结果，它将返回Exit状态。例如，如果我们要等待进程ID是13245，我们可以使用“ wait 13245”， 当此进程（PID 13245）完成， wait命令将返回此进程（PID 13245）退出时的返回值。 gzip命令用于压缩文件。文件经它压缩过后，其名称后面会多出&quot;.gz&quot;的扩展名。 zip和gzip的区别 zip是将文件打包为zip格式的压缩文件 gzip是将文件打包为tar.gz格式的压缩文件 unzip是从zip包中解压出某个文件 gunzip从tar.gz包中解压出某个文件 gzip压缩后原来的文件则没有了，解压缩也一样 zip压缩完会保留原文件 控制台的概念与终端含义非常相近，其实现在我们经常用它们表示相同的东西，但是在计算机的早期时代，它们确实是不同的东西。我们在平时的使用中压根就不区分 Linux 中的终端与控制台。 根目录：每一个文件和目录从根目录开始，只有root用户具有该目录下的写权限。 apt 命令执行需要超级管理员权限(root)，也就是前面必须加 sudo命令 对于文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户,即文件所有者。文件所有者以外的用户又可以分为文件所有者的同组用户和其他用户。因此，Linux系统按文件所有者user、文件所有者同组用户group和其他用户other来规定了不同的文件访问权限。 chown命令用来更改文件属主，也可以同时更改文件属组：sudo chown root.root ceshi.txt Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。 rm -rf命令十分危险，删除之前一定要三思。尤其以下命令 Linux中根目录用/表示。而windows表示目录的方式与Linux有所不同，Windows下有磁盘分区的概念，而Linux下只有目录的概念，所以‘/’所表示的意义在两个系统中有所不同。 ‘/’在linux中表示根目录。在Linux系统中，除根目录(root)以外，所有文件和目录都包含在相应的目录文件中。Linux文件系统采用带链接的树形目录结构，即只有一个根目录（通常用“/”表示），其中含有下级子目录或文件的信息；子目录中又可含有更下级的子目录或者文件的信息。这样一层一层地延伸下去，构成一棵倒置的树。 ‘/’在windows中也表示根目录，但此跟目录非彼根目录。windows对磁盘分区后会有多个磁盘，通常系统会装在C盘。windows有多个磁盘所以就会有‘多个根目录’，在dos命令模式下，在D盘的某文件夹中输入‘cd/’命令回车后会直接回到D盘的根目录。其它磁盘下也会回到该磁盘的目录。在哪个磁盘下使用‘/’，它就表示哪个磁盘的根目录。 服务器上的 Linux 是不安装图形界面的，只能在控制台模式下使用，以尽量节省服务器资源。而我们在学习过程中使用的 Linux 是带图形界面的，以满足初学者的需求，降低学习成本。 Linux Unix win 的宿主语言都是C语言 每种机器的汇编语言还不同 CPU内部有指令集，因此可以知道目标代码里的每个01指令该做什么 .lib是静态连接库文件，.dll是动态连接库文件 gcc hello.c -o hello 会将 hello.c 文件预处理成 hello 文件，若不加 -o 即 gcc hello.c，则自动会生成 a.out 文件 vim :%!xdd 查看程序在磁盘上的十六进制存储状态，显示出来的第一列是内存上的地址。回到文本格式按下:%!xdd -r :%!xdd -b 查看程序在磁盘上的二进制存储状态， 进入gbd后，用 shell+ 的命令可以运行普通的linux命令 shell也是一个软件，包裹着Linux内核的壳，用户可以通过shell与内核交互，不同发行版本的linux的shell还不同 shell不需要编译，是解释执行的方式，JAVA也是解释执行 shell是一种用户界面，它也是一个命令解释器，也是一种编程语言 安全性、稳定性比较高的环境，要求更稳定的shell，图形界面容易崩溃 常用shell类型(Ubuntu用的是第4种) 1. Bourne shell (sh) 2. C-shell (csh) 3. Korn shell (ksh) 4. Bourne Again shell (bash) ./ [文件名]，表示执行该文件(chmod 中改的 rwx 中的 x 就是可执行权限，如果不添加 x 权限，执行该文件时可能会提示权限不够) shell变量在赋值时 = 两边不能有空格 $变量名 才能使用变量 若字面量里面有空格 制表符 换行符，则必须用引号括起来 shell脚本的注释是 # shell脚本的第一行写 #!/bin/bash 代表该shell脚本只能在bash类型的shell解释器下执行， #! 告诉系统其后路径所指定的程序即是解释此脚本文件的 Shell 程序。 位置参数在脚本执行的时候自动赋值的，脚本名会自动赋给 $0 位置参数和shift会和循环结构配合使用 if [ $leap -eq 0 ] if语句要加[]， 且[]里面要加空格 Linux 3类引号 双引号 &quot; 单引号 ’ 倒引号 ` 除了3类引号和转义字符 \\ 之外，其余字符都为普通字符 后台进程的调度优先级都低于前台进程的优先级 “|”是Linux管道命令操作符，简称管道符。使用此管道符“|”可以将两个命令分隔开，“|”左边命令的输出就会作为“|”右边命令的输入，此命令可连续使用，第一个命令的输出会作为第二个命令的输入，第二个命令的输出又会作为第三个命令的输入，依此类推。比如 1ls | grep m?.c | wc -l {} 不会新建进程，()会新建进程 {}里面的值要和{}空格隔开，但是()不需要 位置参数可以用来向shell脚本传值 Shell 支持任意数目的分支，当分支比较多时，可以使用 if elif else 结构，此时分支结束时可以只有个 fi 但是若用 if else if 这种级联结构，则有多少if，结尾跟多少fi ps （英文全拼：process status）命令用于显示当前进程的状态，类似于 windows 的任务管理器。 shell测试命令test、[ ]、[[ ]] test可用于测试表达式。在shell中，几乎所有的判断都使用test实现。 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。 条件测试时，在 [[ 中使用 &amp;&amp; 和 || , 在 [ 中使用 -a 和 -o 表示逻辑与和逻辑或。 [] 完全等价于test，只是写法不同。双中括号[ [] ]基本等价于[] ，它支持更多的条件表达式，还允许在双中括号内使用逻辑运算符&quot;&amp;&amp;&quot;、&quot;||&quot;、&quot;!“和”()&quot;，但这些使用单中括号都能实现，只不过多写几个单中括号而已。单中括号[] 无法实现的功能是正则表达式匹配，而[ [] ]可以实现。因此，在能使用单中括号的情况下，无需考虑使用双中括号。 shift命令用于对参数的移动(左移)，通常用于在不知道传入参数个数的情况下依次遍历每个参数然后进行相应处理，有一个shift 就向左移一位 shell中的缩进与C语言中的缩进一样，没有实际意义 break n 。n 表示跳出循环的层数，如果省略 n，则表示跳出当前的循环。 echo &quot;today is date &quot; 后面用倒引号括住，date就变成了一个命令。同样的还有 c=pwd。另一种方式是 c=$(pwd) 也是把pwd变成命令，不加()括住就是变量。 即倒引号括住 和 $() 的效果是一样的。 文件系统：OS来管理使用文件所用的规范 Linux每个文件都有一个inode号(索引节点)，是唯一的，用来区别别的文件。 ip地址与域名的关系是一对多的关系，同一个ip地址可以对应多个域名，一个域名只能对应一个ip地址 源本质是个服务器 .lib是静态连接库文件，.dll是动态连接库文件 C是C语言的继承，它既可以进行C语言的过程化程序设计，又可以进行以抽象数据类型为特点的基于对象的程序设计，还可以进行以继承和多态为特点的面向对象的程序设计。C擅长面向对象程序设计的同时，还可以进行基于过程的程序设计，因而C++就适应的问题规模而论，大小由之。 C语言编译过程： 预处理程序（Preprocessor）读取C语言源文件，对其中以“#”开头的指令（伪指令）和特殊符号进行处理。伪指令主要包括文件包含、宏定义和条件编译指令。 生成预处理文件 编译程序（Compiler）对预处理之后的预处理文件进行词法分析和语法分析，试图找出所有不符合语法规则的部分。在确定各成分都符合语法规则后，将其“翻译”为功能等价的中间代码表示或者汇编代码。 生成汇编代码 汇编程序（Assembler）把汇编语言代码翻译成目标机器代码的过程。 生成目标文件 连接程序将一个文件中引用的符号（如变量或函数调用）与该符号在另外一个文件(如函数文件)中的定义连接起来，从而使有关的目标文件连成一个整体，最终成为可被操作系统执行的可执行文件。 生成可执行文件 gcc 与 g++ 分别是 gnu 的 c &amp; c++ 编译器 gcc/g++ 在执行编译工作的时候，总共需要4步：按照gcc的选项作用所对应的编译阶段，可将gcc的选项分为四组：预处理选项、编译选项、优化选项和连接选项。详细见下: 预处理,生成 .i 的文件 将预处理后的文件转换成汇编语言, 生成文件 .s 有汇编变为目标代码(机器代码)生成 .o 的文件 连接目标代码, 生成可执行程序 $ gcc f1.c f2.c （针对C语言源程序）执行完成后，生成默认的可执行文件a.out。-o 可以指定连接程序最后生成的可执行文件名称为file(可不带.out后缀)，而不是默认的a.out 不像 Windows，Linux 不以文件后缀来区分可执行文件，Linux 下的可执行文件后缀理论上可以是任意的，这里的.out只是用来表明它是 GCC 的输出文件。不管源文件的名字是什么，GCC 生成的可执行文件的默认名字始终是a.out 虽然Linux 不以后缀名区分文件，但是最好带上正确的后缀名，一来容易区分，而来vim这种文编编辑器可以对不同后缀的文件采用不同的功能和高亮 一个有趣的事实就是，就本质而言，gcc和g并不是编译器，也不是编译器的集合，它们只是一种驱动器，根据参数中要编译的文件的类型，调用对应的GUN编译器而已，更准确的说法是：gcc调用了C编译器，而g调用了C++编译器。比如，用gcc编译一个c文件的话，会有以下几个步骤： 调用预处理器 调用编译器 调用汇编器 调用连接 进程是已启动的可执行程序的运行实例。进程有以下组成部分： 已分配内存的地址空间； 安全属性，包括所有权凭据和特权； 程序代码的一个或多个执行线程； 进程状态 程序： 二进制文件，静态。进程： 是程序运行的过程， 动态，有生命周期及运行状态。 ps 和 top 的区别： ps看到的是命令执行瞬间的进程信息,而top可以持续的监视，默认状态显示的是cpu密集型的进程，并且每5秒钟更新一次。 ps只是查看进程,而top还可以监视系统性能,如平均负载,cpu和内存的消耗 top还可以操作进程,如改变优先级(命令r)和关闭进程(命令k) ps主要是查看进程的，关注点在于查看需要查看的进程。top主要看cpu,内存使用情况，及占用资源最多的进程由高到低排序，关注点在于资源占用情况 Ctrl-l 等价于 clear 控制字符(ctrl z ctrl c ctrl d 等等)都是可以通过stty命令更改的，可在终端中输入命令&quot;stty -a&quot;查看终端配置。 ctrl + z 挂起键，给前台进程组中所有进程发送SIGTSTP信号, 并挂起进程。被挂起的进程并没有真正结束，可以使用fg或bg命令恢复被挂起的进程。 fg将后台中的命令调至前台继续运行, bg将一个在后台暂停的命令，变成继续执行 [1]+ 已停止 yes ok 其中 [1] 代表 工作号 一个终端上的程序在另一个终端上用 ps 命令看不到，但是用 top 或者 glances 可以看到 C/C++包含头文件中&lt;&gt;和&quot;“的区别: 有的程序用&lt;&gt;，有的却用”&quot;，那么二者到底什么区别呢，什么情况下使用呢？&lt;&gt;和&quot;“表示编译器在搜索头文件时的顺序不同，&lt;&gt;表示从系统目录下开始搜索，然后再搜索PATH环境变量所列出的目录，不搜索当前目录，”“是表示从当前目录开始搜索，然后是系统目录和PATH环境变量所列出的目录。所以，系统头文件一般用&lt;&gt;，用户自己定义的则可以使用”&quot;，加快搜索速度。 对于类似let x+y这样的写法，Shell 虽然计算了 x+y 的值，但却将结果丢弃；若不想这样，可以使用let sum=x+y将 x+y 的结果保存在变量 sum 中。这种情况下 (( )) 显然更加灵活，可以使用$((x+y))来获取 x+y 的结果 只有使用$((算术表达式))形式才能返回表达式的值，比如 1234$ echo &quot;((12*9))&quot; ((12*9))$ echo &quot;$((12*9))&quot; 108 $[] 也可以做整数运算，但不如不如 (()) 灵活。 crontab命令是cron table的简写 我们用crontab -e进入当前用户的工作表编辑，是常见的vim界面。每行是一条命令 在Linux系统中，使用crontab执行脚本，由于crontab没有环境变量，它是找不到你使用的命令的，需要使用命令的全路径，才可使用命令, 在crontab里要使用全路径 crontab 执行没反应_crontab不能正常执行 可能是因为crond服务未启动，我们需要手动打开它，其中，Centos 上是 sudo service crond start， Ubuntu上的服务名称是cron不是crond。所以你的命令应该是：sudo service cron start 条件表达式要放在方括号之间，并且要有空格，例如: [a==a==a==b] 是错误的，必须写成 [ $a == $b ]。 当一个用户登录 Linux 之后，系统初始化程序 init 就根据 /etc/passwd 文件中的设定，为每个用户运行一个被称为 Shell（外壳）的程序。确切地说，Shell 是一个命令行解释器，它为用户提供了一个向 Linux 内核发送请求以便运行程序的界面系统级程序，用户可以用 Shell 来启动、挂起、停止甚至编写一些程序。Shell 处在内核与外层应用程序之间，起着协调用户与系统的一致性、在用户与系统之间进行交互的作用。Shell 接收用户输入的命令，并把用户的命令从类似 abed 的 ASCII 码解释为类似 0101 的机器语言，然后把命令提交到系统内核处理；当内核处理完毕之后，把处理结果再通过 Shell 返回给用户。 在一般情况下，人们并不区分 Bourne Shell 和 Bourne Again Shell，所以，像 #!/bin/sh，它同样也可以改为 #!/bin/bash。 shell在定义变量并赋值变量时，变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。 使用一个定义过的变量，需要在变量名前面加美元符号，但请注意，再次赋值某个变量时，仍不需要加$，赋值加 $ 会报错 使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。 使用 unset 命令可以删除变量。 字符串是shell编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了），字符串可以用单引号，也可以用双引号，也可以不用引号。单双引号的区别跟PHP类似。 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的，转义字符也是无效； 双引号里可以有变量，转义字符也是有效 $","categories":[],"tags":[]},{"title":"关于php学习中setcookie的疑惑","slug":"PHP_SetCookie_Problem","date":"2022-07-22T07:42:10.000Z","updated":"2022-11-26T14:04:26.554Z","comments":true,"path":"2022/07/22/PHP_SetCookie_Problem/","link":"","permalink":"http://example.com/2022/07/22/PHP_SetCookie_Problem/","excerpt":"","text":"疑惑1 我们在web程序设计书上看到了一串奇怪的代码，令人费解，见下： 12345678910&lt;?php if (!isset($_COOKIE[&quot;visit_time&quot;])) &#123; setcookie(&quot;visit_time&quot;, date(&quot;y-m-d H:i:s&quot;)); echo &quot;欢迎您的第一次！&quot;.&quot;&lt;br&gt;&quot;; &#125;else &#123; setcookie(&quot;visit_time&quot;, date(&quot;y-m-d H:i:s&quot;), time() + 60); echo &quot;您上次访问网站的时间为&quot;.$_COOKIE[&quot;visit_time&quot;].&quot;&lt;br&gt;&quot;; &#125; echo &quot;&lt;br&gt;&quot;.&quot;您本次访问网站的时间为&quot;.date(&quot;y-m-d, H:i:s&quot;).&quot;&lt;br&gt;&quot;;?&gt; 我们原以为书上写错了，因为 else 后面先是又设置了一次 setcookie(“visit_time”, date(“y-m-d H:i:s”), time() + 60); 再输出上次的 $_COOKIE[“visit_time”]值，我们奇怪，既然又设置了一次 setcookie(“visit_time”, date(“y-m-d H:i:s”), time() + 60); 那么后面echo出来的不应该是本次访问时间吗？怎么能够输出上次访问的时间？我们疑惑地打了一遍代码，发现书上没写错，就是输出的上次的访问时间。怎么回事呢？先看看下面的这个博客： PHP setcookie()首次存储不上值 好了，我们按照这篇博客说的验证一下： 还是那串代码，我们在if条件后面加一个输出 $_COOKIE[“visit_time”] 的值： 1234567891011&lt;?php if (!isset($_COOKIE[&quot;visit_time&quot;])) &#123; setcookie(&quot;visit_time&quot;, date(&quot;y-m-d H:i:s&quot;)); echo &quot;欢迎您的第一次！&quot;.&quot;&lt;br&gt;&quot;; echo &quot;您第1次访问网站的时间为&quot;.$_COOKIE[&quot;visit_time&quot;].&quot;&lt;br&gt;&quot;; &#125;else &#123; setcookie(&quot;visit_time&quot;, date(&quot;y-m-d H:i:s&quot;), time() + 60); echo &quot;您上次访问网站的时间为&quot;.$_COOKIE[&quot;visit_time&quot;].&quot;&lt;br&gt;&quot;; &#125; echo &quot;&lt;br&gt;&quot;.&quot;您本次访问网站的时间为&quot;.date(&quot;y-m-d, H:i:s&quot;).&quot;&lt;br&gt;&quot;;?&gt; 我们在浏览器中第一次看到： 123456欢迎您的第一次！Notice: Undefined index: visit_time in D:\\XAMPP\\XAMPPInstall\\htdocs\\Project\\table4.php on line 13您本次访问网站的时间为您本次访问网站的时间为22-10-12, 11:40:18 没有echo出 $_COOKIE[“visit_time”] 的值，说明第一次确实像博客上说的，“前面第一步设置cookie的头信息，也还没有返回给客户端（因为php是服务器端的脚本文件，必须发给浏览器，，浏览器下次访问服务器时，藏在header里的setcookie才能起作用，php要从上到下把语句执行完才会返回给客户端）” 我们点击第2次 123您上次访问网站的时间为22-10-12 11:40:18您本次访问网站的时间为22-10-12, 11:44:16 第2次能输出 $_COOKIE[“visit_time”] 的值了，而且我们发现 $_COOKIE[“visit_time”] 的值，是上一次我们访问浏览器的时间，这就说明我们每次设置一次setcookie，其值得待到下一次访问时才接受得到。 $_COOKIE[“visit_time”] 存放的都是上次的值。 疑惑2 还有一个疑惑 123456789101112&lt;?php setcookie(&quot;visit_time&quot;, 2, time() + 5); echo &quot;您1次访问网站的时间为&quot;.$_COOKIE[&quot;visit_time&quot;].&quot;&lt;br&gt;&quot;; setcookie(&quot;visit_time&quot;, 3, time() + 5); echo &quot;您2次访问网站的时间为&quot;.$_COOKIE[&quot;visit_time&quot;].&quot;&lt;br&gt;&quot;; setcookie(&quot;visit_time&quot;, 4, time() + 5); echo &quot;您3次访问网站的时间为&quot;.$_COOKIE[&quot;visit_time&quot;].&quot;&lt;br&gt;&quot;; setcookie(&quot;visit_time&quot;, 5, time() + 5); echo &quot;您4次访问网站的时间为&quot;.$_COOKIE[&quot;visit_time&quot;].&quot;&lt;br&gt;&quot;; setcookie(&quot;visit_time&quot;, 6, time() + 5); echo &quot;您5次访问网站的时间为&quot;.$_COOKIE[&quot;visit_time&quot;].&quot;&lt;br&gt;&quot;;?&gt; 第一次点击，输出 123456789101112131415Notice: Undefined index: visit_time in D:\\XAMPP\\XAMPPInstall\\htdocs\\Project\\table4.php on line 21您1次访问网站的时间为Notice: Undefined index: visit_time in D:\\XAMPP\\XAMPPInstall\\htdocs\\Project\\table4.php on line 23您2次访问网站的时间为Notice: Undefined index: visit_time in D:\\XAMPP\\XAMPPInstall\\htdocs\\Project\\table4.php on line 25您3次访问网站的时间为Notice: Undefined index: visit_time in D:\\XAMPP\\XAMPPInstall\\htdocs\\Project\\table4.php on line 27您4次访问网站的时间为Notice: Undefined index: visit_time in D:\\XAMPP\\XAMPPInstall\\htdocs\\Project\\table4.php on line 29您5次访问网站的时间为 输出不了，在5s内再次访问，输出： 12345您1次访问网站的时间为6您2次访问网站的时间为6您3次访问网站的时间为6您4次访问网站的时间为6您5次访问网站的时间为6 5s之后再次访问，输出： 123456789101112131415Notice: Undefined index: visit_time in D:\\XAMPP\\XAMPPInstall\\htdocs\\Project\\table4.php on line 21您1次访问网站的时间为Notice: Undefined index: visit_time in D:\\XAMPP\\XAMPPInstall\\htdocs\\Project\\table4.php on line 23您2次访问网站的时间为Notice: Undefined index: visit_time in D:\\XAMPP\\XAMPPInstall\\htdocs\\Project\\table4.php on line 25您3次访问网站的时间为Notice: Undefined index: visit_time in D:\\XAMPP\\XAMPPInstall\\htdocs\\Project\\table4.php on line 27您4次访问网站的时间为Notice: Undefined index: visit_time in D:\\XAMPP\\XAMPPInstall\\htdocs\\Project\\table4.php on line 29您5次访问网站的时间为 又输出不了了，这一点我们上面已经弄明白了，cookie存在的情况下，第2次访问才能访问得到。但是为什么输出得全是6呢？ 因为 cookie可以重名，但同名同path的cookie视为相同cookie，后面的会覆盖前面的 所以最后一个6覆盖了前面所有的值。 疑惑3 再来说 1234setcookie(&quot;visit_time&quot;, 2, time() + 5); echo &quot;您1次访问网站的时间为&quot;.$_COOKIE[&quot;visit_time&quot;].&quot;&lt;br&gt;&quot;; setcookie(&quot;visit_time&quot;, 3, time() + 5); echo &quot;您2次访问网站的时间为&quot;.$_COOKIE[&quot;visit_time&quot;].&quot;&lt;br&gt;&quot;; 第1次点击，输出： 123456Notice: Undefined index: visit_time in D:\\XAMPP\\XAMPPInstall\\htdocs\\Project\\table4.php on line 21您1次访问网站的时间为Notice: Undefined index: visit_time in D:\\XAMPP\\XAMPPInstall\\htdocs\\Project\\table4.php on line 23您2次访问网站的时间为 5s内点第2次，输出： 12您1次访问网站的时间为3您2次访问网站的时间为3 5s后点，输出： 123456Notice: Undefined index: visit_time in D:\\XAMPP\\XAMPPInstall\\htdocs\\Project\\table4.php on line 21您1次访问网站的时间为Notice: Undefined index: visit_time in D:\\XAMPP\\XAMPPInstall\\htdocs\\Project\\table4.php on line 23您2次访问网站的时间为 这些我们都知道什么原因了，但是看下面2串代码： 1234setcookie(&quot;visit_time&quot;, 2); echo &quot;您1次访问网站的时间为&quot;.$_COOKIE[&quot;visit_time&quot;].&quot;&lt;br&gt;&quot;; setcookie(&quot;visit_time&quot;, 3, time() + 5); echo &quot;您2次访问网站的时间为&quot;.$_COOKIE[&quot;visit_time&quot;].&quot;&lt;br&gt;&quot;; 第一次点击，输出： 123456Notice: Undefined index: visit_time in D:\\XAMPP\\XAMPPInstall\\htdocs\\Project\\table4.php on line 21您1次访问网站的时间为Notice: Undefined index: visit_time in D:\\XAMPP\\XAMPPInstall\\htdocs\\Project\\table4.php on line 23您2次访问网站的时间为 5s内点第2次，输出： 12您1次访问网站的时间为3您2次访问网站的时间为3 5s后点，输出： 123456Notice: Undefined index: visit_time in D:\\XAMPP\\XAMPPInstall\\htdocs\\Project\\table4.php on line 21您1次访问网站的时间为Notice: Undefined index: visit_time in D:\\XAMPP\\XAMPPInstall\\htdocs\\Project\\table4.php on line 23您2次访问网站的时间为 我们第1个setcookie时没有设置失效时间的，第2个setcookie设置了，我们根据结果推断出，第2个同名同path cookie不仅把上一个value覆盖了，还把失效时间更新了。为了验证我们的推断，我们看下面一串代码： 123456&lt;?php setcookie(&quot;visit_time&quot;, 2, time() + 5); echo &quot;您1次访问网站的时间为&quot;.$_COOKIE[&quot;visit_time&quot;].&quot;&lt;br&gt;&quot;; setcookie(&quot;visit_time&quot;, 3); echo &quot;您2次访问网站的时间为&quot;.$_COOKIE[&quot;visit_time&quot;].&quot;&lt;br&gt;&quot;;?&gt; 第一次点击，输出： 12345Notice: Undefined index: visit_time in D:\\XAMPP\\XAMPPInstall\\htdocs\\Project\\table4.php on line 21您1次访问网站的时间为Notice: Undefined index: visit_time in D:\\XAMPP\\XAMPPInstall\\htdocs\\Project\\table4.php on line 23您2次访问网站的时间为 5s内点第2次，输出： 12您1次访问网站的时间为3您2次访问网站的时间为3 5s后点，输出： 12您1次访问网站的时间为3您2次访问网站的时间为3 说明第2个同名同path cookie不仅把上一个value覆盖了，还把失效时间更新了，从5秒后失效更新为当前会话时间内有效。","categories":[],"tags":[]},{"title":"python学习技巧","slug":"Python_Learn_Tips","date":"2022-07-22T07:42:10.000Z","updated":"2022-12-04T12:29:40.338Z","comments":true,"path":"2022/07/22/Python_Learn_Tips/","link":"","permalink":"http://example.com/2022/07/22/Python_Learn_Tips/","excerpt":"","text":"Python字符串是不可变的。这意味着一旦创建了字符串，便无法对其进行修改，如果您进行了修改，则它将创建一个新的python字符串。 对于eval()括号中的的字符串(非数字)，如果字符串带的是单引号或者是双引号都会引起NameError,这是因为eval()函数在处理字符串时会去掉其两个引号。正确应该使用一个单引号包含一个双引号组成的三引号来包含字符串。 python 如果使用一个未被定义的变量,解释器会报错.关键是括号中粉底的那三个词,用来解释python中怎么才叫定义一个变量,也就是说你想定义一个变量必须要给它赋值,只有给一个名称赋了值,才叫定义了一个变量.//有的语言中,可以使用某个关键字先声明一个变量,而赋值的操作可以后面做;还有的语言,你可以只声明变量而不赋值,后面使用该未赋值的变量时,解释器会根据你声明的类型赋一个默认值,等等;也就是说不同语言对变量的处理逻辑可能不同.而python对变量的处理逻辑就是:定义和赋值二者绑在一块了,即赋值的过程同时完成了&quot;定义+赋值&quot;,不存在&quot;只定义&quot;这个过程。python还是一个强类型语言，每个变量的类型必须在编译时确定，而只有赋值才能确定类型。 Python的布尔类型有两个值True和False（注意大小写要区分） python 的方法一定要加括号 字符串切片后返回字符串 有个切片得小技巧，可以看到python切片功能的强大，在做古风排版时：123456n = int(input())str1 = input()if len(str1)%n != 0: str1 = str1 + (n - (len(str1)%n)) * &#x27; &#x27;#用空格补齐字符串for i in range(n): print(str1[i::n]) 123456n = int(input())str1 = input()if len(str1)%n != 0: str1 = str1 + (n - (len(str1)%n)) * &#x27; &#x27;#用空格补齐字符串for i in range(n): print(str1[i::n][::-1]) #str1先和第一个括号结合切片返回一个切片后的字符串，再与第2个[]结合逆序输出 对于python的print(), 字符串和数值类型，可以直接输出; 对于变量，无论什么类型，数值、字符、列表、字典… 可以直接输出 len()方法返回对象（字符、列表、元组等）长度或项目个数，不像C只能用于字符串 python如何判断一个列表中的数值是否全部小于某个数：all(map(lambda x: x &lt; num, list1)) 想把字符数组转为数字型数组，可以用 1234numbers = [‘1’, ‘5’, ‘10’, ‘8’] numbers = list(map(int, numbers))// 或者[int(i) for i in numbers] 如果numbers是纯数字的字符串也能用这种方法转为纯数字的列表 把num=123这个整数转为列表：可以print(list(str(num)))，但不能print(list(num))，因为num不可迭代，list必须用于可迭代对象 字符串切片后返回字符串，列表切片后返回列表 try except和if-else一样，都是分支结构，但是try-except更高阶，因为try-except给了我们试错的机会，如果try那个分支出现错误，不会立马报错，而是跳到except去执行下面的代码，但是if如果出现错误，会立马报错，并程序停止执行。多用try-except，就像我们的生活。 如果您有一个文件a.py，并且在其中有一些功能： 1234567def b():# Somethingreturn 1def c():# Somethingreturn 2 你想把它们导入到另一个.py文件里并调用其中的函数，你得写 1from a import b, c python中 is, is not 对比的是两个变量的内存地址，==,!= 对比的是两个变量的值 python 中没有 || ，和 &amp;&amp;，但是有 == 和 != python isdigit()和isalpha()都是在判断字符串，而非真的数字和字母 python eval(str(n)[::-1]) 整数逆序的方法，利用可迭代对象的切片，这在C语言里很难操作 字符串变列表可以用list() 当for循环有两个需要迭代的对象时，要用zip对这多个变量封装，否则会报错。比如： 1234starts = [0,1,2,3,4]ends = [5,6,7,8,9]for start, end in starts, ends: print((start, end)) 这样会报错 1234starts = [0,1,2,3,4]ends = [5,6,7,8,9]for start, end in zip(starts, ends): print((start, end)) 这样才是对的 python 中 单个字符不能和整数直接运算，不像C语言 注意， python 可以这样写 65 &lt;= ord(i) &lt;= 90 ，这是和C语言很不同的地方 import 模块：导入一个模块；注：相当于导入的是一个文件夹，是个相对路径。 from…import：导入了一个模块中的一个函数；注：相当于导入的是一个文件夹中的文件，是个绝对路径。 from…import *：是把一个模块中所有函数都导入进来; 注：相当于导入的是一个文件夹中所有文件，所有函数都是绝对路径。 from…import *语句与import区别在于： import 导入模块，每次使用模块中的函数都要是定是哪个模块。 from…import * 导入模块，每次使用模块中的函数，直接使用函数就可以了；注因为已经知道该函数是那个模块中的了。 一般来说，推荐使用 import 语句，避免使用 from … import，因为这样可以使你的程序更加易读，也可以避免名称冲突。 python用来计算微积分的库主要用的是sympy库 二分法求解方程的条件是，初始范围必须包含根 列表是个筐，什么都能往里装，甚至可以往里装语句，比如列表推导式：[expression for item in iterable], a = [i for i in range(0, 10)], 更有甚者，可以这样写 [表达式 for 变量 in 列表 if 条件]，a = [i for i in range(0, 10) if i % 2 == 0]，更有甚者，可以这样写 [表达式 for 变量 in 列表 if 条件 if 条件]， 还能这样用： group_labels = [’{}月’.format(i) for i in range(1, 13)]，显示1-12月的字符串列表 相应的，字典也有字典推导式 匿名函数只能写一个表达式，多了不行，不用写return，表达式的值会自动返回 map(function, iterable, …)，后面的iterable参数可以不止有1个。 map()函数，当有多个可迭代对象时，最短的可迭代对象耗尽则整个迭代就将结束。比如 min = map(min, L1, L2), 其中L1和L2是两个长度不同的列表，这个表达式的作用是依次取出L1和L2对应的元素并拿出小的那一个，当L1遍历完了，就会结束。 map(function, iterable,…)还可用于数据清洗 (i for i in range(0, 10) if i % 2 == 0) 这是生成器表达式，和列表推导式的区别就是把[]换成(),生成器遵循迭代器的协议，有惰性，需要的时候才去取数据，这样减少占用内存消耗，生成器对象也是可迭代的，需要取数据的时候，就用循环打印出来，比如： 123456a = (i for i in range(0, 10) if i % 2 == 0)print(a)# 打印不出来，因为我们还没写出需要用到生成器的句子for i in a: print(i)# 能打印出来，因为我们已经写出了需要生成器的句子 生成器用于数据量比较大的情况，否则就没必要 类是对象的模板或蓝图，类是对象的抽象化，对象是类的实例化。类不代表具体的事物，而对象表示具体的事物 创建函数的关键字是def，创建类的关键字是class， 构造器，迭代器，生成器，别搞混了，python中的构造器必须有，不同于java init()方法的self参数指向创建的实例本身，第一个参数，永远都是self，并且实例化的时候不用传入self的实参，解释器会自动传入 在类里面定义的方法，和普通的函数的唯一区别是，第一个参数是self，其他没有什么区别 文件写完一定要close，否则会占用内存，或者程序突然崩溃，那么文件就白写了 文件路径，win用\\，Unix用/ 文件对象不仅是一个可迭代的，它是一个迭代器，这就是为什么它只能遍历文件一次(读完后光标在文本最末位)。您可以使用.seek(0)重置文件光标，但在大多数情况下，您应该只迭代一次文件。 由于读写文件可能产生error，一旦出错，后面的f.close()可能不会被调用，可靠的方法是用with，不仅会自动关闭文件，而且出错了也能关闭 类里面的方法可以返回值 在 Python 中，有一个特殊的常量 None（N 必须大写）。和 False 不同，它不表示 0，也不表示空字符串，而表示没有值，也就是空值。 这里的空值并不代表空对象，即 None 和 []、“” 不同 None 有自己的数据类型，我们可以在 IDLE 中使用 type() 函数查看它的类型，执行代码如下：type(None) &lt;class ‘NoneType’&gt; 它属于 NoneType 类型。需要注意的是，None 是 NoneType 数据类型的唯一值（其他编程语言可能称这个值为 null、nil 或 undefined），也就是说，我们不能再创建其它 NoneType 类型的变量，但是可以将 None 赋值给任何变量。如果希望变量中存储的东西不与任何其它值混淆，就可以使用 None。除此之外，None 常用于 assert、判断以及函数无返回值的情况。举个例子，在前面章节中我们一直使用 print() 函数输出数据，其实该函数的返回值就是 None。因为它的功能是在屏幕上显示文本，根本不需要返回任何值，所以 print() 就返回 None。 spam = print(‘Hello!’) Hello! None == spam True 对于所有没有 return 语句的函数定义，Python 都会在末尾加上 return None，使用不带值的 return 语句（也就是只有 return 关键字本身），那么就返回 None。 Python中print函数中中逗号和加号的区别： print(“hello” + “world”) 输出：helloworld print(“hello”, “world”) 输出：hello world 这里发现加号的作用是连接字符串 而逗号相当于用空格连接字符串。 print(“hello” + 123)： 输出：TypeError: must be str, not int print(“hello”, 123) 输出：hello 123、 这里发现加号在Str类型与Num类型相加的出现了类型错误 逗号连接正常并返回字符串结果。 加号 + ：两边只能是相同数据类型，在Python中主要是运算符的存在，而字符串等类型相加只是Python中的内置方法。 逗号 , : 在这里逗号更多的代表用空格的连接。 当 + 号两边都是列表时，可以将两个列表拼起来 upper()方法遇到大写字母和其他字符时，都不做动作，只有碰见小写字母时才会做动作 str.upper()，返回原字符串的副本，这个方法会return一个新的字符串，但不会改动原来字符串的内容，如果单纯 str.upper() 再输出str, 发现str没有变化，但是str2 = str.upper()，就可以把改动后的新字符串保存在str2中 print() 输出单个换行符 二维数组的切片： 12345a = np.random.rand(3, 3)print(a)a[0:3, 0:3] = 3print()print(a) JAVA中构造方法，实例方法，类方法，有什么区别？ 构造方法：构造方法是用来构造类的对象的，方法名和类名相同没有返回值。一般用 new 构造方法名() 来创建该类的对象。在不写构造方法的情况下会有一个默认的无参构造方法，当然你也可以重写和重载构造方法。 实例方法：即：成员方法。简单地说就是可以通过类的实例（某个对象）调用的方法，也就是我们正常情况下使用的方法。 类方法：简单地说就是直接可以用类名调用的方法，也就是被关键字static修饰的方法，它不需要创建类的对象来调用该方法。 看到这里，我们明白了，python中的实例方法不是构造器，和java中的实例方法一样，但是java/C++中的静态方法、类方法和python中的静态方法、类方法可不一样， python 可以函数嵌套定义，但是C/C++语言不行 decorator的作用:在保证原本函数不改变的前提下，直接给这个函数增加一些功能 实例方法可以用实例对象调用，也可以用类去调用，当使用类去调用时注意要传入第一个参数 类方法可以用实例对象去调用，此时decorator会忽略实例对象而自动传入实例对象所属的类，也可以用类去调用 静态方法可以用实例对象调用也可以用类去调用 python类属性和实例属性不一样，举个例子 12class Person: age = 18 123class Person: def __init__(self): self.age = 18 前者的age是类属性，每一个Person对象都能访问到age这个类属性，但在Person的实例化对象中没法修改age的值，也就是说每个实例化对象的age都是18且只能是18， 但是后者那个age是实例属性，每一个Person对象自带age这个属性，但这个属性属于这个实例对象，修改其中一个实例对象的age不会影响其他实例对象的age值 这一点和java不一样 python set方法去修改私有属性，很多人觉得多此一举，本来把属性设置成私有就是为了不能随便改动它，又定义一个set方法去修改私有属性的值，那不是脱了裤子放屁吗？其实我们有时候设置成私有属性不是让它变得不可修改，而是让它变得不能被随意修改，因为修改它必须调用set方法，所以，我们可以在set方法里面加一些条件，让传进set方法里面的参数做一些限制，使得私有属性修改后的值是恰当的合理的。如果不用私有属性+set方法，直接在类外面就可以修改这个属性，那么我们想在模块的什么地方修改就能在模块的什么地方修改，这样的话麻烦就来了，在修改的那个地方必须做判定，即修改后的新值合不合理，在每个修改属性的地方都要做一个这样的判定，很麻烦，而且容易漏，(如果这个属性恰好是银行存款额，又忘记判定，就容易出事)所以属性修改，采用私有属性+set方法的形式，减少代码重复度，也不会有忘记的情况。这一点python和java是一样的 输入一个整形列表： 1n = list(map(int, input().split(&#x27;,&#x27;))) 切片有一个强大功能是给切片赋值，如果把切片放在赋值语句的左边，或把它作为del操作的对象，我们就可以对序列进行嫁接、切除或就地修改操作。能切片赋值是因为切片是对原iterable的视窗，是引用关系 python切片：超出索引范围的切片参数，可以看成把list以空元素延长，进行切片操作后，去掉空元素后得到结果，例如： 12345678910&gt;&gt;&gt; a[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]&gt;&gt;&gt; a[-100:5][0, 1, 2, 3, 4]&gt;&gt;&gt; a[5:100][5, 6, 7, 8, 9]&gt;&gt;&gt; a[-100:100][0, 1, 2, 3, 4, 5, 6, 7, 8, 9]&gt;&gt;&gt; a[100:1000][] 若start比stop大，则得到空list, 列表切片很有用，比如切片赋值操作： 12345678910111213141516171819202122232425&gt;&gt;&gt; l = list(&quot;0123456789&quot;)&gt;&gt;&gt; l[&#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;]&gt;&gt;&gt; l[6:] = list(&quot;abcdef&quot;) //类似append,add,extends等&gt;&gt;&gt; l [&#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;]&gt;&gt;&gt; l[5:8] = [&quot;g&quot;]&gt;&gt;&gt; l [&#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;g&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;]# 也可以不替换原有元素情况下加入新元素&gt;&gt;&gt; l = list(&quot;abcd&quot;)&gt;&gt;&gt; l [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]&gt;&gt;&gt; l[2:2] = list(&quot;12&quot;)&gt;&gt;&gt; l [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]# 再或者可以这样插入s = list(range(10))s[3:2] = [11, 12]print(s) # 输出[0, 1, 2, 11, 12, 3, 4, 5, 6, 7, 8, 9]# 删除元素&gt;&gt;&gt; l = list(range(10))&gt;&gt;&gt; l[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]&gt;&gt;&gt; del l[5:7] 当然，切片赋值，步长也可以不等于1，举例，给列表索引为偶数的元素排序 12n = list(map(int, input().strip(&#x27;[]&#x27;).split(&#x27;,&#x27;)))n[::2] = sorted(n[::2], reverse=True) 但是，切片赋值，给序列的切片部分新的赋值必须是可迭代类型，直接给列表切片赋一个整型会报错 遍历字典键值对最pythonic的方法就是是使用.items()方法。items() 方法把字典中每对 key 和 value 组成一个元组，并把这些元组放在列表中返回。 12for k,v in dict_1.items(): print(k,&quot;&gt;&gt;&quot;,v) 给字典按值排序： 1234s2 = sorted(s.items(), key=operator.itemgetter(1))# s是一个字典，sorted返回一个新列表，但是列表的元素是一个个包含键值对的元组# 或者用下面的匿名函数sorted(L, key=lambda x:x[1]) python 中 List.count 和 str.count 不一样，Python str.count() 方法用于统计字符串里某个字符或子字符串出现的次数。List.count(obj) 方法用于统计某个元素在列表中出现的次数。obj – 列表中统计的对象 找出列表中出现次数最多的元素： 12a = [1,2,3,4,2,3,2]maxlabel = max(a,key=a.count) Pandas保持了Numpy对关键字axis的用法 bool类型: 12345678&gt;&gt;&gt; bool(0)False&gt;&gt;&gt; bool(1)True&gt;&gt;&gt; bool(2)True&gt;&gt;&gt; issubclass(bool, int) # bool 是 int 子类True operator.eq(48, ‘0’) 用来比较两个对象是否相等，既会检查类型也会检查值 enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。 普通的for循环需要单独设置一个控制变量： 12345i = 0a = [&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;]for j in a: print(i, j) i += 1 但是用了enumerate就不需要了 123a = [&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;]for i, element in enumerate(a): print(i, element) filter() 函数用于过滤序列，过滤掉不符合条件的元素，返回一个迭代器对象，如果要转换为列表，可以使用 list() 来转换。该接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判断，然后返回 True 或 False，最后将返回 True 的元素放到新列表中。 12345def is_odd(n): return divmod(n, 2)[1] == 0b = range(10)print(list(filter(is_odd, b))) 输出： 1[0, 2, 4, 6, 8] python divmod() 函数把除数和余数运算结果结合起来，返回一个包含商和余数的元组(a // b, a % b) id()返回对象的内存地址 split() 通过指定分隔符对字符串进行切片，如果参数 num 有指定值，则分隔 num+1 个子字符串。 123str.split(str=&quot;&quot;, num=string.count(str))str -- 分隔符，默认为所有的空字符，包括空格、换行(\\n)、制表符(\\t)等。num -- 分割次数。默认为 -1, 即分隔所有。 input() 接收多个值: 1a,b,c = (input(&quot;请输入三角形三边的长：&quot;).split()) isinstance() 函数来判断一个对象是否是一个已知的类型，类似 type()。但是与type()又有不同：type() 不会认为子类是一种父类类型，不考虑继承关系。isinstance() 会认为子类是一种父类类型，考虑继承关系。如果要判断两个类型是否相同推荐使用 isinstance()。 len() 方法返回对象（字符、列表、元组等）长度或项目个数。 max() 方法返回给定参数的最大值，参数可以为序列。即参数可以不是数字 Python3 range() 函数返回的是一个可迭代对象（类型是对象），而不是列表类型， 所以打印的时候不会打印列表。 repr() 方法可以将读取到的格式字符，比如换行符、制表符，转化为其相应的转义字符。 123s = &quot;物品\\t单价\\t数量\\n包子\\t1\\t2&quot;print(s)print(repr(s)) 输出: 123物品 单价 数量包子 1 2&#x27;物品\\t单价\\t数量\\n包子\\t1\\t2&#x27; reversed 函数参数是一个iterable，返回一个返回一个反转的迭代器。list.reverse() 函数用于反向列表中元素。 join() 方法用于将序列中的元素以指定的字符连接生成一个新的字符串。str.join(sequence)，sequence – 要连接的元素序列。 12seqString = &#x27;Runoob&#x27;print(&quot;&quot;.join(list(reversed(seqString)))) round() 方法返回浮点数 x 的四舍五入值，准确的说保留值将保留到离上一位更近的一端（四舍六入）。 dict和set都是{}包裹，但是创建一个空{}代表空dict，因为dict更常用 12print(type(&#123;1, 2, 3&#125;))print(type(&#123;1: a, 2: b&#125;)) 输出: 12&lt;class &#x27;set&#x27;&gt;&lt;class &#x27;dict&#x27;&gt; slice 对象用于指定如何对序列进行裁切。您可以指定在哪里开始裁切以及在哪里结束裁切。您还可以指定步进，slice(start, end, step)。返回 slice 对象 sorted() 函数对所有可迭代的对象进行排序操作。sorted(iterable, cmp=None, key=None, reverse=False)，返回一个新的重新排序的列表。该函数可以将字典按照键或者值排序 iterable – 可迭代对象。 key – 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。 reverse – 排序规则，reverse = True 降序 ， reverse = False 升序（默认）。 sort 与 sorted 区别： sort 是应用在 list 上的方法，sorted 可以对所有可迭代的对象进行排序操作。 list函数和list方法的区别: list 的 sort 方法返回的是对已经存在的列表进行操作，而内建函数 sorted 方法返回的是一个新的 list，而不是在原来的基础上进行的操作。 123&gt;&gt;&gt; students = [(&#x27;john&#x27;, &#x27;A&#x27;, 15), (&#x27;jane&#x27;, &#x27;B&#x27;, 12), (&#x27;dave&#x27;, &#x27;B&#x27;, 10)]&gt;&gt;&gt; sorted(students, key=lambda s: s[2]) # 按年龄排序[(&#x27;dave&#x27;, &#x27;B&#x27;, 10), (&#x27;jane&#x27;, &#x27;B&#x27;, 12), (&#x27;john&#x27;, &#x27;A&#x27;, 15)] sum() 方法对序列进行求和计算:sum(iterable[, start]): iterable – 可迭代对象，如：列表、元组、集合。 start – 指定相加的参数，如果没有设置这个值，默认为0 12&gt;&gt;&gt; sum([0,1,2,3,4], 2) # 列表计算总和后再加 212 zip() 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的对象，这样做的好处是节约了不少的内存。我们可以使用 list() 转换来输出列表。如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同，利用 * 号操作符，可以将元组解压为列表。 原始字符串 - 原始字符串：所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。 原始字符串除在字符串的第一个引号前加上字母 r（可以大小写）以外，与普通字符串有着几乎完全相同的语法。 12print( r&#x27;\\n&#x27; )print( R&#x27;\\n&#x27; ) endswith() 方法用于判断字符串是否以指定后缀结尾，如果以指定后缀结尾返回 True，否则返回 False。可选参数 “start” 与 “end” 为检索字符串的开始与结束位置。str.endswith(suffix[, start[, end]]) suffix – 该参数可以是一个字符串或者是一个元素。 start – 字符串中的开始位置。 end – 字符中结束位置。 find()方法和index()一样，只不过find()方法检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回-1； index()方法str不在字符串中会报一个异常。 rfind() 返回字符串最后一次出现的位置，如果没有匹配项则返回-1。rindex() 返回子字符串 str 在字符串中最后出现的位置，如果没有匹配的字符串会报异常，你可以指定可选参数[beg:end]设置查找的区间。 rjust() 返回一个原字符串右对齐,并使用空格填充至长度 width 的新字符串。如果指定的长度小于字符串的长度则返回原字符串。ljust() 方法返回一个原字符串左对齐,并使用空格填充至指定长度的新字符串。如果指定的长度小于原字符串的长度则返回原字符串。 isdigit() 方法只对正整数有效，负数及小数均返回不正确。 isdigit() True: Unicode数字，byte数字（单字节），全角数字（双字节），罗马数字 False: 汉字数字 Error: 无 isdecimal() True: Unicode数字，，全角数字（双字节） False: 罗马数字，汉字数字 Error: byte数字（单字节） isnumeric() True: Unicode数字，全角数字（双字节），罗马数字，汉字数字 False: 无 Error: byte数字（单字节） str.maketrans 返回一个可以用于 str.translate 函数中的翻译表，就是返回一个对照表table，这个对照表可以被translate利用。 str.translate(table) 函数使用 table 作为翻译表，对原字符串中的内容进行替换， 123456789101112# 字母 R 替换为 Ntxt = &quot;Runoob!&quot;mytable = txt.maketrans(&quot;R&quot;, &quot;N&quot;)print(txt.translate(mytable))# 使用字符串设置要替换的字符，一一对应intab = &quot;aeiou&quot;outtab = &quot;12345&quot;trantab = str.maketrans(intab, outtab)str = &quot;this is string example....wow!!!&quot;print (str.translate(trantab)) 输出: 12Nunoob!th3s 3s str3ng 2x1mpl2....w4w!!! max() 也可以返回字符串中最大的字母。min()同理 str.splitlines([keepends]) 按照行(’\\r’, ‘\\r\\n’, \\n’)分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。 1234&gt;&gt;&gt; &#x27;ab c\\n\\nde fg\\rkl\\r\\n&#x27;.splitlines()[&#x27;ab c&#x27;, &#x27;&#x27;, &#x27;de fg&#x27;, &#x27;kl&#x27;]&gt;&gt;&gt; &#x27;ab c\\n\\nde fg\\rkl\\r\\n&#x27;.splitlines(True)[&#x27;ab c\\n&#x27;, &#x27;\\n&#x27;, &#x27;de fg\\r&#x27;, &#x27;kl\\r\\n&#x27;] startswith() 方法用于检查字符串是否是以指定子字符串开头，如果是则返回 True，否则返回 False。startswith() 方法用于检查字符串是否是以指定子字符串开头，如果是则返回 True，否则返回 False。 swapcase() 方法用于对字符串的大小写字母进行转换，即将大写字母转换为小写字母，小写字母会转换为大写字母。lower() 方法转换字符串中所有大写字符为小写。upper() 方法将字符串中的小写字母转为大写字母。 title() 方法返回&quot;标题化&quot;的字符串,就是说所有单词的首个字母转化为大写，其余字母均为小写.istitle() 方法检测字符串中所有的单词拼写首字母是否为大写，且其他字母为小写。 可以使用 del 语句来删除列表的的元素 list.remove(obj) 函数用于移除列表中某个值的第一个匹配项。obj – 列表中要移除的对象。 列表对 + 和 * 的操作符与字符串相似。+ 号用于组合列表，* 号用于重复列表。元组同理 index() 函数用于从列表中找出某个值第一个匹配项的索引位置.与字符串的index()方法类似 list.insert(index, obj) 函数用于将指定对象插入列表的指定位置。 list.remove(obj) 函数用于移除列表中某个值的第一个匹配项。obj – 列表中要移除的对象。 list.copy()返回复制后的新列表。 元组只有一个元素时，后面往往跟个逗号，这是为什么呢？消除歧义，比如tup1=(50，) del tinydict[‘Name’] # 删除键 ‘Name’ tinydict.clear() # 清空字典 del tinydict # 删除字典 dict的键不可变，所以键所以可以用数字，字符串或元组充当，而用列表就不行 dict.fromkeys(seq[, value]) 函数用于创建一个新字典，以序列 seq 中元素做字典的键，value 为字典所有键对应的初始值。这种方式可以把列表利用起来用来创造字典，比一个一个输方便，比如： 1234567seq = (&#x27;name&#x27;, &#x27;age&#x27;, &#x27;sex&#x27;) tinydict = dict.fromkeys(seq)print (&quot;新的字典为 : %s&quot; % str(tinydict)) tinydict = dict.fromkeys(seq, 10)print (&quot;新的字典为 : %s&quot; % str(tinydict)) 输出: 12新的字典为 : &#123;&#x27;age&#x27;: None, &#x27;name&#x27;: None, &#x27;sex&#x27;: None&#125;新的字典为 : &#123;&#x27;age&#x27;: 10, &#x27;name&#x27;: 10, &#x27;sex&#x27;: 10&#125; 下面这种利用 zip()的方法也可以快速创造字典: 123a = list(range(1, 6))b = [&#x27;手机&#x27;, &#x27;电脑&#x27;, &#x27;平板&#x27;, &#x27;数据线&#x27;, &#x27;充电宝&#x27;]s = dict(zip(a, b)) dict.keys()、dict.values() 和 dict.items() 返回的都是视图对象（ view objects），提供了字典实体的动态视图，这就意味着字典改变，视图也会跟着变化。视图对象不是列表，不支持索引，可以使用 list() 来转换为列表。我们不能对视图对象进行任何的修改，因为字典的视图对象都是只读的。 1234dishes = &#123;&#x27;eggs&#x27;: 2, &#x27;sausage&#x27;: 1, &#x27;bacon&#x27;: 1, &#x27;spam&#x27;: 500&#125;print(dishes.items())print(dishes.keys())print(dishes.values()) 输出: 123dict_items([(&#x27;eggs&#x27;, 2), (&#x27;sausage&#x27;, 1), (&#x27;bacon&#x27;, 1), (&#x27;spam&#x27;, 500)])dict_keys([&#x27;eggs&#x27;, &#x27;sausage&#x27;, &#x27;bacon&#x27;, &#x27;spam&#x27;])dict_values([2, 1, 1, 500]) dict.get(key[, value]) 返回指定键的值，如果键不在字典中返回默认值 None 或者设置的默认值。dict.setdefault(key, default=None) 方法和 get()方法 类似, 如果键不存在于字典中，将会添加键并将值设为默认值。 dict.update(dict2)用来合并两个字典 列表、元组、字典中都没有add()方法，只有集合中有 set1.difference_update(set2) 方法与 difference() 方法的区别在于 difference() 方法返回一个移除相同元素的新集合，而 difference_update() 方法是直接在原来的集合中移除元素，没有返回值。 集合中set.pop()随机移除一个元素，因为集合是无序的，这与其他iterable不同，其他pop一般是移除最后一个元素或移除指定的元素 set.isdisjoint(set)方法用于判断两个集合是否包含相同的元素，如果没有返回 True，否则返回 False。 symmetric_difference(), 此时再体会一下symmetric的含义就清楚了，对称的，所以返回的新set的元素：包含在a中，并且不包含在集合b中 + 包含在b中，并且不包含在集合a中。这么解释反而复杂了，其实简单来说就是去重。类似合并 demo[1::2] 切片步长的理解:步长为2即，从当前元素的下一个元素起，向下数 步长 个数字对应的元素 与列表一样，元组中的元素类型也可以不相同. Python 3.6 改写了 dict 的内部算法，因此 3.6 的 dict 是有序的，在此版本之前皆是无序。而恰好《Python 编程从入门到实践》这本书就是用 Python 3.5 版本 for _ in range(n)仅将循环运行n次，等效于for i in range(n)，只不过_在后面不会用到，只是占位符，这里的_可以替换成任何符合规定的字符串。标识符可以由字母、数字、下画线（_）组成，其中数字不能打头。这里 _ 和 i 是一样的 bj_PM_mean = pursue_mean.df_bj.loc[pursue_mean.df_bj[‘PM_mean’].notnull(), [‘PM_mean’]].meam() // loc[]里面括住的，左边代表行标签，右边还有个 [],里面是列标签 bj_PM_mean = pursue_mean.df_bj.loc[pursue_mean.df_bj[‘PM_mean’].notnull(), [‘PM_mean’]].mean() 返回的是一个对象，想取值则 bj_PM_mean.PM_mean 若只想从别的py文件导入某个变量，则可以这样写: from 文件名 import 变量名 from pyecharts import options as opts 使用 from …… import …… 的形式也能 as 别名 pyecharts要求int类型的数据，若是浮点数，则画的柱状图无法显示数据 DataFrame 合并索引的方法之一，可以把要合并的列的数据类型转为字符串，然后用 + 号连接成一个新的列索引","categories":[],"tags":[]},{"title":"尝试一下Markdown","slug":"markdown-learn","date":"2022-07-22T07:42:10.000Z","updated":"2022-08-02T02:24:28.964Z","comments":true,"path":"2022/07/22/markdown-learn/","link":"","permalink":"http://example.com/2022/07/22/markdown-learn/","excerpt":"","text":"尝试一下Markdown （很久没有写作了看起来像小学生作文😂） Markdown是什么 Markdown是一种非常简单的轻量级标记语言，并不是一门编程语言。 我们平时在用word时经常会关注formatting，也就是它的各种格式，但在写一些注重语义的文章时，比如博文，纷杂的格式显得没那么重要，而markdown可以让我们专注于semantics。 Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。 当前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、简书、reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge等。 John Gruber在2004年创造了Markdown语言，在语法上有很大一部分是跟亚伦·斯沃茨（Aaron Swartz）共同合作的。这个语言的目的是希望大家使用“易于阅读、易于撰写的纯文字格式，并选择性的转换成有效的XHTML（或是HTML）”。 其中最重要的设计是可读性，也就是说这个语言应该要能直接在字面上的被阅读，而不用被一些格式化指令标记（像是RTF与HTML）。 因此，它是现行电子邮件标记格式的惯例，虽然它也借鉴了很多早期的标记语言，如：Setext、Texile、reStructuredText。 使用VSCode开始Markdown写作 VSCode（全称：Visual Studio Code）是一款由微软开发且跨平台的免费源代码编辑器。VSCode 是当下非常流行的代码编辑器，它的界面看起来高级且拥有丰富的拓展。而且，VSC天然支持Markdown，所以用起来非常丝滑。 一些编辑器 Windows Typora、Simplenote、Laverna、Boostnote、Inkdrop、Cmd Markdown、Github、马克飞象、Yu Writer、看云、有道云笔记、为知笔记、蚂蚁笔记 MacOS Typora、Typed、Ulysses、Falcon Linux Typora、Atom、GNU Emacs、Remarkable、Haroopad、ReText、UberWriter、Mark My Words Android Draft、JotterPad X、坚果云Markdown iOS Byword、simplenote、坚果云Markdown 写一些 LaTeX 公式 在这写一段公式 ∫dxa2−x2=12aln⁡a+xa−x+C\\int \\frac{d x}{a^{2}-x^{2}}=\\frac{1}{2 a} \\ln \\frac{a+x}{a-x}+C∫a2−x2dx​=2a1​lna−xa+x​+C 哈哈哈哈哈哈哈 再来一个！ f(t)=a0+∑n=1∞[ancos⁡(nωt)+bnsin⁡(nωt)]a0=1T∫t0t0+Tf(t)dtan=2T∫t0t0+Tf(t)cos⁡(nωt)dt,bn=2T∫t0t0+Tf(t)sin⁡(nωt)dtf(t)=c0+∑n=1∞cncos⁡(nωt+ϕn)an=cncos⁡ϕn,bn=−cnsin⁡ϕntan⁡ϕn=−bnan\\begin{gathered} f(t)=a_{0}+\\sum_{n=1}^{\\infty}\\left[a_{n} \\cos (n \\omega t)+b_{n} \\sin (n \\omega t)\\right] \\\\ a_{0}=\\frac{1}{T} \\int_{t_{0}}^{t_{0}+T} f(t) \\mathrm{d} t \\\\ a_{n}=\\frac{2}{T} \\int_{t_{0}}^{t_{0}+T} f(t) \\cos (n \\omega t) \\mathrm{d} t, b_{n}=\\frac{2}{T} \\int_{t_{0}}^{t_{0}+T} f(t) \\sin (n \\omega t) \\mathrm{d} t \\\\ f(t)=c_{0}+\\sum_{n=1}^{\\infty} c_{n} \\cos \\left(n \\omega t+\\phi_{n}\\right) \\\\ a_{n}=c_{n} \\cos \\phi_{n}, b_{n}=-c_{n} \\sin \\phi_{n} \\\\ \\tan \\phi_{n}=-\\frac{b_{n}}{a_{n}} \\end{gathered} f(t)=a0​+n=1∑∞​[an​cos(nωt)+bn​sin(nωt)]a0​=T1​∫t0​t0​+T​f(t)dtan​=T2​∫t0​t0​+T​f(t)cos(nωt)dt,bn​=T2​∫t0​t0​+T​f(t)sin(nωt)dtf(t)=c0​+n=1∑∞​cn​cos(nωt+ϕn​)an​=cn​cosϕn​,bn​=−cn​sinϕn​tanϕn​=−an​bn​​​ (偷偷用了Mathpix Snipping Tool) 来个表格 Markdown语法 详解 效果 斜体 无 斜体 粗体 无 粗体 插入链接 此处是一个链接 一串code 1234def check_anagram(first_word, second_word): return sorted(first_word) == sorted(second_word)print(check_anagram(&quot;silent&quot;, &quot;listen&quot;)) # Trueprint(check_anagram(&quot;ginger&quot;, &quot;danger&quot;)) # False See u again !","categories":[],"tags":[]},{"title":"HTML中表单的input标签 name属性有无[]的区别","slug":"form_name_Problem","date":"2022-07-22T07:42:10.000Z","updated":"2022-10-13T07:26:24.154Z","comments":true,"path":"2022/07/22/form_name_Problem/","link":"","permalink":"http://example.com/2022/07/22/form_name_Problem/","excerpt":"","text":"先看链接 我们来看这段代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;大卖场&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;#&quot; method=&quot;post&quot;&gt; &lt;center&gt;注册账号&lt;/center&gt; &lt;table align=&quot;center&quot; border=&quot;1&quot;&gt; &lt;tr&gt; &lt;td&gt;用户名:&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;content[username]&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;email:&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;content[email]&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码:&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;content[pwd]&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;确认密码:&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;content[confirm_pwd]&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;性别:&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;radio&quot; name=&quot;content[sex]&quot; value=&quot;男&quot;&gt;男 &lt;input type=&quot;radio&quot; name=&quot;content[sex]&quot; value=&quot;女&quot; checked&gt;女 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;手机号码:&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;content[phone]&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;喜欢的编程技术:&lt;/td&gt; &lt;td&gt; &lt;select name=&quot;content[loveLanguage]&quot;&gt; &lt;option selected&gt;PHP&lt;/option&gt; &lt;option &gt;Python&lt;/option&gt; &lt;option&gt;Java&lt;/option&gt; &lt;option&gt;C&lt;/option&gt; &lt;option&gt;C++&lt;/option&gt; &lt;option&gt;Go&lt;/option&gt; &lt;option&gt;Rust&lt;/option&gt; &lt;option&gt;C#&lt;/option&gt; &lt;/select&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td COLSPAN=&quot;2&quot;&gt; &lt;input type=&quot;checkbox&quot; checked name=&quot;content[check]&quot;&gt;我已经看过并接受&lt;a href=&quot;https://www.bilibili.com/&quot; target=&quot;_blank&quot;&gt; &lt;b&gt;用户协议&lt;/b&gt;&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;立即注册&quot; name=&quot;bnt&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/form&gt; &lt;?php if (isset($_POST[&quot;bnt&quot;])) &#123; if (isset($_POST[&quot;content&quot;][&quot;check&quot;])) &#123; if ($_POST[&quot;content&quot;][&quot;username&quot;] == &quot;&quot; || $_POST[&quot;content&quot;][&quot;email&quot;] == &quot;&quot; || $_POST[&quot;content&quot;][&quot;pwd&quot;] == &quot;&quot; || $_POST[&quot;content&quot;][&quot;confirm_pwd&quot;] == &quot;&quot; || $_POST[&quot;content&quot;][&quot;sex&quot;] == &quot;&quot; || $_POST[&quot;content&quot;][&quot;phone&quot;] == &quot;&quot; || $_POST[&quot;content&quot;][&quot;loveLanguage&quot;] == &quot;&quot;) &#123; echo &quot;不能有不填的！&quot; or exit(&quot;回去填&quot;); &#125;else &#123; echo &quot;你好&quot;; echo &quot;用户名:&quot;.$_POST[&quot;content&quot;][&quot;username&quot;].&quot;&lt;br&gt;&quot;; echo &quot;邮箱:&quot;.$_POST[&quot;content&quot;][&quot;email&quot;].&quot;&lt;br&gt;&quot;; echo &quot;密码:&quot;.$_POST[&quot;content&quot;][&quot;pwd&quot;].&quot;&lt;br&gt;&quot;; echo &quot;确认密码:&quot;.$_POST[&quot;content&quot;][&quot;confirm_pwd&quot;].&quot;&lt;br&gt;&quot;; echo &quot;性别:&quot;.$_POST[&quot;content&quot;][&quot;sex&quot;].&quot;&lt;br&gt;&quot;; echo &quot;手机号:&quot;.$_POST[&quot;content&quot;][&quot;phone&quot;].&quot;&lt;br&gt;&quot;; echo &quot;你喜欢的编程预言:&quot;.$_POST[&quot;content&quot;][&quot;loveLanguage&quot;].&quot;&lt;br&gt;&quot;; &#125; &#125; &#125; ?&gt;&lt;/body&gt;&lt;/html&gt; 如果写成 $_POST[“content[check]”] 就是错误的，因为这种索引形式没法索引二维数组。","categories":[],"tags":[]},{"title":"数据科学导论理论课期末复习","slug":"DS_Intro","date":"2022-07-22T07:42:10.000Z","updated":"2023-03-17T01:37:11.048Z","comments":true,"path":"2022/07/22/DS_Intro/","link":"","permalink":"http://example.com/2022/07/22/DS_Intro/","excerpt":"","text":"第一章 数据科学definition: 从数据形成知识的过程，通过假设猜想，分析建模，从数据中发现可用知识，进而改进关键决策的过程 数据科学的最终产物: 数据产品 数据科学的知识结构： 专业领域知识: 领域专家能提出更具体的问题，领域知识在数据科学中占主导地位 数学: 数学家是团队中解决问题的人 计算机科学: 数据分析通过计算机程序实现 数据科学的关键步骤: 问题描述: 提需求 数据准备: 数据清洗 数据探索: 数据可视化 预测建模；机器学习 分析成果应用: 落地 数据科学的关键技术 数据采集: 人工采集: 互联网问卷调查 传感器采集: 智慧水务 系统日志采集: 服务器日志 网络爬虫采集: hacker 数据预处理: 数据清洗 数据集成: 集成到一个数据集里面，比如集成到一个csv文件中 数据变换: 比如归一化，比如独热矩阵 数据存储与管理: 文件系统 数据库 数据分析 第二章 多维数组运算: 使用广播机制， 第三章 数据汇总与统计 是数据探索的重要方法 (数据探索在第一章出现在数据科学的关键步骤里) 数据可视化是数据探索的重要方法 统计是对数据资料获取、整理、分析、描述、推断方法的总称 常用统计量: 均值 中位数 众数 方差 标准差 协方差 最大值 最小值 频率 分位数: 将样本从小到大排序，然后分成4等份，处于1/4处位置的是上四分位数，处于1/2位置的是中位数，处于3/4位置的是下四分位数 pandas基于Numpy，但增加了2种新型数据结构 Series DateFrame 数据文件的读写； pd.read_csv() 保存csv文件: pd.to_csv() 数据清洗: 对采集数据进行重新审查和校验的过程 第四章 pandas封装了Matplotlib的主要绘图功能，利用 Serier 和 DateDrame 数据结构快速画图，但是精准绘图还是得看 Matplotlib pandas的plot 常用参数: kind: line: 折线图 bar：垂直柱状图 barh：水平柱状图 histogram: 直方图 box: 箱型图 kde: 核密度估计图 density；同kde pie: 饼图 scatter；散点图 color: b: blue r；red c: cyan g: green k: black m: magenta w: white y: yellow alpha: 0-1, 表示图片透明度 linestyle: ‘-’: 实线 ‘–’: 破折线 ‘-.’: 点画线 ‘:’: 虚线 dashed: 虚线 柱状图分类: 按排列方式不同: 垂直柱状图 水平柱状图 按表达总体个数的不同； 单式柱状图 复式柱状图 多个总体叠加一起: 堆叠柱状图 直方图和柱状图的区别: histogram 横坐标轴按区间个数等分，长方形高度表示频率，面积表示频数 bar 横坐标为离散值，柱体高度表示对应数据值 histogram 横轴坐标为连续值，一个柱体表示一个区间对应的样本个数，柱体间无分隔。bar 柱体间有分隔 密度图(Kernel Density Estimate kde)采用平滑的峰值函数(简称 核)来拟合概率密度函数 第五章 机器学习分为有监督学习和无监督学习 有监督学习: 分为分类问题和回归问题: 分类问题: 类别的数量是已知的 回归问题: 预测目标是连续变量 无监督学习: 分为数据降维和聚类 数据降维: 对特征数量进行压缩，减少无关特征项的干扰 聚类: 与分类问题的区别是事先不知道类别的数量 常用回归方法: 线性回归 逻辑回归 多项式回归 回归分析性能指标 均方根误差(root mean squared error) 决定系数(R^2) 模型的决定系数 R^2 表示 模型中的目标变量的真实值有百分之多少能用自变量解释 常用分类方法: 决策树 贝叶斯分类 KNN 支持向量机 神经网络 集成学习 分类性能指标 混淆矩阵 accuracy precision recall F1 如果想提高precision，势必要严格正例的筛选条件，那么会造成recall下降，因此F1作为评价标准具有更高的实用价值 每次在样本特征集中选择最合适的特征项作为分支节点是决策树构造的核心 分类中的 SVM 常用核函数； 线性核函数: linear 多项式核函数: poly 高斯核函数；rbf sigmoid: Logistic 常用聚类方法； 划分 层次 基于密度聚类 基于图/网格聚类 聚类性能指标 有分类标签: 兰德指数，取值0-1，越接近1越好 无分类标签: 轮廓系数，取值 -1-1，越大越好 聚类的 K-means 算法原理: 假定划分簇数k 从数据集任选 k 个样本作为各个簇中心 根据每个样本与簇中心的距离相似度，将数据集中的每个样本划分到与其最相似的簇中 计算每个簇的中心 不断重复直到每个簇的中心不再变化 常用数据降维方法: 特征选择: 特征虽然减少但不改变特征 过滤法 包装法 嵌入法 特征提取: 特征减少且有新特征出现 线性方法: 线性变换 非线性方法: 非线性变换 数据降维的主成分分析算法: 计算样本矩阵的协方差矩阵，得到由特征值组成的特征向量，选择特征值最大的k个特征所对应的特征向量，构成新的特征矩阵 常用集成学习算法 Bagging算法(并行): 随机森林算法 Boosting算法(串行): Gradient Boosting GBDT 随机森林常见的组合策略: 对数值型采用平均或加权平均 对分类采用投票法 梯度提升机计算复杂度比bagging高 第六章 人造神经元也称为感知器(perception) 感知器由输入节点，输出节点，权重连接线组成 单个感知器只能处理线性可分问题，多层神经元可以处理线性不可分问题 激活函数的作用: 线性模型的表达能力不够，引入激活函数，添加非线性因素 输入层和输出层之间的神经元称之为隐藏层 神经网络的参数: 偏置项 连接权值 神经网络的激活函数: sigmoid tanh relu 拥有多个隐藏层，每层神经元与下一层神经元全连接，同层神经元之间不连接，也没有跨层神经元连接，称之为 多层前馈神经网络 神经网络的计算量与神经元数量的平方呈正比 优化权重算法: adam: 在大数据集上效果好 lbfgs: 收敛快 sgd；参数调整较优则有最佳表现 神经网络需要的训练时间远大于别的机器学习模型 深度学习: 具有多层隐藏层，并且每个隐藏层都有很多个节点的神经网络 其他的机器学习方法，比如 决策树，SVM，朴素贝叶斯 称为浅层学习 深度学习在实现有监督学习时，构建的网络分2部分: 特征提取 递归神经网络 长短期记忆网络 预测网络 其他机器学习方法 二分类问题仅仅需要一个输出节点； 多分类问题按输出类型数设置节点数，每个节点的输出值代表输入数据属于该节点的概率，总和为1 回归问题的输出层只有一个节点 基于 Keras 训练神经网络模型，按照以下3个步骤: 定义神经网络的结构 定义神经网络的损失函数，优化器，性能评估指标，并编译模型 使用数据集训练模型 第七章 文本处理常见任务: 文本分类 信息检索 信息抽取 自动问答 机器翻译 自动摘要 文本处理的基本步骤: 文本采集: 爬虫 文本预处理: 分词 特征提取与特征选择: 词袋模型、TF-IDF模型、词向量模型 序列建模分析 中文分词方法: 基于词典的分词方法 基于统计的分词方法 jieba的3种分词模式: 精确模式 全模式 搜索引擎模式 如果某个词在特点文档中是高频词，但在整个文档集中是低频词，那么该词的TF-IDF较高 第八章 像素有2个含义 像素是数字图像的最小单位 像素也被用来表示整幅图像的网格数 数字图像的类型: 二值图像: 0代表黑，1代表白，用1位二进制表示 灰度图像: 取值0-225，0代表黑，225代表白，用8位二进制表示 RGB图像: 用24位二进制表示 数字图像处理: 图像变换: 小波变换 图像增强和复原: 去除噪声 图像重建: CT 图像编码: 图像压缩 图像识别: 人脸识别 因为图像处理的数据量特别大，所以不能用前面的多层前馈神经网络，这才发明了卷积神经网络，专门用于数字图像处理 卷积层: 卷积单元的一组连接共享一个权重，这种方式极大地减少隐藏层的数量 池化层: 将若干个卷积层节点划分为一个区域，将最大值或平均值作为新的特征值，减少隐藏层节点数，加快计算速度，防止过拟合 使用卷积神经网络无需对图像进行复杂的预处理 第九章 时序数据: 连续观察同一对象在不同时间点上获得的数据样本集 时序数据的观察值的主要要素 趋势性: 受根本因素影响 平稳时间序列: 均值和方差为常数 非平稳时间序列 循环性 季节性: 波动性； 时序书局举例: 地震波、金融数据、语音信号、心电信号 时序数据的特征提取方法: 基于统计方法的特征提取 基于模型的特征提取 基于变换的特征提取 基于分形理论的特征提取 时序数据分析模型: 线性模型: 适用于平稳时间序列 适用于经过差分可以转化为平稳时间序列的非平稳时间序列 非线性模型: 计算量远大于线性模型 经过差分仍不能转为平稳时间序列的非平稳时间序列 处理时序数据的神经网络是: 循环神经网络(数字图像处理是卷积神经网络) 循环神经网络中: 计算隐藏的特征: RNN 参数最少 LSTM 最复杂, 参数最多 GRU 是简化的LSTM 语音识别技术的框架: 前端模块: 端点检测、降噪 后端模块: 利用训练好的模型进行模式识别 语音识别过程: 语音帧-&gt;状态-&gt;音素-&gt;单词发音 第十章 大数据特征 规模性 高速性 多样性 高价值性","categories":[],"tags":[]},{"title":"志老师的操作系统","slug":"OS_Learn","date":"2022-07-22T07:42:10.000Z","updated":"2023-03-21T07:50:26.214Z","comments":true,"path":"2022/07/22/OS_Learn/","link":"","permalink":"http://example.com/2022/07/22/OS_Learn/","excerpt":"","text":"实验成绩就看实验报告，实验报告成绩取平均 第1章 计算机五大组成部分: 运算器 控制器 存储器 输入设备 输出设备 运算器+控制器 统称为CPU 存储器是主存 计算机系统层次结构 软件 应用软件 系统软件 编辑软件，编译软件 操作系统 硬件及固件(裸机) OS是计算机硬件、软件资源的管理者 管理的obj: CPU 存储器 外部设备 信息(数据和软件) 管理的content: 资源的当前状态(数量和使用情况) 资源的分配、回收和访问 相应管理策略(包括用户权限) OS是用户使用系统硬件、软件的接口 系统命令 命令行 菜单式 命令脚本式 图形用户接口GUI 系统调用(会编程和不会编程的区别) 第2章 系统启动的过程，就是把内核从硬盘调到内存的过程","categories":[],"tags":[]},{"title":"C++学习tips","slug":"C_Plus_Plus_Tips","date":"2022-07-22T07:42:10.000Z","updated":"2023-03-21T14:37:39.724Z","comments":true,"path":"2022/07/22/C_Plus_Plus_Tips/","link":"","permalink":"http://example.com/2022/07/22/C_Plus_Plus_Tips/","excerpt":"","text":"C++中比较大小的表达式中，小于号和大于号都是不能连着打的，要用&amp;&amp;连接起来，这一点不同于日常的数学表达式，例如if（a &lt; b &lt; c）或者if（0 &lt; a &lt; 100）都是不正确的写法。这一点与C语言一样 class 相当于开发零件 #include 是 #include&lt;stdio.h&gt; 在C里的规范写法，其中c代表C语言，C头文件没有.h namespace 名字空间可以有多个，初学者先使用 std 这个标准的名字空间, (名字空间)详解 cin 表示字符设备，在字符设备中流入a 即 cin&gt;&gt;a，流入b即 cin&gt;&gt;b cout表示屏幕，a流向屏幕 cout &lt;&lt; a ，cout本身也是个对象，cout的类是ostream, cout &lt;&lt; a 等价于 cout.show(a) 结构体一般只包含成员变量，但是C++的class可以包含方法，变量一般只有数据，但是对象还有方法 C中的运算符可以看作一个函数，例如 &lt;&lt; ，自己也可以定义运算符，使用关键字operator，C可以把某个运算符看作函数名，这样就可以自己把函数名换做容易理解的运算符，这就是操作符重载(override)，C++里的 String 也是操作符重载。 重载 &lt;&lt; : ostream &amp; operator &lt;&lt; (ostream &amp; mycout, fraction x) class访问运算符默认是private， 有的器官只需自己使用，比如五脏，这样的器官可以做成private，不给别人看，也没必要给别人看，用来保护内部成员。但是有些器官比如手，眼睛，皮肤，需要给外界使用，所以这些器官写出public，private 和 publlic 可以交替写，比如先写private 再写publuic 再写private 内部成员之于class的方法来说是全局变量，所以方法可以直接访问全局变量 自然语言中有多态的现象，比如 我打你 ，调用伤害函数，我打游戏，调用打游戏函数，即同一个函数名，在不同的上下文中对应不同的函数体与函数功能，比如除号 / int / int 执行整数除法，double / int 执行小数除法，fraction / fraction 则自动调用我们自己定义的 class 里的 / 函数。这种多态可以降低用户的使用门槛 cout 和 cin 都是 C++ 的内置对象，而不是关键字.只不过它们是由标准库的开发者提前创建好的，可以直接拿来使用。这种在 C++ 中提前创建好的对象称为内置对象。 endl表示换行，与C语言里的\\n作用相同。当然代码中也可以用\\n来替代endl 。endl 最后一个字符是字母“l”，而非阿拉伯数字“1”，它是“end of line”的缩写。 若 cin&gt;&gt;(int型)，若输是小书，则会强制转换成整型赋给变量 输入运算符&gt;&gt;在读入下一个输入项前会忽略前一项后面的空格，所以数字 8 和 7.4 之间要有一个空格，当 cin 读入 8 后忽略空格，接着读取 7.4。 意源文件的后缀，.c是C语言代码，.cpp是C++代码，它们的编译方式不同。 C语言并没有彻底从语法上支持“真”和“假”，只是用 0 和非 0 来代表。这点在 C++ 中得到了改善，C++ 新增了 bool 类型（布尔类型），也就是说C语言没有bool类型，但是C有。它一般占用 1 个字节长度。bool 类型只有两个取值，true 和 false：true 表示“真”，false 表示“假”。但是在 C 中使用 cout 输出 bool 变量的值时还是用数字 1 和 0 表示，而不是 true 或 false。Java、PHP、JavaScript 等也都支持布尔类型，但输出结果为 true 或 false。但在C++中仍可以使用 true 或 false 显式地对 bool 变量赋值，比如 bool flag = true; true 和 false 是 C++ 中的关键字，true 表示“真”，false 表示“假”。以后可以直接 return true; 或 return false; 对函数作 inline 声明只是程序员对编译器提出的一个建议，而不是强制性的，并非一经指定为 inline 编译器就必须这样做。编译器有自己的判断能力，它会根据具体情况决定是否这样做。也就是说程序定义成inline，编译器在编译时替补替换成函数体还不一定，这得看编译器 C++规定，默认参数只能放在形参列表的最后，而且一旦为某个形参指定了默认值，那么它后面的所有形参都必须有默认值。实参和形参的传值是从左到右依次匹配的，默认参数的连续性是保证正确传参的前提。在以后设计类时你将发现，通过使用默认参数，可以减少要定义的析构函数、方法以及方法重载的数量。 构造函数参数列表的定义不能有默认参数，但是构造函数参数列表的声明可以加默认参数。即使构造函数的声明加了默认参数后，定义也不能加默认参数 C++ 允许多个函数拥有相同的名字，只要它们的参数列表不同就可以，这就是函数的重载。(参数列表又叫参数签名，包括参数的类型、参数的个数和参数的顺序，只要有一个不同就叫做参数列表不同。参数列表不同包括参数的个数不同、类型不同或顺序不同，仅仅参数名称不同是不可以的。函数返回值也不能作为重载的依据，判断是不是函数重载只能根据参数列表不同、函数名相同即可)。另外const也可以作为函数重载的依据，比如2个函数什么都一样，就是参数的const位置不同，那么也是重载。 函数的重载的规则： 函数名称必须相同。 参数列表必须不同（个数不同、类型不同、参数排列顺序不同等）。 函数的返回类型可以相同也可以不相同。 仅仅返回类型不同不足以成为函数的重载。 重载就是在一个作用范围内（同一个类、同一个命名空间等）有多个名称相同但参数不同的函数。重载的结果是让一个函数名拥有了多种用途，使得命名更加方便（在中大型项目中，给变量、函数、类起名字是一件让人苦恼的问题），调用更加灵活。在使用重载函数时，同名函数的功能应当相同或相近，不要用同一函数名去实现完全不相干的功能，虽然程序也能运行，但可读性不好，使人觉得莫名其妙。 C++代码在编译时会根据参数列表对函数进行重命名，例如 void Swap(int a, int b) 会被重命名为 _Swap_int_int，void Swap(float x, float y)会被重命名为 _Swap_float_float。当发生函数调用时，编译器会根据传入的实参去逐个匹配，以选择对应的函数，如果匹配失败，编译器就会报错，这叫做重载决议（Overload Resolution）。不同的编译器有不同的重命名方式，这里仅仅举例说明，实际情况可能并非如此。从这个角度讲，函数重载仅仅是语法层面的，本质上它们还是不同的函数，占用不同的内存，入口地址也不一样。 类的成员方法就是成员函数，是函数的一种 与结构体一样，类只是一种复杂数据类型的声明，不占用内存空间。而对象是类这种数据类型的一个变量，或者说是通过类这种数据类型创建出来的一份实实在在的数据，所以占用内存空间。在定义类时不能对成员变量进行初始化，因为没有地方存储数据。只有在创建对象以后才会给成员变量分配内存，这个时候就可以赋值了。但C++11可以在给类的成员变量在声明的时候初始化，即成员变量的就地初始化 类名的首字母一般大写，以和其他的标识符区分开。 { }内部是类所包含的成员变量和成员函数，它们统称为类的成员（Member）；由{ }包围起来的部分有时也称为类体，和函数体的概念类似。 注意在类定义的最后有一个分号;，它是类定义的一部分，表示类定义结束了，不能省略。 C语言的函数也是封装，但是OOP里面的封装是指多了一层封装，就是类（Class），即类的封装 除了创建单个对象，还可以创建对象数组： 1Student allStu[100]; 该语句创建了一个 allStu 数组，它拥有100个元素，每个元素都是 Student 类型的对象。 类通常定义在函数外面，当然也可以定义在函数内部，不过很少这样使用。 栈内存是程序自动管理的，不能使用 delete 删除在栈上创建的对象；堆内存由程序员管理，对象使用完毕后可以通过 delete 删除。在实际开发中，new 和 delete 往往成对出现，以保证及时删除不再使用的对象，防止无用内存堆积。虽然在一般的程序中无视垃圾内存影响不大，但记得 delete 掉不再使用的对象依然是一种良好的编程习惯。 两种创建对象的方式： 一种是在栈上创建，形式和定义普通变量类似； 另外一种是在堆上使用 new 关键字创建，必须要用一个指针指向它，读者要记得 delete 掉不再使用的对象。 这2种创建对象的方式创建的对象在调用析构函数时会有区别： 在函数内部用第一种方式创建的对象是局部对象，它和局部变量类似，位于栈区，函数执行结束时会自动调用这些对象的析构函数. new 创建的对象位于堆区，通过 delete 删除时才会调用析构函数;如果没有 delete，析构函数就不会被执行. 通过对象名字访问成员使用点号.，通过对象指针访问成员使用箭头-&gt;，这和结构体非常类似。 类的成员函数也和普通函数一样，都有返回值和参数列表，它与一般函数的区别是：成员函数是一个类的成员，出现在类体中，它的作用范围由类来决定；而普通函数是独立的，作用范围是全局的，或位于某个命名空间内。 可以只在类体中声明函数，而将函数定义放在类体外面 在类体中和类体外定义成员函数的区别： 在类体中定义的成员函数会自动成为内联函数，在类体外定义的不会。 在类体内部定义的函数也可以加 inline 关键字，但这是多余的，因为类体内部定义的函数默认就是内联函数。 既希望将函数定义在类体外部，又希望它是内联函数，那么可以在定义函数时加 inline 关键字。当然你也可以在函数声明处加 inline，不过这样做没有效果，编译器会忽略函数声明处的 inline 在类体外定义 inline 函数的方式，必须将类的定义和成员函数的定义都放在同一个头文件中（或者同一个源文件中），否则编译时无法进行嵌入（将函数代码的嵌入到函数调用处） 再次强调，虽然 C++ 支持将内联函数定义在类的外部，但我强烈建议将函数定义在类的内部，这样它会自动成为内联函数，何必费力不讨好地将它定义在类的外部呢，这样并没有任何优势。 但是内联函数一般不是我们所期望的，它会将函数调用处用函数体替代，所以我建议在类体内部对成员函数作声明，而在类体外部进行定义，这是一种良好的编程习惯，实际开发中大家也是这样做的。 所谓访问权限，就是你能不能使用该类中的成员。 Java、C# 程序员注意，C++ 中的 public、private、protected 只能修饰类的成员，不能修饰类，C++中的类没有共有私有之分。 在类的内部（定义类的代码内部），无论成员被声明为 public、protected 还是 private，都是可以互相访问的，没有访问权限的限制。在类的外部（定义类的代码之外），只能通过对象访问成员，并且通过对象只能访问 public 属性的成员，不能访问 private、protected 属性的成员。 成员变量大都以m_开头，这是约定成俗的写法，不是语法规定的内容。以m_开头既可以一眼看出这是成员变量，又可以和成员函数中的形参名字区分开。以 setname() 为例，如果将成员变量m_name的名字修改为name，那么 setname() 的形参就不能再叫name了，得换成诸如name1、_name这样和成员变量不一样的名字。 该向外暴露的接口（能通过对象访问的成员）都声明为 public，不希望外部知道、或者只在类内部使用的、或者对外部没有影响的成员，都建议声明为 private。 根据C++软件设计规范，实际项目开发中的成员变量以及只在类内部使用的成员函数（只被成员函数调用的成员函数）都建议声明为 private，而只将允许通过对象调用的成员函数声明为 public。 声明为 protected 的成员在类外也不能通过对象访问，但是在它的派生类内部可以访问，记住protected 属性的成员在类外也无法访问即可，只有public才可以在类外访问 给成员变量赋值的函数通常称为 set 函数，它们的名字通常以set开头，后跟成员变量的名字；读取成员变量的值的函数通常称为 get 函数，它们的名字通常以get开头，后跟成员变量的名字。 构造函数只能给成员变量赋值一次，以后再修改还得借助 set 函数。 这种将成员变量声明为 private、将部分成员函数声明为 public 的做法体现了类的封装性。所谓封装，是指尽量隐藏类的内部实现，只向用户提供有用的成员函数。 额外添加 set 函数和 get 函数多麻烦，直接将成员变量设置为 public 多省事！确实，这样做 99.9% 的情况下都不是一种错误，但是，将成员变量设置为 private 是一种软件设计规范，尤其是在大中型项目中，还是请大家尽量遵守这一原则。 在一个类体中，private 和 public 可以分别出现多次。每个部分的有效范围到出现另一个访问限定符或类体结束时（最后一个右花括号）为止。但是为了使程序清晰，应该养成这样的习惯，使每一种成员访问限定符在类定义体中只出现一次。一般private放在public前面 构造函数不需要用户显式调用，用户也不能调用 构造函数必须是 public 属性的，否则创建对象时无法调用。当然，设置为 private、protected 属性也不会报错，但是没有意义。 构造函数没有返回值，因为没有变量来接收返回值，即使有也毫无用处，这意味着： 不管是声明还是定义，函数名前面都不能出现返回值类型，即使是 void 也不允许； 函数体中不能有 return 语句。 构造函数的调用是强制性的(compulsory)，一旦在类中定义了构造函数，那么创建对象时就一定要调用，不调用是错误的。如果有多个重载的构造函数，那么创建对象时提供的实参必须和其中的一个构造函数匹配；反过来说，创建对象时只有一个构造函数会被调用。比如我们为Student类定义了构造函数，创建对象时如果写作Student stu或者new Student就是错误的，因为类中包含了构造函数，而创建对象时却没有调用。 构造函数在实际开发中会大量使用，它往往用来做一些初始化工作，例如对成员变量赋值、预先打开文件等。 如果用户自己没有定义构造函数，那么编译器会自动生成一个默认的构造函数，默认生成的构造函数如下：Student(){} , 实际上编译器只有在必要的时候才会生成默认构造函数，而且它的函数体一般不为空。默认构造函数的目的是帮助编译器做初始化工作，而不是帮助程序员。这是C++的内部实现机制，这里不再深究，初学者可以按照上面说的“一定有一个空函数体的默认构造函数 Student(){}”来理解。 最后需要注意的一点是，调用没有参数的构造函数也可以省略括号。对于示例2的代码，在栈上创建对象可以写作Student stu()或Student stu，在堆上创建对象可以写作Student *pstu = new Student()或Student *pstu = new Student，它们都会调用构造函数 Student()。学构造函数之前我们就是这样做的，创建对象时都没有写括号，其实是调用了默认的构造函数。 一个类必须有构造函数，要么用户自己定义，要么编译器自动生成。一旦用户自己定义了构造函数，不管有几个，也不管形参如何，编译器都不再自动生成。 造函数的一项重要功能是对成员变量进行初始化，为了达到这个目的，可以在构造函数的函数体中对成员变量一一赋值，还可以采用初始化列表。使用构造函数初始化列表并没有效率上的优势，仅仅是书写方便，尤其是成员变量较多时，这种写法非常简单明了。而且，初始化 const 成员变量的唯一方法就是使用初始化列表。 注意，成员变量的初始化顺序与初始化列表中列出的变量的顺序无关，它只与成员变量在类中声明的顺序有关。 面向对象之前，代码复用主要depend函数，但是这种复用力度比较低，粒度较小，class出现以后，将变量和函数打包，大大提高了代码复用力度，增大粒度。 一个类只能有一个析构函数。如果用户没有定义，编译器会自动生成一个默认的析构函数。 函数名是标识符的一种，原则上标识符的命名中不允许出现符号，在析构函数的名字中出现的可以认为是一种特殊情况，目的是为了和构造函数的名字加以对比和区分。 C++ 中的 new 和 delete 分别用来分配和释放内存，它们与C语言中 malloc()、free() 最大的一个不同之处在于：用 new 分配内存时会调用构造函数，用 delete 释放内存时会调用析构函数。构造函数和析构函数对于类来说是不可或缺的，所以在C++中我们非常鼓励使用 new 和 delete。 在所有函数之外创建的对象是全局对象，它和全局变量类似，位于内存分区中的全局数据区，程序在结束执行时会调用这些对象的析构函数。 在函数内部创建的对象是局部对象，它和局部变量类似，位于栈区，函数执行结束时会调用这些对象的析构函数。 new 创建的对象位于堆区，通过 delete 删除时才会调用析构函数；如果没有 delete，析构函数就不会被执行。 this 是一个const指针，要用-&gt;来访问成员变量或成员函数。this 是 const 指针，它的值是不能被修改的，一切企图修改该指针的操作，如赋值、递增、递减等都是不允许的。 this 虽然用在类的内部，但是只有在对象被创建以后才会给 this 赋值，并且这个赋值的过程是编译器自动完成的，不需要用户干预，用户也不能显式地给 this 赋值。 this 只能在成员函数内部使用，用在其他地方没有意义，也是非法的。 只有当对象被创建后 this 才有意义，因此不能在 static 成员函数中使用 this 作为隐式形参，本质上是成员函数的局部变量，所以只能用在成员函数的内部，并且只有在通过对象调用成员函数时才给 this 赋值。 成员函数最终被编译成与对象无关的普通函数，除了成员变量，会丢失所有信息，所以编译时要在成员函数中添加一个额外的参数，把当前对象的首地址传入，以此来关联成员函数和成员变量。这个额外的参数，实际上就是 this，它是成员函数和成员变量关联的桥梁。 this 的功能可不止用来区分重名的形参和内部变量，this本质是指针，它还可以起到指针应有的作用，比如下面这2段代码 12345678910Cmycomplex Cmycomplex::Add(Cmycomplex &amp;z) &#123; Cmycomplex cache(0, 0); cache.real = real + z.real; cache.imag = imag + z.imag; return cache;&#125;z1.Add(z3);z1.Show();// 我们发现z1的值并没有改变，也就是z1的值并没有加上z3，这是因为Add函数是将z1+z3的结果返回给一个局部变量cache，当Add返回值没有被利用后，就被回收了，整个过程z1的值都没有被改变(不管是函数体内还是函数体外) 12345678910Cmycomplex Cmycomplex::Add(Cmycomplex &amp;z) &#123; Cmycomplex cache(0, 0); this-&gt;real = real + z.real; this-&gt;imag = imag + z.imag; return cache;&#125;z1.Add(z3);z1.Show();// 但是用this指针以后，我们可以在函数体内部来改变z1的值。 题目有后缀代码时不能在后缀代码再放任何文件 默认参数一般放在函数声明里，而不是放在函数体里，因为声明可以有很多个 C++的形参如果比较大，比如引用是一个很复杂的对象比如图像，那么换成引用的话参数传递效率会提高，但有原对象被修改的风险。引用可以实现函数参数的双向传递 如果在一段程序里自己定义的函数名和内置库里面的某个函数名重名了，又不能用运算符重载，那么可以用 :: ，比如在定义自己的复数类sqrt方法时，函数体需要用到cmath的sqrt方法，但是此时我们定义的sqrt和函数体里的sqrt重名了，编译器会以为是递归，此时用 std::sqrt，和自己定义的复数类的sqrt便来区分 构造函数的参数列表添加默认参数则可以减少构造函数的重载，同时减少程序代码量，比如 1Cmycomplex(double real = 0, double imag = 0); 那么创建对象时，可以赋2个初值，赋1个初值，或者不赋值。这些只需一个构造函数就能做到，不必再重载多个构造函数。但是也有缺点，比如形参 a, b, c，如果要缺省b，那么c也必须设为缺省，不能跳着设置缺省。 函数体内的引用参数的作用域就是函数体内部，生存期也是函数调用开始和结束之间，与局部变量一样，之后该引用关系便会消除。 static 成员变量必须在类声明的外部初始化。static 成员变量的内存既不是在声明类时分配，也不是在创建对象时分配，而是在（类外）初始化时分配。反过来说，没有在类外初始化的 static 成员变量不能使用。static 成员变量不占用对象的内存，而是在所有对象之外开辟内存，即使不创建对象也可以访问。具体来说，static 成员变量和普通的 static 变量类似，都在内存分区中的全局数据区分配内存。 一个类中可以有一个或多个静态成员变量，所有的对象都共享这些静态成员变量，都可以引用它。 static 成员变量和普通 static 变量一样，都在内存分区中的全局数据区分配内存，到程序结束时才释放。这就意味着，static 成员变量不随对象的创建而分配内存，也不随对象的销毁而释放内存。而普通成员变量在对象创建时分配内存，在对象销毁时释放内存。 静态成员变量必须初始化，而且只能在类体外进行。初始化时可以赋初值，也可以不赋值。如果不赋值，那么会被默认初始化为 0。全局数据区的变量都有默认的初始值 0，而动态数据区（堆区、栈区）变量的默认值是不确定的，一般认为是垃圾值。 静态成员变量在初始化时不能再加 static，但必须要有数据类型。被 private、protected、public 修饰的静态成员变量都可以用这种方式初始化: 1int Student::m_total = 0; 静态成员变量既可以通过对象名访问，也可以通过类名访问，但要遵循 private、protected 和 public 关键字的访问权限限制。 普通成员函数可以访问所有成员（包括成员变量和成员函数），静态成员函数只能访问静态成员。静态成员函数没有 this 指针，不知道指向哪个对象，无法访问对象的成员变量，也就是说静态成员函数不能访问普通成员变量，只能访问静态成员变量。 普通成员函数必须通过对象才能调用，而静态成员函数没有 this 指针，无法在函数体内部访问某个对象，所以不能调用普通成员函数，只能调用静态成员函数。 静态成员函数与普通成员函数的根本区别在于：普通成员函数有 this 指针，可以访问类中的任意成员（包括静态成员变量和静态成员函数和const成员）；而静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）。 静态成员函数可以通过类来调用（一般都是这样做），也可以通过对象来调用 编译器在编译一个普通成员函数时，会隐式地增加一个形参 this，并把当前对象的地址赋值给 this，所以普通成员函数只能在创建对象后通过对象来调用，因为它需要当前对象的地址。而静态成员函数可以通过类来直接调用，编译器不会为它增加形参 this，它不需要当前对象的地址，所以不管有没有创建对象，都可以调用静态成员函数。 const 成员变量的用法和普通 const 变量的用法相似，只需要在声明时加上 const 关键字。初始化 const 成员变量只有一种方法，就是通过构造函数的初始化列表 const 成员函数可以使用类中的所有成员变量，但是不能修改它们的值，这种措施主要还是为了保护数据而设置的。const 成员函数也称为常成员函数。我们通常将 get 函数设置为常成员函数。 getname()、getage()、getscore() 三个函数的功能都很简单，仅仅是为了获取成员变量的值，没有任何修改成员变量的企图，所以我们加了 const 限制，这是一种保险的做法，同时也使得语义更加明显。 需要强调的是，必须在成员函数的声明和定义处同时加上 const 关键字。char *getname() const和char *getname()是两个不同的函数原型，如果只在一个地方加 const 会导致声明和定义处的函数原型冲突。 最后再来区分一下 const 的位置： 函数开头的 const 用来修饰函数的返回值，表示返回值是 const 类型，也就是不能被修改，例如const char * getname()。 函数头部的结尾加上 const 表示常成员函数，这种函数只能读取成员变量的值，而不能修改成员变量的值，例如char * getname() const。 const 也可以用来修饰对象，称为常对象。一旦将对象定义为常对象之后，就只能调用类的 const 成员（包括 const 成员变量和 const 成员函数）了。因为访问非 const 成员可能会修改对象的数据（编译器也会这样假设），这样定义为常对象就失去意义了。C++禁止这样做。 stu、pstu 分别是常对象以及常对象指针，它们都只能调用 const 成员函数。 友元函数可以是不属于任何类的非成员函数(比如全局范围内的函数)，也可以是其他类的成员函数。 友元函数可以访问当前类中的所有成员，包括 public、protected、private 属性的。就和类里面定义的成员函数一样 类的提前声明和函数的提前声明是一个道理。一般情况下，类必须在正式声明之后才能使用；但是某些情况下，只要做好提前声明，也可以先使用。但是应当注意，类的提前声明的使用范围是有限的，只有在正式声明一个类以后才能用它去创建对象。因为创建对象时要为对象分配内存，在正式声明类之前，编译器无法确定应该为对象分配多大的内存。编译器只有在“见到”类的正式声明后（其实是见到成员变量），才能确定应该为对象预留多大的内存。在对一个类作了提前声明后，可以用该类的名字去定义指向该类型对象的指针变量（本例就定义了 Address 类的指针变量）或引用变量（后续会介绍引用），因为指针变量和引用变量本身的大小是固定的，与它所指向的数据的大小无关。 一个函数可以被多个类声明为友元函数，这样就可以访问多个类中的 private 成员。即一个函数可以成为好几个函数的朋友。 关于友元，有两点需要说明： 友元的关系是单向的而不是双向的。如果声明了类 B 是类 A 的友元类，不等于类 A 是类 B 的友元类，类 A 中的成员函数不能访问类 B 中的 private 成员。 友元的关系不能传递。如果类 B 是类 A 的友元类，类 C 是类 B 的友元类，不等于类 C 是类 A 的友元类。 除非有必要，一般不建议把整个类声明为友元类，而只将某些成员函数声明为友元函数，这样更安全一些。 在C++中，派生（Derive）和继承是一个概念，只是站的角度不同。继承是儿子接收父亲的产业，派生是父亲把产业传承给儿子。 以下是两种典型的使用继承的场景： 当你创建的新类与现有的类相似，只是多出若干成员变量或成员函数时，可以使用继承，这样不但会减少代码量，而且新类会拥有基类的所有功能。 当你需要创建多个类，它们拥有很多相似的成员变量或成员函数时，也可以使用继承。可以将这些类的共同成员提取出来，定义为基类，然后从基类继承，既可以节省代码，也方便后续修改成员。 引用是 C++ 的新增内容，在实际开发中会经常使用；C++ 用的引用就如同C语言的指针一样重要，但它比指针更加方便和易用，有时候甚至是不可或缺的。同指针一样，引用能够减少数据的拷贝，提高数据的传递效率。 数组、结构体、对象是一系列数据的集合，数据的数量没有限制，可能很少，也可能成千上万，对它们进行频繁的内存拷贝可能会消耗很多时间，拖慢程序的执行效率。所以C/C++ 索性直接禁止在函数调用时直接传递数组的内容，而是强制传递数组指针 &lt;&lt; 正常情况下是移位运算符，但是当其左边是ostream类时，&lt;&lt; 发生重载，比如 cout &lt;&lt; a &lt;&lt; b &lt;&lt; c; 那么 cout &lt;&lt; a 现在执行，执行完成之后返回一个ostream类，然后返回的这个ostream类，与后面的 &lt;&lt; 接着发生重载，这样接龙，就会实现连续输出到屏幕的功能。 引用2个功能： 数据传递更高效 有的对象只有一份，不能复制，只能引用，比如cout，cout是屏幕，只有一份，不能复制，只能引用。 请看下面这段代码： 12345678910111213141516171819202122/** ostream 和 istream的属性是私有的，在自己定义的类里访问不到，所以只能定义为全局函数，并把这个全局函数声明为ComplexNumber的友元函数；** cout代表屏幕，屏幕只有一份，所以只能引用不能复制；** 我们引用复数类z的同时，把其设为const,只读不写，从而防止函数体修改z；** 之所以返回类型也是ostream类而不是void，是因为我们想实现连续输出的效果，* &lt;&lt; 正常情况下是移位运算符，但是当其左边是ostream类时，&lt;&lt; 发生重载，* 比如 cout &lt;&lt; a &lt;&lt; b &lt;&lt; c; 那么 cout &lt;&lt; a 现在执行，执行完成之后返回一个ostream类，* 然后返回的这个ostream类，与后面的 &lt;&lt; 接着发生重载，这样接龙，就会实现连续输出到屏幕的功能* 我们如果将该函数的返回类型修改为void，并不返回值，那么就不会实现这种连续输出的效果；** 请注意，这里返回类型必须是 ostream &amp; 而不是 ostream ，因为如果是单纯返回 ostream 那么返回出去的时候会复制一份screen* 但是计算机不让我们复制，所以只能直接把screen引用出去，那么如果计算机允许我们复制，是可以不加 &amp; 符的。构造函数设为private就不允许复制了** 但是输出的内容会对screen有所改变，所有也不能是const*/ostream &amp; operator &lt;&lt; (ostream &amp; screen, const Cmycomplex &amp; z) &#123; screen&lt;&lt;&quot;(&quot;&lt;&lt;z.real&lt;&lt;&quot;+&quot;&lt;&lt;z.imag&lt;&lt;&quot;)&quot;&lt;&lt;endl; return screen;&#125; 我们成功地把 &lt;&lt; 重载了，那么 cout &lt;&lt; (complex 类型 + 2) 也能成功，这是为什么呢，我们之前只把 + 重载为 complex + complex ，没有重载过 complex + 实数，这怎么能成功呢？这是因为类型转换，编译器碰见 complex + double 就会去类里面找有没有这种类型的重载，没有，那么编译器会尝试把double类型依照构造器转换成complex类型，然后进行 complex + complex 运算，那么此时构造器起决定性作用，如果存在只要求传入一个double的构造器，那么就能转换成，否则就不能转成。 cin&gt;&gt; 的用法:以空格、tab 或换行作为分隔符。 正则表达式有它自身的语法。这与C的语法是两回事。C编译器只会检查C代码的语法。因此，即便你的代码通过了C编译器的语法检查，但在运行的时候，由于正则表达式的语义，还可能出现正则表达式的错误。 在代码中写字符串有时候是比较麻烦的，因为很多字符需要通过反斜杠转义。当有多个反斜杠连在一起时，就很容易写错或者理解错了。当通过字符串来写正则表达式时，这个问题就更严重了。因为正则表达式本身也有一些字符需要转义。例如，对于这样一个字符串 “(’(?:[\\\\’]|\\\\.)*’|&quot;(?:[\\\\”]|\\\\.)*&quot;)|&quot; 大部分人恐怕很难一眼看出其含义了。在正则表达式很复杂的时候，推荐大家使用 Raw string literal 来表达。这种表达式是告诉编译器：这里的内容是纯字符串，因此不再需要增加反斜杠来转义特殊字符。也就是说，R&quot;(content)&quot;中的content是你需要的字符串本身。 软件设计的最小特权原则：权限能给多小就给多小，不多给。比如成员变量一般设为private，不设为public。能用const就用const，尽量加const，除法没办法加const(这样万一有问题，那么造成的伤害就越小) const修饰一个引用，能让这个引用关系变为只读的 如果一个成员函数被设为const，那么编译器怎么检查这个成员函数到底是不是const呢？ 不能有修改的语句， 不能调用非const的函数 这个逻辑是非常自洽的，比如const对象只能调用const 成员变量和 const 成员函数，如果不是const 成员变量和 const 成员函数，那么编译器不允许你调用，它因为这个对象本身就是const，编译器怕你通过调用普通成员进而修改他们。 C++推荐一下2种，因为第2种有类型检查，第1种只是单纯的文本替换，不做类型检查 #define pi 3.1415926 const double pi = 3.1415926; string xxx(pi)，第1个不做类型检查，会通过；第2个做类型检查，不会通过 其次 const 变量可以用来定义数组。 在作操作符重载时，不能违背该操作符原有的习惯，否则这是一个不好的重载，比如重载单目运算符 ++ 时。 重载单目运算符 ++ 时，需要重载前置++，和后置++，而重载只能通过参数列表区分，那么单目运算符都不需要参数，那么怎么区分呢？答案就是在后置运算符重载时在参数列表多一个表区分的形参 int ，int 只有语法地位，没有实际意义，叫哑元， 该形参不会在函数体内被使用，仅表区分。当我们把++放在对象后面时，编译器一看在后面，就会找带哑元的函数，当放对象前面时，就会找不带哑元的函数。 前置是先自增再赋值，所以返回的可以是引用，也可以不是引用(我们提倡使用引用，这样提高效率)，返回自增后的值；后置是先赋值在自增，返回的是自增前的值，但是后置千万不能返回引用。 定义函数时，如果 return 局部变量 ，那么函数的返回类型不能是引用，否则会很危险，因为局部变量在函数结束时已经没了，返回引用的话，这个引用关系会指向这块已经被回收的内存，这块内存可能已经去干别的了，但是这个引用关系还在，这就很危险。 time b = (a); 表示a先前置+1，再后置+1，即a+2，b+1 函数模板不用再重载，相当于把数据类型变成参数。模板可以写在函数里面，也可以写在类里面。分为函数模板和类的模板 看下面这段代码 12345678910111213bool fraction::operator==(fraction x) &#123; this-&gt;simply(); x.simply(); if (member == x.member || denominator == x.denominator) &#123; return true; &#125; else &#123; return false; &#125;&#125;bool fraction::operator!=(fraction x) &#123; return !(*this==x);&#125; 当重载 != 时，可以利用上面的 == ，我们提倡这样写，这样改动 == 时，不必再改动 != ，这样写很方便，再看下面的例子： 123456789101112131415161718192021222324bool fraction::operator&lt;(fraction x) &#123; fraction temp = x - *this; if (temp.member &gt; 0 &amp;&amp; temp.denominator &gt;0) &#123; return true; &#125; else &#123; return false; &#125;&#125;bool fraction::operator&lt;=(fraction x) &#123; if (*this &lt; x || *this == x) &#123; return true; &#125; else &#123; return false; &#125;&#125;bool fraction::operator&gt;(fraction x) &#123; return !(*this&lt;=x);&#125;bool fraction::operator&gt;=(fraction x) &#123; return !(*this&lt;x);&#125; CLion每次生成新的类体外定义都会在类体外已有的函数定义下接着生成，并不会按照函数在类体的声明的顺序安排类体外函数的定义，这样有个好处，就是能保证后来的函数在调用旧的函数时，旧函数的函数体在新函数之前，防止出现不能调用的情况 使用类模板使用户可以为类声明一种模式，使得类中的某些数据成员、某些成员函数的参数、某些成员函数的返回值，能取任意类型（包括基本类型的和用户自定义类型）。 注意：模板头和类头是一个整体，可以换行，但是中间不能有分号 编译是源代码-&gt;exe的过程，运行是执行exe的过程； 在编译期间， 模板类型只要支持所用的操作符都行，但是如果不支持就不能用模板代替，比如 complex &lt; int 复数不支持和实数比大小，所以complex就不能用模板代替 double在内存中有符号位，所以有+0，-0之分，+0和-0不相等 如果一段程序既有函数模板又有函数重载，这俩函数同名，那么编译器优先选择重载，因为函数重载是程序员主动重载的，编译器会觉得程序员不会闲着没事去重载一个函数，所以优先选择重载 C++中 * 不是一个运算符，仅仅表示是这一个指针，所以没有CPU的运行周期; 但是 &amp; 是一个运算符，具有CPU的运行周期 ptr-&gt;getx() 相当于 (*ptr).getx(); 只不过后者书写方式比较繁琐，所以一般使用前者。 this指针隐藏于每一个非静态成员函数之中。当C++编译成C语言代码后，在C语言代码中就会出现this指针，比如 z1.getReal() -&gt; getReal(&amp;z1)，在C语言里面函数是getReal(class *this) C++ 代码 编译后变成 C语言代码，然后 C语言代码 变成汇编语言(asm)，再编译变成 机器语言(obj)，然后连接器(linker)把机器语言组装成 .exe ，然后loader把exe文件转移到内存上开始运行 源代码-&gt;exe文件叫编译时刻，exe通过loader装载到内存开始运行叫运行时刻 看下面这段代码： 12345678910class Fred;class Barney &#123; Fred x;&#125;;class Fred &#123; Barney y;&#125;// 这行代码是错的，这两个类互相交叉定义，尽管Fred类已经提前声明了，但是类体还在后面，所以在Barney类体定义中，直接去创建一个Fred对象会出错，因为Fred类此时还没有精确定义，编译器不知道 Fred对象占用多少空间，所以会报错。为了解决这种情况，可以用指针 析构函数没有参数，因为都要死了 析构函数在对象的生存期结束时执行 用 new 和 delete 分配内存比 malloc 和 free s更加简单：new 操作符会根据后面的数据类型来推断所需空间的大小。和 malloc() 一样，new 也是在堆区分配内存，必须手动释放，否则只能等到程序运行结束由操作系统回收。为了避免内存泄露，通常 new 和 delete、new[] 和 delete[] 操作符应该成对出现，并且不要和C语言中 malloc()、free() 一起混用。 C++ 中的 new 和 delete 分别用来分配和释放内存，它们与C语言中 malloc()、free() 最大的一个不同之处在于：用 new 分配内存时会调用构造函数，用 delete 释放内存时会调用析构函数。构造函数和析构函数对于类来说是不可或缺的，所以在C++中我们非常鼓励使用 new 和 delete。但是看下面的代码： 123456789101112131415161718192021// 这是个构造函数，其中成员变量 m_len 是我们输入传入构造函数来初始化的，// 另一个成员函数 p指针是依赖输入的 m_len 参数来初始化的，并不是我们直接输入的。template&lt;class T&gt;myArray&lt;T&gt;::myArray(int len):m_len(len) &#123; if (m_len &gt; 0) &#123; p = new T[m_len]; // p = (T *) malloc(sizeof(T) * m_len); &#125; else &#123; p = nullptr; &#125;&#125;template&lt;class T&gt;myArray&lt;T&gt;::~myArray() &#123; // 如果p已经指向NULL了，就没必要再释放了 if (p != nullptr) &#123; delete[] p; // free(p); p = nullptr; &#125;&#125; 那么根据我们之前的理论，用 new 分配内存时会调用构造函数，用 delete 释放内存时会调用析构函数。那么在构造函数和析构函数的定义使用 new 和 delete 中是不是就变成递归了呢？并不是，因为new调用的是定义类型的构造函数，比如 12new T&lt;complex&gt;// 在new的时候自动调用的是complex的构造函数，而不是调用的我们正在定义的构造函数 在模板类中输入流“&gt;&gt;”和输出流“&lt;&lt;”的重载,若使用友元在类内声明，在类外实现，那么连接时将会报错,但我们可以采用以下三种方式来实现输出流&quot;&lt;&lt;&quot;和&quot;输入流&gt;&gt;&quot;的重载。转载 将输出流&quot;&lt;&lt;&quot;和&quot;输入流&gt;&gt;&quot;重载的实现写在类中 那么输入输出流重载为什么不能在类内声明，类外实现呢？？因为模板比较特殊，如果在模板类外实现重载的话：正好是函数模板的定义,而我们知道操作符重载函数不是类的成员函数，因此此处相当于定义了一个新的函数模板（不同于类中的friend ostream&amp; operator&lt;&lt;(ostream&amp; out,Test&lt; T &gt;&amp; t) ）。但若去掉template &lt; class T &gt; ，函数中的参数Test&lt; T &gt;就不知是什么类型，所以不能在模板类内声明，类外实现操作符重载。 既然类外实现相当于重定义了一个函数模板，那么只要他不使用类的私用成员即可，因此重载的函数模板只有通过类的公有成员函数来实现对类的私有成员的操作，这样不必在类内声明它为友元，直接在类外重载即可。 使用过渡函数 我们知道，数据的值可以通过函数参数传递，在函数定义时数据的值是未知的，只有等到函数调用时接收了实参才能确定其值。这就是值的参数化。在C++中，数据的类型也可以通过参数来传递，在函数定义时可以不指明具体的数据类型，当发生函数调用时，编译器可以根据传入的实参自动推断数据类型。这就是类型的参数化。等发生函数调用时再根据传入的实参来逆推出真正的类型。 值（Value）和类型（Type）是数据的两个主要特征，它们在C++中都可以被参数化。 在函数模板中，数据的值和类型都被参数化了 一但定义了函数模板，就可以将类型参数用于函数定义和函数声明了。说得直白一点，原来使用 int、float、char 等内置类型的地方，都可以用类型参数来代替。 template是定义函数模板的关键字。typename是另外一个关键字，用来声明具体的类型参数，这里的类型参数就是T。从整体上看，template &lt; typename T &gt; 被称为模板头。 函数模板也可以提前声明，不过声明时需要带上模板头，并且模板头和函数定义（声明）是一个不可分割的整体，它们可以换行，但中间不能有分号。比如： 12345678//定义函数模板template&lt;typename T&gt; //模板头，这里不能有分号T max(T a, T b, T c)&#123; //函数头 T max_num = a; if(b &gt; max_num) max_num = b; if(c &gt; max_num) max_num = c; return max_num;&#125; 同样的，模板头和类头是一个整体，可以换行，但是中间不能有分号。 typename关键字也可以使用class关键字替代，它们没有任何区别。C++ 早期对模板的支持并不严谨，没有引入新的关键字，而是用 class 来指明类型参数，但是 class 关键字本来已经用在类的定义中了，这样做显得不太友好，所以后来 C++ 又引入了一个新的关键字 typename，专门用来定义类型参数。不过至今仍然有很多代码在使用 class 关键字，包括 C++ 标准库、一些开源程序等。 模板头中包含的类型参数可以用在函数定义的各个位置，包括返回值、形参列表和函数体；本例我们在形参列表和函数体中使用了类型参数T。说得直白一点，原来使用 int、float、char 等内置类型的地方，都可以用类型参数来代替。 类型参数的命名规则跟其他标识符的命名规则一样，不过使用 T、T1、T2、Type 等已经成为了一种惯例。 定义模板函数的语法： 123template &lt;typename 类型参数1 , typename 类型参数2 , ...&gt; 返回值类型 函数名(形参列表)&#123; //在函数体中可以使用类型参数&#125; 类型参数可以有多个，它们之间以逗号,分隔。类型参数列表以&lt; &gt;包围，形式参数列表以( )包围。 声明类模板的语法为： 123template&lt;typename 类型参数1 , typename 类型参数2 , …&gt; class 类名&#123; //TODO:&#125;; 类型参数不能为空，多个类型参数用逗号隔开。 在类外定义成员函数时仍然需要带上模板头，格式为： 12345template&lt;typename 类型参数1 , typename 类型参数2 , …&gt;返回值类型 类名&lt;类型参数1 , 类型参数2, ...&gt;::函数名(形参列表)&#123; //TODO:&#125;// 第一行是模板头，第二行是函数头，它们可以合并到一行，不过为了让代码格式更加清晰，一般是将它们分成两行。 除了 template 关键字后面要指明类型参数，类名 Point 后面也要带上类型参数，只是不加 typename 关键字了。另外需要注意的是，在类外定义成员函数时，template 后面的类型参数要和类声明时的一致。 使用类模板创建对象时，需要指明具体的数据类型。请看下面的代码： 123Point&lt;int, int&gt; p1(10, 20);Point&lt;int, float&gt; p2(10, 15.5);Point&lt;float, char*&gt; p3(12.4, &quot;东经180度&quot;); 与函数模板不同的是，类模板在实例化时必须显式地指明数据类型，编译器不能根据给定的数据推演出数据类型。但是函数模板不必，编译器能逆推出数据类型。 除了对象变量，我们也可以使用对象指针的方式来实例化： 12Point&lt;float, float&gt; *p1 = new Point&lt;float, float&gt;(10.6, 109.3);Point&lt;char*, char*&gt; *p = new Point&lt;char*, char*&gt;(&quot;东经180度&quot;, &quot;北纬210度&quot;); 需要注意的是，赋值号两边都要指明具体的数据类型，且要保持一致。下面的写法是错误的： 12Point&lt;float, float&gt; *p1 = new Point&lt;float, float&gt;(10.6, 109.3);Point&lt;char*, char*&gt; *p = new Point&lt;char*, char*&gt;(&quot;东经180度&quot;, &quot;北纬210度&quot;); 转载 强类型和弱类型是站在变量定义和类型转换的角度讲的，并把 C/C++ 归为强类型语言。另外还有一种说法是站在编译和运行的角度，并把 C/C++ 归为弱类型语言。这次我们只关注第一种说法。不管是强类型语言还是弱类型语言，在编译器（解释器）内部都有一个类型系统来维护变量的各种信息。对于强类型的语言，变量的类型从始至终都是确定的、不变的，编译器在编译期间就能检测某个变量的操作是否正确，这样最终生成的程序中就不用再维护一套类型信息了，从而减少了内存的使用，加快了程序的运行。不过这种说法也不是绝对的，有些特殊情况还是要等到运行阶段才能确定变量的类型信息。比如 C++ 中的多态，编译器在编译阶段会在对象内存模型中增加虚函数表、type_info 对象等辅助信息，以维护一个完整的继承链，等到程序运行后再执行一段代码才能确定调用哪个函数，对于弱类型的语言，变量的类型可以随时改变，赋予它什么类型的数据它就是什么类型，编译器在编译期间不好确定变量的类型，只有等到程序运行后、真的赋给变量一个值了，才能确定变量当前是什么类型，所以传统的编译对弱类型语言意义不大，因为即使编译了也有很多东西确定不下来。弱类型语言往往是一边执行一边编译，这样可以根据上下文（可以理解为当前的执行环境）推导出很多有用信息，让编译更加高效。我们将这种一边执行一边编译的语言称为解释型语言，而将传统的先编译后执行的语言称为编译型语言。强类型语言较为严谨，在编译时就能发现很多错误，适合开发大型的、系统级的、工业级的项目；而弱类型语言较为灵活，编码效率高，部署容易，学习成本低，在 Web 开发中大显身手。另外，强类型语言的 IDE 一般都比较强大，代码感知能力好，提示信息丰富；而弱类型语言一般都是在编辑器中直接书写代码。PHP 不需要使用模板就可以处理多种类型的数据，它天生对类型就不敏感。C++ 就不一样了，它是强类型的，比较“死板”，所以后来 C++ 开始支持模板了，主要就是为了弥补强类型语言“不够灵活”的缺点。模板所支持的类型是宽泛的，没有限制的，我们可以使用任意类型来替换，这种编程方式称为泛型编程（Generic Programming）。相应地，可以将参数 T 看做是一个泛型，而将 int、float、string 等看做是一种具体的类型。除了 C++，Java、C#、Pascal（Delphi）也都支持泛型编程。C++ 模板也是被迫推出的，最直接的动力来源于对数据结构的封装。数据结构关注的是数据的存储，以及存储后如何进行增加、删除、修改和查询操作，它是一门基础性的学科，在实际开发中有着非常广泛的应用。C++ 开发者们希望为线性表、链表、图、树等常见的数据结构都定义一个类，并把它们加入到标准库中，这样以后程序员就不用重复造轮子了，直接拿来使用即可。但是这个时候遇到了一个无法解决的问题，就是数据结构中每份数据的类型无法提前预测。以链表为例，它的每个节点可以用来存储小数、整数、字符串等，也可以用来存储一名学生、教师、司机等，还可以直接存储二进制数据，这些都是可以的，没有任何限制。而 C++ 又是强类型的，数据的种类受到了严格的限制，这种矛盾是无法调和的。要想解决这个问题，C++ 必须推陈出新，跳出现有规则的限制，开发新的技术，于是模板就诞生了。模板虽然不是 C++ 的首创，但是却在 C++ 中大放异彩，后来也被 Java、C# 等其他强类型语言采用。C++ 模板有着复杂的语法，可不仅仅是前面两节讲到的那么简单，它的话题可以写一本书。C++ 模板也非常重要，整个标准库几乎都是使用模板来开发的，STL 更是经典之作。STL（Standard Template Library，标准模板库）就是 C++ 对数据结构进行封装后的称呼。 当一个静态成员变量的功能是计数创建对象的数量时，千万别忘记在构造函数里对静态成员变量++，否则静态成员变量一直都是0(如果不赋值，那么会被默认初始化为 0。全局数据区的变量都有默认的初始值 0，而动态数据区（堆区、栈区）变量的默认值是不确定的，一般认为是垃圾值。) 类模板里的作计数功能的static成员变量，每一种类型的类使用自己的static成员变量，比如创建2个int类型变量和1个double类型变量，那么int的static就计2，double的static计1 用数组做日期的下一天很方便： 123456789101112131415161718192021222324252627282930313233date &amp;date::operator++() &#123; m_day++; if (LeapYear(year())) &#123; int days_per_month[13] = &#123;0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;; if (m_day &lt;= days_per_month[m_month]) &#123; ; &#125; else &#123; m_month = m_month + 1; m_day = 1; if (m_month &lt;= 12) &#123; ; &#125; else &#123; m_year = m_year + 1; m_month = 1; &#125; &#125; &#125; else &#123; int days_per_month[13] = &#123;0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;; if (m_day &lt;= days_per_month[m_month]) &#123; ; &#125; else &#123; m_month = m_month + 1; m_day = 1; if (m_month &lt;= 12) &#123; ; &#125; else &#123; m_year = m_year + 1; m_month = 1; &#125; &#125; &#125; return *this;&#125; 多重继承比单纯的类组合的一个好处就是，多重继承可以直接访问使用基类protected的成员与成员函数，如果是单纯的类的组合，那么仅仅能整体地使用别的类，不能像多继承那样细致地访问基类里的成员变量和成员函数 在多继承中，书写子类的构造函数时一定别忘了带上父类的构造函数，这样可以实例化Time的同时也实例化基类，以方便后面使用基类的对象。比如下面的代码： 123456789Time::Time(int year, int month, int day, int h, int m, int s):date(year, month, day), Clock(h, m, s) &#123; //实例化Time的同时也实例化基类，以方便后面使用基类的对象 m_year = year; m_month = month; m_day = day; hour = h; min = m; sec = s;&#125; 函数体内，最后return局部变量是，函数返回类型千万不能是引用，否则很危险。比如下面的代码就不行： 12345678910111213141516171819202122232425262728293031323334date &amp;date::Next() &#123;date tmp = *this;tmp.m_day++;if (LeapYear(year())) &#123; int days_per_month[13] = &#123;0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;; if (tmp.m_day &lt;= days_per_month[tmp.m_month]) &#123; ; &#125; else &#123; tmp.m_month = tmp.m_month + 1; tmp.m_day = 1; if (tmp.m_month &lt;= 12) &#123; ; &#125; else &#123; tmp.m_year = tmp.m_year + 1; tmp.m_month = 1; &#125; &#125;&#125; else &#123; int days_per_month[13] = &#123;0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;; if (tmp.m_day &lt;= days_per_month[tmp.m_month]) &#123; ; &#125; else &#123; tmp.m_month = tmp.m_month + 1; tmp.m_day = 1; if (tmp.m_month &lt;= 12) &#123; ; &#125; else &#123; tmp.m_year = tmp.m_year + 1; tmp.m_month = 1; &#125; &#125;&#125;return tmp;&#125; 昨天弄清是在原对象身上做加加减减还是再复制一份原对象，然后在复制体上加加减减，然后返回复制体，这两种方式得到的结果是不同的 C++不光成员函数可以重载，全局函数也能重载。 typeid 的操作对象既可以是表达式，也可以是数据类型 type_info 类的name()成员函数可以用来返回类型的名称。 将某个计算过程写成函数有助于我们理清思路，因为我们在写这个函数的时候可以排除别的程序的思路干扰。 如果不定义构造函数，那么编译器送我一个，但是编译器送的这个构造函数什么也不干。此时如果成员变量有指针变量，那么此时就很危险，指针可能会乱指。 构造函数没有返回值，只能用用异常处理机制来处理构造函数的异常情况 VLA虽然方便，而且可以写是否越界的判断和提示，但是会拖慢性能，因为每访问一个VLA的元素都要做一次越界判断，这样会比C的固定数组多一些时钟周期。一旦规模上去了，拖慢速度就凸显出来了。 12345678910111213141516171819/* * 这里返回引用的好处是可以直接给a[index]赋值,比如a[i] = 2 * 1.1; a[i]返回它本身，所以直接修改了a[i]的值 * 如果这里返回的不是引用关系，那么在返回时，会把a[i]复制一份返回给外面，那么这个返回值是不能作为左值的， * 即这个返回变量是只能读的变量，不能写的变量. * 举个例子，a+b=5; 这个语句是非法的，因为a+b的返回结果不能作为左值，是一个只读变量，不能把5写进去。 * 这里同理，如果返回的不是引用，那就不能书写 a[i] = 2 * 1.1; 这样的语句。但可以写 cout&lt;&lt;a[i] * */template&lt;class T&gt;T &amp; myArray&lt;T&gt;::operator [] (int index) &#123; // myArray&lt;T&gt;是类名，后面的&lt;T&gt;和前面的myArray共同组成类名 if (index &lt; m_len) &#123; return *(p + index); &#125; else &#123; cout&lt;&lt;&quot;out of range&quot;; return p[0]; &#125;// return p[index]; // 这个p是T类型，所以不是普通数组的[]，不会发生递归调用&#125; free和delete不能随便调用，因为借多少还多少，不能多还。 动态数组里也可以放动态数组 1234567891011121314151617181920212223242526int main() &#123; //定义一个二维数组，第2维没有给出它的len，也可以编译通过，是因为构造函数的形参len有默认值10 myArray&lt;myArray&lt;double&gt;&gt; aa(10); //赋值 for (int i = 0; i &lt; 10; ++i) &#123; for (int j = 0; j &lt; 10; ++j) &#123; aa[i][j] = i * j * 1.2; &#125; &#125; // 输出 for (int i = 0; i &lt; 10; ++i) &#123; for (int j = 0; j &lt; 10; ++j) &#123; cout&lt;&lt;aa[i][j]&lt;&lt;&quot;\\t&quot;; &#125; cout&lt;&lt;endl; &#125; return 0;&#125;/* * 当主函数结束时，对象aa调用析构函数，此时因为是二维数组，所以会触发级联析构， * 比如要析构aa[0]，但是aa[0]也是一个VLA，所以又会调用aa[0]这个元素的析构函数 * * */ 123// 如果不加[]，仅仅是delete p;那么仅仅会释放p指向数组的第一个元素，加上delete会释放p指向的一连串内存空间// 借的时候是借的一个数组的内存，那么在delete的时候加上 [] 会释放整个数组的内存delete[] p; new也有不如mallcoc的时候，因为malloc不会调用构造函数，可以提高效率 C有些函数比如构造函数、析构函数都是自动调用的，不是程序员主动发起的，所以C调试会比C困难一些。 内存泄漏（Memory Leak）是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。 若VLA创建2个对象，比如 myArray&lt; Point &gt; a, b; 那么 给a所指向数组的某个元素赋值，a[ 3 ] = 12; 但是当我们想让 b=a 时，会发生内存泄漏，因为刚刚创建a和b时，a b 各指向自己的一块连续内存，即一共有2块内存被申请，那么如果令 b = a ，b的成员变量的指针就会指向a所指向的那块连续内存，此时b所指向的原来的内存会被抛弃，但是这块内存并没有释放，但是没人指它了，所以会发生内存泄漏。同时不光会出现内存泄漏的问题，在a 和 b这两个变量生存期结束时，会分别调用一次析构函数，那么此时，a 和 b所指向的这块内存，会被释放2次，这也是非法的。 一般的对象作2个同类的对象的赋值操作比如a=b，没啥问题，但是VLA成员变量里面有一个指向内存的指针，程序员会让它申请内存，这样就不能简单地浅赋值了。 如果没定义构造函数，那么编译器送一个构造函数。同样的，我们没有重载 = , 那么编译器会送一个比较肤浅的 = 重载，编译器送的赋值叫浅赋值，这种浅赋值对于一般的对象赋值没问题，但是碰见VLA这种需要申请内存的类，那么编译器送的这个浅赋值就不行，不行的原因上面我们已经讲过，此时需要我们自己去重载新的 = ，称之为深赋值。 深赋值也称深copy，对于VLA这种对象，只能使用深copy不能使用浅copy。 我们在重载自己的 = 时，要千万注意考虑 出现a=a 的情况，如果只是简单地把原内存释放掉再申请一个，再赋值，对于两个不同对象可以，但是对于同对象赋值，原内存已经被释放掉了，后面不能再拿来赋值。此时要作 if 判断。 所有涉及到资源的赋值，则需要自己去设计赋值操作，比如文件 对于一般类型的变量，可以这样赋值，int b(a)，可以把a的值赋给b，但是这也是浅copy，但是同样，对于VLA就不行，比如 myArray&lt; Point &gt; b(a)，那么此时b和a会指向同一个内存空间，对象死亡时会调用2次析构函数，这是非法的，但是好在b一出生就指向了a，没有自己原来指向的旧内存，不会发生内存泄漏，但这仍是非法的。这是就需要我们自己重载一个copy构造，使得b一出生就指向自己的内存并 copy a的值。 如果对于一般的类，编译器会送一个copy构造，compelx b(a) 是没问题的，但对于需要申请内存的类，编译器送的简单的这种copy构造函数就不行，需要我们自己定义一个copy构造。即使对于普通类，如果我们自己定义一个copy构造，那么编译器就会用我们自己定义的那个copy构造 实参在传给形参时，如果不是引用传值的话，会自动调用copy构造函数。那么此时会拖慢性能。写成引用传参就不会调用copy构造。 引用传参一般会设为const，这样既享受到效率的提高，又保证变量不会被修改，比较安全。 链表对计算机是一件好事，因为对内存利用率更高，内存腾出一段连续内存是很难的事 计算机很多消息队列都是用链表，还有很多数据包也是用链表 正在玩游戏，突然手机提醒将要没电，那么这个消息是一个紧急消息，那么可以用链表插入，这样比VLA的每个元素往后挪效率更高 链表的常见操作：追加、遍历、插入、删除、归还 双向链表可以2个方向来回找，单向链表只能1个方向 下面2个概念 指向对象的常指针：将指向对象的指针变量声明为const型，并使之初始化，这样指针值始终保持为其初始值，不能改变。 12Time t1(10,12,15),t2;Time * const ptr1=&amp;t1; 指向常对象的指针：如果一个变量已经被声明成常变量，则只能用指向常变量的指针变量指向它，而不能用一般的（非const型的）指针变量指向它。对于对象也是如此，如果声明一个对象为常对象，则只能用指向常对象的const指针指向它，而不能用一般的（非const型的）指针变量指向它。因为怕你通过这个指针去修改常对象 1234567const int a;//定义常变量aconst int *p;//定义指向常变量的指针p=&amp;a;const Time t1;//定义常对象const Time *p;//定义指向常对象的指针p=t1; 什么是常引用？正常的引用：int &amp;a=b 相当于 int *const a=b ；而常引用：const int &amp;a=b就相当于 const int * const a=b。不仅仅是a这个地址不可修改，而且其指向的内存空间也不可修改。 C++对象数组的正确创建方式： 1234//栈中创建对象数组Acct myAcct[6];//堆中创建对象数组Acct *CheckingAcct = new Acct[3]; 注意，在学吧上提交程序时，//StudybarCommentBegin 和 //StudybarCommentEnd 不能乱加，因为加了后天就会给你把之间的代码删掉 new可以自动调用构造函数这一点在VLA里特别有优势，比如创建一个动态数组，每个元素是一个Point类，那么用new就会自动初始化里面每一个Point元素 对于动态数组类所申请的内存，在使用完必须由程序员自己释放，否则会引起内存泄露。 有时候构造函数会重载错误，出现 error: Call of Overloaded Function is ambiguous 的提示，这是怎么回事呢？我见到过一下2种： 构造函数使用默认参数的情况下，又写个相同功能的构造函数 123Point(int x);Point(int x, int y = 0);// 创建对象只传入1个参数时，这2个构造函数会重复，导致编译器不知道调用哪个 原因在与c++，默认将小数认为是double类型，在上面程序调用时，double类型需要做类型转换但是转成float还是int，编译器不知道。 12345678910111213141516#include&lt;iostream&gt;using namespace std;int sum(int a,int b)&#123; return a+b;&#125;int sum(float a, float b)&#123; return a+b;&#125;int main()&#123; cout &lt;&lt; sum(1.3, 2.7); return 0;&#125; malloc &amp; free 多维数组。多维数组需一维一维地malloc，同时也要反过来一维一维地free。而delete可以自动调用析构函数从而实现级联析构，不用一层一层写 unsigned就是unsigned int的简写。signed,unsigned,long和short都隐含了int，所以等价于signed int,unsigned int,long int,short int 字符数组转化成string类型 char ch [] = “ABCDEFG”; string str(ch);//也可string str = ch; char ch [] = “ABCDEFG”; string str; str = ch;//在原有基础上添加可以用str += ch; 重载过 - 号，不代表重载过 -= 号，想使用 -= 需要再重载 -= 如果是重载双目操作符（即为类的成员函数），就只要设置一个参数作为右侧运算量，而左侧运算量就是对象本身。而 &gt;&gt; 或&lt;&lt; 左侧运算量是 cin或cout 而不是对象本身，所以不满足后面一点, 就只能申明为友元函数了。所以当想实现 int + complex 时，也必须要重载了 非静态成员不能可以在不建立对象的情况下调用类成员，非静态成员是随着对象存在而产生的，没有对象也就不会存在非静态成员，静态的可以，类名::成员名方式访问。所以想重载pow(object, n)可以定义为友元 vector:reverse和resize区别 “一、resize 1、resize(n) 调整容器的长度大小，使其能容纳n个元素。 如果n小于容器的当前的size，则删除多出来的元素。否则，添加采用值初始化的元素。 2、 resize(n，t) 多一个参数t，将所有新添加的元素初始化为t。 3、 所以resize也能改变capacity大小 二、reserve reserver()的用法只有一种：reserve(n) 预分配n个元素的存储空间。 size（长度）：指容器当前拥有的元素个数； capacity（容量）：则指容器在必须分配新存储空间之前可以存储的元素总数，也可以说是预分配存储空间的大小。 容器调用resize()函数后，所有的空间都已经初始化了，所以可以直接访问。而reserve()函数预分配出的空间没有被初始化，所以不可访问。 两个函数互相调用，是递归的一种方式。不建议这样写代码，递归一般在函数内部自己调用自己。 12345678910111213void A();void B();void A()&#123; B(); return;&#125;void B()&#123; A(); return;&#125; vector 有一个机制是这样的，如果新加入一个元素，比如通过push_back()，但是size 大于了capacity，那么vector 就会重新找一块更大的地方再把数据放进去。重新分配的过程：申请一块新的内存 &gt; 拷贝数据 &gt; 释放原内存。 resize()做的操作大概是直接修改了 数据量 大小，让我不能访问后面的数据，而不是释放空间。这就是问题所在，重新指定大小后，这么大的空间就浪费掉了。但是可以在后面紧跟着用 shrink_to_fit() vector调用clear()函数只会调用tempObject的析构函数，从而释放掉obj1和obj2两个对象，不会释放vector所占用的内存。真正释放vector所占用的内存，要到vector对象离开作用域时，自动调用vector的析构函数释放内存。即一般情况下，对象死亡调用析构函数时vector才会释放内存。想提前释放内存可以用swap()或者clear()和shrink_to_fit()联用 C++ 函数 std::vector::resize() 改变向量的大小。如果 n 小于当前大小，则销毁额外的元素。如果 n 大于当前容器大小，则在向量末尾插入新元素(旧元素保持不变)。如果指定了 val，那么新增得新元素将使用 val 进行初始化。 几乎所有的教程都指出，在使用vector前，要先用reserve分配内存。因为这在已知要插入的元素个数时，可以一次性分配所有内存，而不必因为push_back插入元素频繁执行内存分配（默认动作）。 vector在reverse后，直接赋值没有变化，只能push_back 在调用pop back函数之前，如果整数向量integer已经为空，因此尝试访问integer.back0时会导致溢出错误。 递归函数体里面函数的参数列表的参数不用再写数据类型 在自己定义的动态数组中，如果想这样创建一个二维数组 DynamicArray&lt; DynamicArray&lt; int &gt; &gt; ，那么必须要求有无需形参的构造函数，或者必须有所有形参都有默认值的构造函数，才能编译通过。因为 DynamicArray&lt; int &gt; 相当于创建一个没有参数的对象。 同一个类模板不同的实例之间相互独立，如果类模板中有静态成员，则每个模板类分别占用一个静态成员 如果普通类从模板类中派生，则必须指定参数，例如： 1class VectorDouble: public DynamicArray&lt;double&gt; 不能写成 1class VectorDouble: public DynamicArray&lt;T&gt; 一般认为良好的编程实践是，尽可能在 main 函数结束时终止程序，所以，许多程序员仅使用 exit 函数来处理出错的情形。在这种情况下，应该使用错误代码来表明发生了问题。一般认为良好的编程实践是，尽可能在 main 函数结束时终止程序，所以，许多程序员仅使用 exit 函数来处理出错的情形。在这种情况下，应该使用错误代码来表明发生了问题。 在多个构造函数中使用默认参数时，注意别功能重复了，因为有可能出现既适用于这个构造函数，也适用于那个构造函数的现象，这就会报错 C++的构造函数是不能被继承的，(网上说析构函数也不能被继承，但是我本地试了一下，发现析构函数能被继承，但构造函数真真切切的不能被继承)，想继承构造函数，可以看这个 继承构造函数，一种是用 透传构造函数，一直是用using 派生类能够通过using语句声明要在子类中继承基类的全部构造函数，注意是全部构造函数，基类如果有多个构造函数，那么一个using就可以全部继承过来 当使用using语句继承基类构造函数时。派生类无法对类自身定义的新的类成员进行初始化，我们可使用类成员的初始化表达式，为派生类成员设定一个默认初始值。比如 int d{0}; 当两个指针指向同一内存的时候特别需要注意，因为此时delete其中任意一个指针（准确说应该是指针所指向的内存）另外一个指针指向已被释放（已经不存在）的内存，此时通过指针对内存的操作自然会出错。 当一个指针p指向一个结构体时，*p 可以拿到整个结构体所有的成员，p-&gt;可以拿到结构体某一个成员 first = new Node&lt; T &gt;，这句话是分配1个Node&lt; T &gt;型的内存空间，与 int *p = new int; 是一个意思 头节点的含义代表一个链表的起始，date域不存任何元素，真正的第一个元素是在头节点的后面一个节点。头节点的好处是，使first永远不为空，在操作时非常方便。如果没有头节点，也能设计单链表，但在设计插入或者删除时，会经常判断头节点是否为空，非常麻烦 auto的原理就是根据后面的值，来自己推测前面的类型是什么。 auto的作用就是为了简化变量初始化，如果这个变量有一个很长很长的初始化类型，就可以用auto代替。 auto 注意点： 用auto声明的变量必须初始化（auto是根据后面的值来推测这个变量的类型，如果后面没有值，自然会报错） 函数和模板参数不能被声明为auto（原因同上） 因为auto是一个占位符，并不是一个他自己的类型，因此不能用于类型转换或其他一些操作，如sizeof和typeid 定义在一个auto序列的变量必须始终推导成同一类型 12auto x1 = 5, x2 = 5.0, x3=&#x27;r&#x27;; // This is too much....we cannot combine like this//这样就是错的 if (a) 和 if (a != NULL) 是等价的","categories":[],"tags":[]},{"title":"数据科学导论","slug":"anaconda_is_sb","date":"2022-07-22T07:42:10.000Z","updated":"2023-03-13T09:50:44.283Z","comments":true,"path":"2022/07/22/anaconda_is_sb/","link":"","permalink":"http://example.com/2022/07/22/anaconda_is_sb/","excerpt":"","text":"不如pycharm现搜现装，方便的多 Anaconda装几个G都是用不到的，用到的一个都没有，还要自己装，sb pycharm还能选择安装版本 有时候运行jupyter会出现，实际上已经安装过库，但是提示没有安装库的情况，这时候重启一下pycharm就好了","categories":[],"tags":[]},{"title":"pycharm中使用jupyter","slug":"pycharm_jupyter_learn","date":"2022-07-22T07:42:10.000Z","updated":"2023-03-08T16:40:39.575Z","comments":true,"path":"2022/07/22/pycharm_jupyter_learn/","link":"","permalink":"http://example.com/2022/07/22/pycharm_jupyter_learn/","excerpt":"","text":"当在pycarm中装完anaconda后，不需要在装pycharm里的jupyter插件，因为anaconda自带jupyter Pycharm配置了anaconda后会十分方便的调用一些anaconda自带的包，但是anaconda也不是万能的。这个时候你会发现pycharm中的setting那里加号已经无法安装包了 anaconda自己创建的tensorflow环境的包比base环境的包少很多，只有tensorflow相关的包，所以当时在base环境里装tensorflow半天装不出来，自己建的tensor环境里一会装完了，是因为在自己新建的环境里动的包少，在base环境里装的话，要动的包很多，就很慢 在anaconda里面装好包后，如果pycharm的解释器用的是这个anaconda这个解释器，那么pycharm能自动检测到","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2022-07-20T03:19:50.706Z","updated":"2022-07-20T09:09:11.232Z","comments":true,"path":"2022/07/20/hello-world/","link":"","permalink":"http://example.com/2022/07/20/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}