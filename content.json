{"meta":{"title":"下水道灵魂画手","subtitle":"","description":"一次编译，到处运行","author":"DifferentLee","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"CN五大城市PM2.5数据分析","slug":"PM2.5_five_cities","date":"2022-12-01T07:42:10.000Z","updated":"2022-12-05T13:41:08.962Z","comments":true,"path":"2022/12/01/PM2.5_five_cities/","link":"","permalink":"http://example.com/2022/12/01/PM2.5_five_cities/","excerpt":"","text":"中国农业大学 Python 程序设计实验报告 [toc] CSV文件数据预处理(pursue_mean.py) 导入CSV文件 1234567import pandas as pddf_bj = pd.read_csv(&quot;./data/BeijingPM20100101_20151231.csv&quot;)df_sh = pd.read_csv(&quot;./data/ShanghaiPM20100101_20151231.csv&quot;)df_cd = pd.read_csv(&quot;./data/ChengduPM20100101_20151231.csv&quot;)df_gz = pd.read_csv(&quot;./data/GuangzhouPM20100101_20151231.csv&quot;)df_sy = pd.read_csv(&quot;./data/ShenyangPM20100101_20151231.csv&quot;) 北京的数据信息 如何衡量污染状态 根据 《中华人民共和国生态环境部 环境空气质量指数（AQI）技术规定（试行）》 做一个不是很合理的假设–PM2.5是首要污染物，即令 AQI = IAQI(PM2.5) 即用PM2.5的数据粗略地去估计污染指数 如何划分污染等级 同样地，根据《中华人民共和国生态环境部 环境空气质量指数（AQI）技术规定（试行）》 我们取100为区分污染和优良的分界点 求PM2.5均值 求中国的测点和美国测点PM2.5的平均值: 12345df_bj[&#x27;PM_mean&#x27;] = df_bj.loc[:, [&#x27;PM_Dongsi&#x27;, &#x27;PM_Dongsihuan&#x27;, &#x27;PM_Nongzhanguan&#x27;, &#x27;PM_US Post&#x27;]].mean(axis=1)df_sh[&#x27;PM_mean&#x27;] = df_sh.loc[:, [&#x27;PM_Jingan&#x27;, &#x27;PM_US Post&#x27;, &#x27;PM_Xuhui&#x27;]].mean(axis=1)df_cd[&#x27;PM_mean&#x27;] = df_cd.loc[:, [&#x27;PM_Caotangsi&#x27;, &#x27;PM_Shahepu&#x27;, &#x27;PM_US Post&#x27;]].mean(axis=1)df_gz[&#x27;PM_mean&#x27;] = df_gz.loc[:, [&#x27;PM_City Station&#x27;, &#x27;PM_5th Middle School&#x27;, &#x27;PM_US Post&#x27;]].mean(axis=1)df_sy[&#x27;PM_mean&#x27;] = df_sy.loc[:, [&#x27;PM_Taiyuanjie&#x27;, &#x27;PM_US Post&#x27;, &#x27;PM_Xiaoheyan&#x27;]].mean(axis=1) 求求中国的测点PM2.5的平均值: 12345df_bj[&#x27;PM_mean_CN&#x27;] = df_bj.loc[:, [&#x27;PM_Dongsi&#x27;, &#x27;PM_Dongsihuan&#x27;, &#x27;PM_Nongzhanguan&#x27;]].mean(axis=1)df_sh[&#x27;PM_mean_CN&#x27;] = df_sh.loc[:, [&#x27;PM_Jingan&#x27;, &#x27;PM_Xuhui&#x27;]].mean(axis=1)df_cd[&#x27;PM_mean_CN&#x27;] = df_cd.loc[:, [&#x27;PM_Caotangsi&#x27;, &#x27;PM_Shahepu&#x27;]].mean(axis=1)df_gz[&#x27;PM_mean_CN&#x27;] = df_gz.loc[:, [&#x27;PM_City Station&#x27;, &#x27;PM_5th Middle School&#x27;]].mean(axis=1)df_sy[&#x27;PM_mean_CN&#x27;] = df_sy.loc[:, [&#x27;PM_Taiyuanjie&#x27;, &#x27;PM_Xiaoheyan&#x27;]].mean(axis=1) 绘制5个城市6年PM2.5均值的地理分布图(geo_map.py) 删除每个城市中国的测点和美国测点PM2.5的平均值中的 Nan 值 12345bj_PM_mean = pursue_mean.df_bj.loc[pursue_mean.df_bj[&#x27;PM_mean&#x27;].notnull(), [&#x27;PM_mean&#x27;]].mean()sh_PM_mean = pursue_mean.df_sh.loc[pursue_mean.df_sh[&#x27;PM_mean&#x27;].notnull(), [&#x27;PM_mean&#x27;]].mean()cd_PM_mean = pursue_mean.df_cd.loc[pursue_mean.df_cd[&#x27;PM_mean&#x27;].notnull(), [&#x27;PM_mean&#x27;]].mean()gz_PM_mean = pursue_mean.df_gz.loc[pursue_mean.df_gz[&#x27;PM_mean&#x27;].notnull(), [&#x27;PM_mean&#x27;]].mean()sy_PM_mean = pursue_mean.df_sy.loc[pursue_mean.df_sy[&#x27;PM_mean&#x27;].notnull(), [&#x27;PM_mean&#x27;]].mean() 创建地理分布图 1234567891011# 创建地理分布图districts = [&#x27;北京&#x27;, &#x27;上海&#x27;, &#x27;成都&#x27;, &#x27;广州&#x27;, &#x27;沈阳&#x27;]geo = Geo()geo.add_schema(maptype=&#x27;china&#x27;)geo.add(&#x27;五大城市PM2.5均值&#x27;, [(&#x27;北京&#x27;, bj_PM_mean.PM_mean), (&#x27;上海&#x27;, sh_PM_mean.PM_mean), (&#x27;成都&#x27;, cd_PM_mean.PM_mean), (&#x27;广州&#x27;, gz_PM_mean.PM_mean), (&#x27;沈阳&#x27;, sy_PM_mean.PM_mean)], type_=&quot;effectScatter&quot;, is_selected=True)geo.set_series_opts(label_opts=opts.LabelOpts(is_show=False))geo.set_global_opts(visualmap_opts=opts.VisualMapOpts(is_piecewise=True), title_opts=opts.TitleOpts(&#x27;五个城市PM2.5均值&#x27;))geo.render(&#x27;./picture/PM2.5map.html&#x27;) 得到下图 可以看出，偏北方的城市空气质量有待提高 绘制5个城市逐年PM2.5平均值折线图(per_year_PM2.5.py) 按照年分组 &amp;&amp; 排除缺失数据 1234567891011121314bj_year_PM_mean = pursue_mean.df_bj.loc[pursue_mean.df_bj[&#x27;PM_mean&#x27;].notnull(), [&#x27;PM_mean&#x27;]]. \\ groupby(pursue_mean.df_bj[&#x27;year&#x27;]).mean()sh_year_PM_mean = pursue_mean.df_sh.loc[pursue_mean.df_sh[&#x27;PM_mean&#x27;].notnull(), [&#x27;PM_mean&#x27;]]. \\ groupby(pursue_mean.df_sh[&#x27;year&#x27;]).mean()cd_year_PM_mean = pursue_mean.df_cd.loc[pursue_mean.df_cd[&#x27;PM_mean&#x27;].notnull(), [&#x27;PM_mean&#x27;]]. \\ groupby(pursue_mean.df_cd[&#x27;year&#x27;]).mean()gz_year_PM_mean = pursue_mean.df_gz.loc[pursue_mean.df_gz[&#x27;PM_mean&#x27;].notnull(), [&#x27;PM_mean&#x27;]]. \\ groupby(pursue_mean.df_gz[&#x27;year&#x27;]).mean()sy_year_PM_mean = pursue_mean.df_sy.loc[pursue_mean.df_sy[&#x27;PM_mean&#x27;].notnull(), [&#x27;PM_mean&#x27;]]. \\ groupby(pursue_mean.df_sy[&#x27;year&#x27;]).mean() 绘制5大城市逐年PM2.5均值折线图 1234567891011121314151617181920212223242526272829303132333435363738394041424344plt.rcParams[&#x27;font.sans-serif&#x27;] = [&#x27;SimHei&#x27;] # 如果要显示中文字体,则在此处设为：SimHeiplt.rcParams[&#x27;axes.unicode_minus&#x27;] = False # 显示负号x = np.array([i for i in range(2010, 2016)])BeiJing = np.array(bj_year_PM_mean.values)ShangHai = np.array(np.insert(sh_year_PM_mean.values, 0, [np.nan]))ChengDu= np.array(np.insert(cd_year_PM_mean.values, 0, [np.nan, np.nan]))GuangZhou = np.array(np.insert(gz_year_PM_mean.values, 0, [np.nan]))ShenYang = np.array(np.insert(sy_year_PM_mean.values, 0, [np.nan, np.nan, np.nan]))# label在图示(legend)中显示。若为数学公式,则最好在字符串前后添加&quot;$&quot;符号# color：b:blue、g:green、r:red、c:cyan、m:magenta、y:yellow、k:black、w:white、、、# 线型：- -- -. : ,# marker：. , o v &lt; * + 1plt.figure(figsize=(10, 5))plt.grid(linestyle=&quot;--&quot;) # 设置背景网格线为虚线ax = plt.gca()ax.spines[&#x27;top&#x27;].set_visible(False) # 去掉上边框ax.spines[&#x27;right&#x27;].set_visible(False) # 去掉右边框plt.plot(x, BeiJing, marker=&#x27;o&#x27;, color=&quot;blue&quot;, label=&quot;北京&quot;, linewidth=1.5)plt.plot(x, ShangHai, marker=&#x27;o&#x27;, color=&quot;green&quot;, label=&quot;上海&quot;, linewidth=1.5)plt.plot(x, ChengDu, marker=&#x27;o&#x27;, color=&quot;red&quot;, label=&quot;成都&quot;, linewidth=1.5)plt.plot(x, GuangZhou, marker=&#x27;o&#x27;, color=&quot;magenta&quot;, label=&quot;广州&quot;, linewidth=1.5)plt.plot(x, ShenYang, marker=&#x27;o&#x27;, color=&quot;black&quot;, label=&quot;沈阳&quot;, linewidth=1.5)group_labels = [&#x27;2010年&#x27;, &#x27;2011年&#x27;, &#x27;2012年&#x27;, &#x27;2013年&#x27;, &#x27;2014年&#x27;, &#x27;2015年&#x27;] # x轴刻度的标识plt.xticks(x, group_labels, fontsize=12, fontweight=&#x27;bold&#x27;) # 默认字体大小为10plt.yticks(fontsize=12, fontweight=&#x27;bold&#x27;)plt.title(&quot;五大城市PM2.5均值逐年变化&quot;, fontsize=12, fontweight=&#x27;bold&#x27;) # 默认字体大小为12plt.xlabel(&quot;年份&quot;, fontsize=13, fontweight=&#x27;bold&#x27;)plt.ylabel(&quot;PM2.5均值&quot;, fontsize=13, fontweight=&#x27;bold&#x27;)plt.xlim(2009, 2016) # 设置x轴的范围plt.ylim(30, 120)# plt.legend() #显示各曲线的图例plt.legend(loc=0, numpoints=1)leg = plt.gca().get_legend()ltext = leg.get_texts()plt.setp(ltext, fontsize=12, fontweight=&#x27;bold&#x27;) # 设置图例字体的大小和粗细plt.savefig(&#x27;./picture/year_line_graph.jpg&#x27;) # 建议保存为svg格式,再用inkscape转为矢量图emf后插入word中plt.show() 可以看出北京的空气质量持续偏高，广州和上海较低，但总体是下降趋势， 北京的检测数量最全，6年数据全都有，沈阳仅有2年的数据 PM2.5随季节变化的折线图(season_PM25_line.py) 按照季节分组 &amp;&amp; 排除缺失数据 123456789101112131415161718import pursue_meanimport matplotlib.pyplot as pltimport numpy as npbj_season_PM_mean = pursue_mean.df_bj.loc[pursue_mean.df_bj[&#x27;PM_mean&#x27;].notnull(), [&#x27;PM_mean&#x27;]]. \\ groupby(pursue_mean.df_bj[&#x27;season&#x27;]).mean()sh_season_PM_mean = pursue_mean.df_sh.loc[pursue_mean.df_sh[&#x27;PM_mean&#x27;].notnull(), [&#x27;PM_mean&#x27;]]. \\ groupby(pursue_mean.df_sh[&#x27;season&#x27;]).mean()cd_season_PM_mean = pursue_mean.df_cd.loc[pursue_mean.df_cd[&#x27;PM_mean&#x27;].notnull(), [&#x27;PM_mean&#x27;]]. \\ groupby(pursue_mean.df_cd[&#x27;season&#x27;]).mean()gz_season_PM_mean = pursue_mean.df_gz.loc[pursue_mean.df_gz[&#x27;PM_mean&#x27;].notnull(), [&#x27;PM_mean&#x27;]]. \\ groupby(pursue_mean.df_gz[&#x27;season&#x27;]).mean()sy_season_PM_mean = pursue_mean.df_sy.loc[pursue_mean.df_sy[&#x27;PM_mean&#x27;].notnull(), [&#x27;PM_mean&#x27;]]. \\ groupby(pursue_mean.df_sy[&#x27;season&#x27;]).mean() 绘制季节折线图 1234567891011121314151617181920212223242526272829303132333435363738394041424344plt.rcParams[&#x27;font.sans-serif&#x27;] = [&#x27;SimHei&#x27;] # 如果要显示中文字体,则在此处设为：SimHeiplt.rcParams[&#x27;axes.unicode_minus&#x27;] = False # 显示负号x = np.array([i for i in range(1, 5)])BeiJing = np.array(bj_season_PM_mean.values)ShangHai = np.array(sh_season_PM_mean.values)ChengDu= np.array(cd_season_PM_mean.values)GuangZhou = np.array(gz_season_PM_mean.values)ShenYang = np.array(sy_season_PM_mean.values)# label在图示(legend)中显示。若为数学公式,则最好在字符串前后添加&quot;$&quot;符号# color：b:blue、g:green、r:red、c:cyan、m:magenta、y:yellow、k:black、w:white、、、# 线型：- -- -. : ,# marker：. , o v &lt; * + 1plt.figure(figsize=(10, 5))plt.grid(linestyle=&quot;--&quot;) # 设置背景网格线为虚线ax = plt.gca()ax.spines[&#x27;top&#x27;].set_visible(False) # 去掉上边框ax.spines[&#x27;right&#x27;].set_visible(False) # 去掉右边框plt.plot(x, BeiJing, marker=&#x27;o&#x27;, color=&quot;blue&quot;, label=&quot;北京&quot;, linewidth=1.5)plt.plot(x, ShangHai, marker=&#x27;o&#x27;, color=&quot;green&quot;, label=&quot;上海&quot;, linewidth=1.5)plt.plot(x, ChengDu, marker=&#x27;o&#x27;, color=&quot;red&quot;, label=&quot;成都&quot;, linewidth=1.5)plt.plot(x, GuangZhou, marker=&#x27;o&#x27;, color=&quot;magenta&quot;, label=&quot;广州&quot;, linewidth=1.5)plt.plot(x, ShenYang, marker=&#x27;o&#x27;, color=&quot;black&quot;, label=&quot;沈阳&quot;, linewidth=1.5)group_labels = [&#x27;第1季度&#x27;, &#x27;第2季度&#x27;, &#x27;第3季度&#x27;, &#x27;第4季度&#x27;] # x轴刻度的标识plt.xticks(x, group_labels, fontsize=12, fontweight=&#x27;bold&#x27;) # 默认字体大小为10plt.yticks(fontsize=12, fontweight=&#x27;bold&#x27;)plt.title(&quot;五大城市PM2.5均值逐季度变化&quot;, fontsize=12, fontweight=&#x27;bold&#x27;) # 默认字体大小为12plt.xlabel(&quot;季度&quot;, fontsize=13, fontweight=&#x27;bold&#x27;)plt.ylabel(&quot;PM2.5均值&quot;, fontsize=13, fontweight=&#x27;bold&#x27;)plt.xlim(0, 6) # 设置x轴的范围plt.ylim(20, 140)# plt.legend() #显示各曲线的图例plt.legend(loc=0, numpoints=1)leg = plt.gca().get_legend()ltext = leg.get_texts()plt.setp(ltext, fontsize=12, fontweight=&#x27;bold&#x27;) # 设置图例字体的大小和粗细plt.savefig(&#x27;./picture/season_line_graph.jpg&#x27;) # 建议保存为svg格式,再用inkscape转为矢量图emf后插入word中plt.show() 从图中可以看出，第2季度也就是夏季的空气质量最好，第4季度也就是冬季空气质量最差。 该结论对5个城市具有普适性 PM2.5随季节变化的柱状图(season_PM25_bar.py) 可以直接借助绘制PM2.5随季节变化的折线图的数据绘制柱状图 绘制柱状图 123456789101112131415161718192021222324from pyecharts import options as optsfrom pyecharts.charts import Barfrom pyecharts.globals import ThemeTypefrom itertools import chainfrom season_PM25_line import bj_season_PM_mean, sh_season_PM_mean, cd_season_PM_mean, gz_season_PM_mean, \\ sy_season_PM_meanc = ( Bar(&#123;&quot;theme&quot;: ThemeType.MACARONS&#125;) .add_xaxis([&#x27;第1季度&#x27;, &#x27;第2季度&#x27;, &#x27;第3季度&#x27;, &#x27;第4季度&#x27;]) .add_yaxis(series_name=&#x27;北京&#x27;, y_axis=[int(i) for i in list(chain.from_iterable(bj_season_PM_mean.values.tolist()))]) .add_yaxis(series_name=&#x27;上海&#x27;, y_axis=[int(i) for i in list(chain.from_iterable(sh_season_PM_mean.values.tolist()))]) .add_yaxis(series_name=&#x27;成都&#x27;, y_axis=[int(i) for i in list(chain.from_iterable(cd_season_PM_mean.values.tolist()))]) .add_yaxis(series_name=&#x27;广州&#x27;, y_axis=[int(i) for i in list(chain.from_iterable(gz_season_PM_mean.values.tolist()))]) .add_yaxis(series_name=&#x27;沈阳&#x27;, y_axis=[int(i) for i in list(chain.from_iterable(sy_season_PM_mean.values.tolist()))]) .set_series_opts(label_opts=opts.LabelOpts(is_show=True)) .set_global_opts( title_opts=opts.TitleOpts(title=&quot;季节对PM2.5的影响&quot;), xaxis_opts=opts.AxisOpts(name=&#x27;季节&#x27;, name_location=&#x27;middle&#x27;, name_gap=30), yaxis_opts=opts.AxisOpts(name=&#x27;PM2.5&#x27;, name_location=&#x27;middle&#x27;, name_gap=30), toolbox_opts=opts.ToolboxOpts() ) .render(&#x27;./picture/season_bar_graph.html&#x27;)) 累计风速对PM2.5的影响散点图(lws_scatter.py) 先将风速按顺序排序 12345bj_lws = pursue_mean.df_bj[&#x27;Iws&#x27;].sort_values()sh_lws = pursue_mean.df_sh[&#x27;Iws&#x27;].sort_values()cd_lws = pursue_mean.df_cd[&#x27;Iws&#x27;].sort_values()gz_lws = pursue_mean.df_gz[&#x27;Iws&#x27;].sort_values()sy_lws = pursue_mean.df_sy[&#x27;Iws&#x27;].sort_values() 再按照风速排序索引出PM2.5均值 12345bj_PM = pursue_mean.df_bj.loc[bj_lws.index, &#x27;PM_mean&#x27;]sh_PM = pursue_mean.df_sh.loc[sh_lws.index, &#x27;PM_mean&#x27;]cd_PM = pursue_mean.df_cd.loc[cd_lws.index, &#x27;PM_mean&#x27;]gz_PM = pursue_mean.df_gz.loc[gz_lws.index, &#x27;PM_mean&#x27;]sy_PM = pursue_mean.df_sy.loc[sy_lws.index, &#x27;PM_mean&#x27;] 作散点图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155# ToDO BeiJing Scatter Graphbj_scatter = ( Scatter() .add_xaxis(xaxis_data=bj_lws.values) .add_yaxis( series_name=&#x27;PM2.5&#x27;, y_axis=bj_PM.values, symbol_size=5, label_opts=opts.LabelOpts(is_show=False) ) .set_series_opts() .set_global_opts( title_opts=opts.TitleOpts(title=&quot;合成风速对PM2.5的影响&quot;), xaxis_opts=opts.AxisOpts( name=&#x27;合成风速(m/s)&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&quot;value&quot;, splitline_opts=opts.SplitLineOpts(is_show=True) ), yaxis_opts=opts.AxisOpts( name=&#x27;PM2.5&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&#x27;value&#x27;, axistick_opts=opts.AxisTickOpts(is_show=True), splitline_opts=opts.SplitLineOpts(is_show=True) ), tooltip_opts=opts.ToolboxOpts(), visualmap_opts=opts.VisualMapOpts( type_=&quot;color&quot;, max_=800, min_=5, dimension=1 ) ))# ToDO ShangHai Scatter Graphsh_scatter = ( Scatter() .add_xaxis(xaxis_data=sh_lws.values) .add_yaxis( series_name=&#x27;PM2.5&#x27;, y_axis=sh_PM.values, symbol_size=5, label_opts=opts.LabelOpts(is_show=False) ) .set_series_opts() .set_global_opts( title_opts=opts.TitleOpts(title=&quot;合成风速对PM2.5的影响&quot;), xaxis_opts=opts.AxisOpts( name=&#x27;合成风速(m/s)&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&quot;value&quot;, splitline_opts=opts.SplitLineOpts(is_show=True) ), yaxis_opts=opts.AxisOpts( name=&#x27;PM2.5&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&#x27;value&#x27;, axistick_opts=opts.AxisTickOpts(is_show=True), splitline_opts=opts.SplitLineOpts(is_show=True) ), tooltip_opts=opts.ToolboxOpts(), visualmap_opts=opts.VisualMapOpts( type_=&quot;color&quot;, max_=800, min_=5, dimension=1 ) ))# ToDO ChengDu Scatter Graphcd_scatter = ( Scatter() .add_xaxis(xaxis_data=cd_lws.values) .add_yaxis( series_name=&#x27;PM2.5&#x27;, y_axis=cd_PM.values, symbol_size=5, label_opts=opts.LabelOpts(is_show=False) ) .set_series_opts() .set_global_opts( title_opts=opts.TitleOpts(title=&quot;合成风速对PM2.5的影响&quot;), xaxis_opts=opts.AxisOpts( name=&#x27;合成风速(m/s)&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&quot;value&quot;, splitline_opts=opts.SplitLineOpts(is_show=True) ), yaxis_opts=opts.AxisOpts( name=&#x27;PM2.5&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&#x27;value&#x27;, axistick_opts=opts.AxisTickOpts(is_show=True), splitline_opts=opts.SplitLineOpts(is_show=True) ), tooltip_opts=opts.ToolboxOpts(), visualmap_opts=opts.VisualMapOpts( type_=&quot;color&quot;, max_=800, min_=5, dimension=1 ) ))# ToDO GuangZhou Scatter Graphgz_scatter = ( Scatter() .add_xaxis(xaxis_data=gz_lws.values) .add_yaxis( series_name=&#x27;PM2.5&#x27;, y_axis=gz_PM.values, symbol_size=5, label_opts=opts.LabelOpts(is_show=False) ) .set_series_opts() .set_global_opts( title_opts=opts.TitleOpts(title=&quot;合成风速对PM2.5的影响&quot;), xaxis_opts=opts.AxisOpts( name=&#x27;合成风速(m/s)&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&quot;value&quot;, splitline_opts=opts.SplitLineOpts(is_show=True) ), yaxis_opts=opts.AxisOpts( name=&#x27;PM2.5&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&#x27;value&#x27;, axistick_opts=opts.AxisTickOpts(is_show=True), splitline_opts=opts.SplitLineOpts(is_show=True) ), tooltip_opts=opts.ToolboxOpts(), visualmap_opts=opts.VisualMapOpts( type_=&quot;color&quot;, max_=800, min_=5, dimension=1 ) ))# ToDO ShenYang Scatter Graphsy_scatter = ( Scatter() .add_xaxis(xaxis_data=sy_lws.values) .add_yaxis( series_name=&#x27;PM2.5&#x27;, y_axis=sy_PM.values, symbol_size=5, label_opts=opts.LabelOpts(is_show=False) ) .set_series_opts() .set_global_opts( title_opts=opts.TitleOpts(title=&quot;合成风速对PM2.5的影响&quot;), xaxis_opts=opts.AxisOpts( name=&#x27;合成风速(m/s)&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&quot;value&quot;, splitline_opts=opts.SplitLineOpts(is_show=True) ), yaxis_opts=opts.AxisOpts( name=&#x27;PM2.5&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&#x27;value&#x27;, axistick_opts=opts.AxisTickOpts(is_show=True), splitline_opts=opts.SplitLineOpts(is_show=True) ), tooltip_opts=opts.ToolboxOpts(), visualmap_opts=opts.VisualMapOpts( type_=&quot;color&quot;, max_=800, min_=5, dimension=1 ) ))bj_scatter.render(&#x27;./picture/wind_speed_scatter/BeiJing.html&#x27;)sh_scatter.render(&#x27;./picture/wind_speed_scatter/ShangHai.html&#x27;)cd_scatter.render(&#x27;./picture/wind_speed_scatter/ChengDu.html&#x27;)gz_scatter.render(&#x27;./picture/wind_speed_scatter/GuangZhou.html&#x27;)sy_scatter.render(&#x27;./picture/wind_speed_scatter/ShenYang.html&#x27;) 北京 成都 广州 上海 沈阳 相对湿度对PM2.5的影响散点图(humidity_scatter.py) 先将湿度按顺序排序 123456789101112import pursue_meanfrom pyecharts.charts import Scatterfrom pyecharts import options as opts# pursue_mean.df_bj.info()bj_humid = pursue_mean.df_bj[&#x27;HUMI&#x27;].sort_values()sh_humid = pursue_mean.df_sh[&#x27;HUMI&#x27;].sort_values()cd_humid = pursue_mean.df_cd[&#x27;HUMI&#x27;].sort_values()gz_humid = pursue_mean.df_gz[&#x27;HUMI&#x27;].sort_values()# gz_humid = pursue_mean.df_gz.loc[pursue_mean.df_gz[&#x27;HUMI&#x27;].notnull(), [&#x27;HUMI&#x27;]].sort_values(&#x27;HUMI&#x27;)sy_humid = pursue_mean.df_sy[&#x27;HUMI&#x27;].sort_values() 再按照湿度排序索引出PM2.5均值 12345bj_PM_humid = pursue_mean.df_bj.loc[bj_humid.index, &#x27;PM_mean&#x27;]sh_PM_humid = pursue_mean.df_sh.loc[sh_humid.index, &#x27;PM_mean&#x27;]cd_PM_humid = pursue_mean.df_cd.loc[cd_humid.index, &#x27;PM_mean&#x27;]gz_PM_humid = pursue_mean.df_gz.loc[gz_humid.index, &#x27;PM_mean&#x27;]sy_PM_humid = pursue_mean.df_sy.loc[sy_humid.index, &#x27;PM_mean&#x27;] 作散点图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157# ToDO BeiJing Scatter Graphbj_humid_scatter = ( Scatter() .add_xaxis(xaxis_data=bj_humid.values) .add_yaxis( series_name=&#x27;PM2.5&#x27;, y_axis=bj_PM_humid.values, symbol_size=5, label_opts=opts.LabelOpts(is_show=False) ) .set_series_opts() .set_global_opts( title_opts=opts.TitleOpts(title=&quot;湿度对PM2.5的影响&quot;), xaxis_opts=opts.AxisOpts( name=&#x27;湿度(%)&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&quot;value&quot;, splitline_opts=opts.SplitLineOpts(is_show=True) ), yaxis_opts=opts.AxisOpts( name=&#x27;PM2.5&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&#x27;value&#x27;, axistick_opts=opts.AxisTickOpts(is_show=True), splitline_opts=opts.SplitLineOpts(is_show=True) ), tooltip_opts=opts.ToolboxOpts(), visualmap_opts=opts.VisualMapOpts( type_=&quot;color&quot;, max_=800, min_=5, dimension=1 ) ))# ToDO ShangHai Scatter Graphsh_humid_scatter = ( Scatter() .add_xaxis(xaxis_data=sh_humid.values) .add_yaxis( series_name=&#x27;PM2.5&#x27;, y_axis=sh_PM_humid.values, symbol_size=5, label_opts=opts.LabelOpts(is_show=False) ) .set_series_opts() .set_global_opts( title_opts=opts.TitleOpts(title=&quot;湿度对PM2.5的影响&quot;), xaxis_opts=opts.AxisOpts( name=&#x27;湿度(%)&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&quot;value&quot;, splitline_opts=opts.SplitLineOpts(is_show=True) ), yaxis_opts=opts.AxisOpts( name=&#x27;PM2.5&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&#x27;value&#x27;, axistick_opts=opts.AxisTickOpts(is_show=True), splitline_opts=opts.SplitLineOpts(is_show=True) ), tooltip_opts=opts.ToolboxOpts(), visualmap_opts=opts.VisualMapOpts( type_=&quot;color&quot;, max_=800, min_=5, dimension=1 ) ))# ToDO ChengDu Scatter Graphcd_humid_scatter = ( Scatter() .add_xaxis(xaxis_data=cd_humid.values) .add_yaxis( series_name=&#x27;PM2.5&#x27;, y_axis=cd_PM_humid.values, symbol_size=5, label_opts=opts.LabelOpts(is_show=False) ) .set_series_opts() .set_global_opts( title_opts=opts.TitleOpts(title=&quot;湿度对PM2.5的影响&quot;), xaxis_opts=opts.AxisOpts( name=&#x27;湿度(%)&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&quot;value&quot;, splitline_opts=opts.SplitLineOpts(is_show=True) ), yaxis_opts=opts.AxisOpts( name=&#x27;PM2.5&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&#x27;value&#x27;, axistick_opts=opts.AxisTickOpts(is_show=True), splitline_opts=opts.SplitLineOpts(is_show=True) ), tooltip_opts=opts.ToolboxOpts(), visualmap_opts=opts.VisualMapOpts( type_=&quot;color&quot;, max_=800, min_=5, dimension=1 ) ))# ToDO GuangZhou Scatter Graphgz_humid_scatter = ( Scatter() .add_xaxis(xaxis_data=gz_humid.values) .add_yaxis( series_name=&#x27;PM2.5&#x27;, y_axis=gz_PM_humid.values, symbol_size=5, label_opts=opts.LabelOpts(is_show=False) ) .set_series_opts() .set_global_opts( title_opts=opts.TitleOpts(title=&quot;湿度对PM2.5的影响&quot;), xaxis_opts=opts.AxisOpts( name=&#x27;湿度(%)&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&quot;value&quot;, splitline_opts=opts.SplitLineOpts(is_show=True), min_=0, max_=100 ), yaxis_opts=opts.AxisOpts( name=&#x27;PM2.5&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&#x27;value&#x27;, axistick_opts=opts.AxisTickOpts(is_show=True), splitline_opts=opts.SplitLineOpts(is_show=True) ), tooltip_opts=opts.ToolboxOpts(), visualmap_opts=opts.VisualMapOpts( type_=&quot;color&quot;, max_=800, min_=5, dimension=1 ) ))# ToDO ShenYang Scatter Graphsy_humid_scatter = ( Scatter() .add_xaxis(xaxis_data=sy_humid.values) .add_yaxis( series_name=&#x27;PM2.5&#x27;, y_axis=sy_PM_humid.values, symbol_size=5, label_opts=opts.LabelOpts(is_show=False) ) .set_series_opts() .set_global_opts( title_opts=opts.TitleOpts(title=&quot;湿度对PM2.5的影响&quot;), xaxis_opts=opts.AxisOpts( name=&#x27;湿度(%)&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&quot;value&quot;, splitline_opts=opts.SplitLineOpts(is_show=True) ), yaxis_opts=opts.AxisOpts( name=&#x27;PM2.5&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&#x27;value&#x27;, axistick_opts=opts.AxisTickOpts(is_show=True), splitline_opts=opts.SplitLineOpts(is_show=True) ), tooltip_opts=opts.ToolboxOpts(), visualmap_opts=opts.VisualMapOpts( type_=&quot;color&quot;, max_=800, min_=5, dimension=1 ) ))bj_humid_scatter.render(&#x27;./picture/humidity_scatter/humid_BeiJing.html&#x27;)sh_humid_scatter.render(&#x27;./picture/humidity_scatter/humid_ShangHai.html&#x27;)cd_humid_scatter.render(&#x27;./picture/humidity_scatter/humid_ChengDu.html&#x27;)gz_humid_scatter.render(&#x27;./picture/humidity_scatter/humid_GuangZhou.html&#x27;)sy_humid_scatter.render(&#x27;./picture/humidity_scatter/humid_ShenYang.html&#x27;) 北京 成都 广州 上海 沈阳 气压对PM2.5的影响散点图(pressure_scatter.py) 先将气压按顺序排序 123456789import pursue_meanfrom pyecharts.charts import Scatterfrom pyecharts import options as optsbj_pres = pursue_mean.df_bj[&#x27;PRES&#x27;].sort_values()sh_pres = pursue_mean.df_sh[&#x27;PRES&#x27;].sort_values()cd_pres = pursue_mean.df_cd[&#x27;PRES&#x27;].sort_values()gz_pres = pursue_mean.df_gz[&#x27;PRES&#x27;].sort_values()sy_pres = pursue_mean.df_sy[&#x27;PRES&#x27;].sort_values() 再按照气压排序索引出PM2.5均值 12345bj_PM_pres = pursue_mean.df_bj.loc[bj_pres.index, &#x27;PM_mean&#x27;]sh_PM_pres = pursue_mean.df_sh.loc[sh_pres.index, &#x27;PM_mean&#x27;]cd_PM_pres = pursue_mean.df_cd.loc[cd_pres.index, &#x27;PM_mean&#x27;]gz_PM_pres = pursue_mean.df_gz.loc[gz_pres.index, &#x27;PM_mean&#x27;]sy_PM_pres = pursue_mean.df_sy.loc[sy_pres.index, &#x27;PM_mean&#x27;] 作散点图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162# ToDO BeiJing Scatter Graphbj_pressure_scatter = ( Scatter() .add_xaxis(xaxis_data=bj_pres.values) .add_yaxis( series_name=&#x27;PM2.5&#x27;, y_axis=bj_PM_pres.values, symbol_size=5, label_opts=opts.LabelOpts(is_show=False) ) .set_series_opts() .set_global_opts( title_opts=opts.TitleOpts(title=&quot;气压对PM2.5的影响&quot;), xaxis_opts=opts.AxisOpts( name=&#x27;气压(hpa)&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&quot;value&quot;, splitline_opts=opts.SplitLineOpts(is_show=True), min_=990 ), yaxis_opts=opts.AxisOpts( name=&#x27;PM2.5&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&#x27;value&#x27;, axistick_opts=opts.AxisTickOpts(is_show=True), splitline_opts=opts.SplitLineOpts(is_show=True) ), tooltip_opts=opts.ToolboxOpts(), visualmap_opts=opts.VisualMapOpts( type_=&quot;color&quot;, max_=800, min_=5, dimension=1 ) ))# ToDO ShangHai Scatter Graphsh_pressure_scatter = ( Scatter() .add_xaxis(xaxis_data=sh_pres.values) .add_yaxis( series_name=&#x27;PM2.5&#x27;, y_axis=sh_PM_pres.values, symbol_size=5, label_opts=opts.LabelOpts(is_show=False) ) .set_series_opts() .set_global_opts( title_opts=opts.TitleOpts(title=&quot;气压对PM2.5的影响&quot;), xaxis_opts=opts.AxisOpts( name=&#x27;气压(hpa)&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&quot;value&quot;, splitline_opts=opts.SplitLineOpts(is_show=True), min_=987, max_=1042 ), yaxis_opts=opts.AxisOpts( name=&#x27;PM2.5&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&#x27;value&#x27;, axistick_opts=opts.AxisTickOpts(is_show=True), splitline_opts=opts.SplitLineOpts(is_show=True) ), tooltip_opts=opts.ToolboxOpts(), visualmap_opts=opts.VisualMapOpts( type_=&quot;color&quot;, max_=800, min_=5, dimension=1 ) ))# ToDO ChengDu Scatter Graphcd_pressure_scatter = ( Scatter() .add_xaxis(xaxis_data=cd_pres.values) .add_yaxis( series_name=&#x27;PM2.5&#x27;, y_axis=cd_PM_pres.values, symbol_size=5, label_opts=opts.LabelOpts(is_show=False) ) .set_series_opts() .set_global_opts( title_opts=opts.TitleOpts(title=&quot;气压对PM2.5的影响&quot;), xaxis_opts=opts.AxisOpts( name=&#x27;气压(hpa)&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&quot;value&quot;, splitline_opts=opts.SplitLineOpts(is_show=True), min_=990 ), yaxis_opts=opts.AxisOpts( name=&#x27;PM2.5&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&#x27;value&#x27;, axistick_opts=opts.AxisTickOpts(is_show=True), splitline_opts=opts.SplitLineOpts(is_show=True) ), tooltip_opts=opts.ToolboxOpts(), visualmap_opts=opts.VisualMapOpts( type_=&quot;color&quot;, max_=800, min_=5, dimension=1 ) ))# ToDO GuangZhou Scatter Graphgz_pressure_scatter = ( Scatter() .add_xaxis(xaxis_data=gz_pres.values) .add_yaxis( series_name=&#x27;PM2.5&#x27;, y_axis=gz_PM_pres.values, symbol_size=5, label_opts=opts.LabelOpts(is_show=False) ) .set_series_opts() .set_global_opts( title_opts=opts.TitleOpts(title=&quot;气压对PM2.5的影响&quot;), xaxis_opts=opts.AxisOpts( name=&#x27;气压(hpa)&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&quot;value&quot;, splitline_opts=opts.SplitLineOpts(is_show=True), min_=974 ), yaxis_opts=opts.AxisOpts( name=&#x27;PM2.5&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&#x27;value&#x27;, axistick_opts=opts.AxisTickOpts(is_show=True), splitline_opts=opts.SplitLineOpts(is_show=True) ), tooltip_opts=opts.ToolboxOpts(), visualmap_opts=opts.VisualMapOpts( type_=&quot;color&quot;, max_=800, min_=5, dimension=1 ) ))# ToDO ShenYang Scatter Graphsy_pressure_scatter = ( Scatter() .add_xaxis(xaxis_data=sy_pres.values) .add_yaxis( series_name=&#x27;PM2.5&#x27;, y_axis=sy_PM_pres.values, symbol_size=5, label_opts=opts.LabelOpts(is_show=False) ) .set_series_opts() .set_global_opts( title_opts=opts.TitleOpts(title=&quot;气压对PM2.5的影响&quot;), xaxis_opts=opts.AxisOpts( name=&#x27;气压(hpa)&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&quot;value&quot;, splitline_opts=opts.SplitLineOpts(is_show=True), min_=985, max_=1045 ), yaxis_opts=opts.AxisOpts( name=&#x27;PM2.5&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&#x27;value&#x27;, axistick_opts=opts.AxisTickOpts(is_show=True), splitline_opts=opts.SplitLineOpts(is_show=True) ), tooltip_opts=opts.ToolboxOpts(), visualmap_opts=opts.VisualMapOpts( type_=&quot;color&quot;, max_=800, min_=5, dimension=1 ) ))bj_pressure_scatter.render(&#x27;./picture/pressure_scatter/pressure_BeiJing.html&#x27;)sh_pressure_scatter.render(&#x27;./picture/pressure_scatter/pressure_ShangHai.html&#x27;)cd_pressure_scatter.render(&#x27;./picture/pressure_scatter/pressure_ChengDu.html&#x27;)gz_pressure_scatter.render(&#x27;./picture/pressure_scatter/pressure_GuangZhou.html&#x27;)sy_pressure_scatter.render(&#x27;./picture/pressure_scatter/pressure_ShenYang.html&#x27;) 北京 成都 广州 上海 沈阳 温度对PM2.5的影响散点图(temperature_scatter.py) 先将温度按顺序排序 123456789import pursue_meanfrom pyecharts.charts import Scatterfrom pyecharts import options as optsbj_temp = pursue_mean.df_bj[&#x27;TEMP&#x27;].sort_values()sh_temp = pursue_mean.df_sh[&#x27;TEMP&#x27;].sort_values()cd_temp = pursue_mean.df_cd[&#x27;TEMP&#x27;].sort_values()gz_temp = pursue_mean.df_gz[&#x27;TEMP&#x27;].sort_values()sy_temp = pursue_mean.df_sy[&#x27;TEMP&#x27;].sort_values() 再按照温度排序索引出PM2.5均值 12345bj_PM_temp = pursue_mean.df_bj.loc[bj_temp.index, &#x27;PM_mean&#x27;]sh_PM_temp = pursue_mean.df_sh.loc[sh_temp.index, &#x27;PM_mean&#x27;]cd_PM_temp = pursue_mean.df_cd.loc[cd_temp.index, &#x27;PM_mean&#x27;]gz_PM_temp = pursue_mean.df_gz.loc[gz_temp.index, &#x27;PM_mean&#x27;]sy_PM_temp = pursue_mean.df_sy.loc[sy_temp.index, &#x27;PM_mean&#x27;] 作散点图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155# TODO BeiJing Scatter Graphbj_temp_scatter = ( Scatter() .add_xaxis(xaxis_data=bj_temp.values) .add_yaxis( series_name=&#x27;PM2.5&#x27;, y_axis=bj_PM_temp.values, symbol_size=5, label_opts=opts.LabelOpts(is_show=False) ) .set_series_opts() .set_global_opts( title_opts=opts.TitleOpts(title=&quot;温度对PM2.5的影响&quot;), xaxis_opts=opts.AxisOpts( name=&#x27;温度(℃)&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&quot;value&quot;, splitline_opts=opts.SplitLineOpts(is_show=True) ), yaxis_opts=opts.AxisOpts( name=&#x27;PM2.5&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&#x27;value&#x27;, axistick_opts=opts.AxisTickOpts(is_show=True), splitline_opts=opts.SplitLineOpts(is_show=True) ), tooltip_opts=opts.ToolboxOpts(), visualmap_opts=opts.VisualMapOpts( type_=&quot;color&quot;, max_=800, min_=5, dimension=1 ) ))# ToDO ShangHai Scatter Graphsh_temp_scatter = ( Scatter() .add_xaxis(xaxis_data=sh_temp.values) .add_yaxis( series_name=&#x27;PM2.5&#x27;, y_axis=sh_PM_temp.values, symbol_size=5, label_opts=opts.LabelOpts(is_show=False) ) .set_series_opts() .set_global_opts( title_opts=opts.TitleOpts(title=&quot;温度对PM2.5的影响&quot;), xaxis_opts=opts.AxisOpts( name=&#x27;温度(℃)&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&quot;value&quot;, splitline_opts=opts.SplitLineOpts(is_show=True) ), yaxis_opts=opts.AxisOpts( name=&#x27;PM2.5&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&#x27;value&#x27;, axistick_opts=opts.AxisTickOpts(is_show=True), splitline_opts=opts.SplitLineOpts(is_show=True) ), tooltip_opts=opts.ToolboxOpts(), visualmap_opts=opts.VisualMapOpts( type_=&quot;color&quot;, max_=800, min_=5, dimension=1 ) ))# ToDO ChengDu Scatter Graphcd_temp_scatter = ( Scatter() .add_xaxis(xaxis_data=cd_temp.values) .add_yaxis( series_name=&#x27;PM2.5&#x27;, y_axis=cd_PM_temp.values, symbol_size=5, label_opts=opts.LabelOpts(is_show=False) ) .set_series_opts() .set_global_opts( title_opts=opts.TitleOpts(title=&quot;温度对PM2.5的影响&quot;), xaxis_opts=opts.AxisOpts( name=&#x27;温度(℃)&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&quot;value&quot;, splitline_opts=opts.SplitLineOpts(is_show=True) ), yaxis_opts=opts.AxisOpts( name=&#x27;PM2.5&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&#x27;value&#x27;, axistick_opts=opts.AxisTickOpts(is_show=True), splitline_opts=opts.SplitLineOpts(is_show=True) ), tooltip_opts=opts.ToolboxOpts(), visualmap_opts=opts.VisualMapOpts( type_=&quot;color&quot;, max_=800, min_=5, dimension=1 ) ))# ToDO GuangZhou Scatter Graphgz_temp_scatter = ( Scatter() .add_xaxis(xaxis_data=gz_temp.values) .add_yaxis( series_name=&#x27;PM2.5&#x27;, y_axis=gz_PM_temp.values, symbol_size=5, label_opts=opts.LabelOpts(is_show=False) ) .set_series_opts() .set_global_opts( title_opts=opts.TitleOpts(title=&quot;温度对PM2.5的影响&quot;), xaxis_opts=opts.AxisOpts( name=&#x27;温度(℃)&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&quot;value&quot;, splitline_opts=opts.SplitLineOpts(is_show=True) ), yaxis_opts=opts.AxisOpts( name=&#x27;PM2.5&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&#x27;value&#x27;, axistick_opts=opts.AxisTickOpts(is_show=True), splitline_opts=opts.SplitLineOpts(is_show=True) ), tooltip_opts=opts.ToolboxOpts(), visualmap_opts=opts.VisualMapOpts( type_=&quot;color&quot;, max_=800, min_=5, dimension=1 ) ))# ToDO ShenYang Scatter Graphsy_temp_scatter = ( Scatter() .add_xaxis(xaxis_data=sy_temp.values) .add_yaxis( series_name=&#x27;PM2.5&#x27;, y_axis=sy_PM_temp.values, symbol_size=5, label_opts=opts.LabelOpts(is_show=False) ) .set_series_opts() .set_global_opts( title_opts=opts.TitleOpts(title=&quot;温度对PM2.5的影响&quot;), xaxis_opts=opts.AxisOpts( name=&#x27;温度(℃)&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&quot;value&quot;, splitline_opts=opts.SplitLineOpts(is_show=True) ), yaxis_opts=opts.AxisOpts( name=&#x27;PM2.5&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&#x27;value&#x27;, axistick_opts=opts.AxisTickOpts(is_show=True), splitline_opts=opts.SplitLineOpts(is_show=True) ), tooltip_opts=opts.ToolboxOpts(), visualmap_opts=opts.VisualMapOpts( type_=&quot;color&quot;, max_=800, min_=5, dimension=1 ) ))bj_temp_scatter.render(&#x27;./picture/temperature_scatter/temperature_BeiJing.html&#x27;)sh_temp_scatter.render(&#x27;./picture/temperature_scatter/temperature_ShangHai.html&#x27;)cd_temp_scatter.render(&#x27;./picture/temperature_scatter/temperature_ChengDu.html&#x27;)gz_temp_scatter.render(&#x27;./picture/temperature_scatter/temperature_GuangZhou.html&#x27;)sy_temp_scatter.render(&#x27;./picture/temperature_scatter/temperature_ShenYang.html&#x27;) 北京 成都 广州 上海 沈阳 降水量对PM2.5的影响散点图(accum_precipitation_scatter.py) 先将降水量按顺序排序 123456789import pursue_meanfrom pyecharts.charts import Scatterfrom pyecharts import options as optsbj_precipitation = pursue_mean.df_bj[&#x27;Iprec&#x27;].sort_values()sh_precipitation = pursue_mean.df_sh[&#x27;Iprec&#x27;].sort_values()cd_precipitation = pursue_mean.df_cd[&#x27;Iprec&#x27;].sort_values()gz_precipitation = pursue_mean.df_gz[&#x27;Iprec&#x27;].sort_values()sy_precipitation = pursue_mean.df_sy[&#x27;Iprec&#x27;].sort_values() 再按照降水量排序索引出PM2.5均值 12345bj_PM_precipitation = pursue_mean.df_bj.loc[bj_precipitation.index, &#x27;PM_mean&#x27;]sh_PM_precipitation = pursue_mean.df_sh.loc[sh_precipitation.index, &#x27;PM_mean&#x27;]cd_PM_precipitation = pursue_mean.df_cd.loc[cd_precipitation.index, &#x27;PM_mean&#x27;]gz_PM_precipitation = pursue_mean.df_gz.loc[gz_precipitation.index, &#x27;PM_mean&#x27;]sy_PM_precipitation = pursue_mean.df_sy.loc[sy_precipitation.index, &#x27;PM_mean&#x27;] 作散点图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156# TODO BeiJing Scatter Graphbj_precipitation_scatter = ( Scatter() .add_xaxis(xaxis_data=bj_precipitation.values) .add_yaxis( series_name=&#x27;PM2.5&#x27;, y_axis=bj_PM_precipitation.values, symbol_size=5, label_opts=opts.LabelOpts(is_show=False) ) .set_series_opts() .set_global_opts( title_opts=opts.TitleOpts(title=&quot;累计降雨量对PM2.5的影响&quot;), xaxis_opts=opts.AxisOpts( name=&#x27;累计降雨量(mm)&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&quot;value&quot;, splitline_opts=opts.SplitLineOpts(is_show=True), max_=250 ), yaxis_opts=opts.AxisOpts( name=&#x27;PM2.5&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&#x27;value&#x27;, axistick_opts=opts.AxisTickOpts(is_show=True), splitline_opts=opts.SplitLineOpts(is_show=True) ), tooltip_opts=opts.ToolboxOpts(), visualmap_opts=opts.VisualMapOpts( type_=&quot;color&quot;, max_=800, min_=5, dimension=1 ) ))# ToDO ShangHai Scatter Graphsh_precipitation_scatter = ( Scatter() .add_xaxis(xaxis_data=sh_precipitation.values) .add_yaxis( series_name=&#x27;PM2.5&#x27;, y_axis=sh_PM_precipitation.values, symbol_size=5, label_opts=opts.LabelOpts(is_show=False) ) .set_series_opts() .set_global_opts( title_opts=opts.TitleOpts(title=&quot;累计降雨量对PM2.5的影响&quot;), xaxis_opts=opts.AxisOpts( name=&#x27;累计降雨量(mm)&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&quot;value&quot;, splitline_opts=opts.SplitLineOpts(is_show=True) ), yaxis_opts=opts.AxisOpts( name=&#x27;PM2.5&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&#x27;value&#x27;, axistick_opts=opts.AxisTickOpts(is_show=True), splitline_opts=opts.SplitLineOpts(is_show=True) ), tooltip_opts=opts.ToolboxOpts(), visualmap_opts=opts.VisualMapOpts( type_=&quot;color&quot;, max_=800, min_=5, dimension=1 ) ))# ToDO ChengDu Scatter Graphcd_precipitation_scatter = ( Scatter() .add_xaxis(xaxis_data=cd_precipitation.values) .add_yaxis( series_name=&#x27;PM2.5&#x27;, y_axis=cd_PM_precipitation.values, symbol_size=5, label_opts=opts.LabelOpts(is_show=False) ) .set_series_opts() .set_global_opts( title_opts=opts.TitleOpts(title=&quot;累计降雨量对PM2.5的影响&quot;), xaxis_opts=opts.AxisOpts( name=&#x27;累计降雨量(mm)&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&quot;value&quot;, splitline_opts=opts.SplitLineOpts(is_show=True) ), yaxis_opts=opts.AxisOpts( name=&#x27;PM2.5&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&#x27;value&#x27;, axistick_opts=opts.AxisTickOpts(is_show=True), splitline_opts=opts.SplitLineOpts(is_show=True) ), tooltip_opts=opts.ToolboxOpts(), visualmap_opts=opts.VisualMapOpts( type_=&quot;color&quot;, max_=800, min_=5, dimension=1 ) ))# ToDO GuangZhou Scatter Graphgz_precipitation_scatter = ( Scatter() .add_xaxis(xaxis_data=gz_precipitation.values) .add_yaxis( series_name=&#x27;PM2.5&#x27;, y_axis=gz_PM_precipitation.values, symbol_size=5, label_opts=opts.LabelOpts(is_show=False) ) .set_series_opts() .set_global_opts( title_opts=opts.TitleOpts(title=&quot;累计降雨量对PM2.5的影响&quot;), xaxis_opts=opts.AxisOpts( name=&#x27;累计降雨量(mm)&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&quot;value&quot;, splitline_opts=opts.SplitLineOpts(is_show=True) ), yaxis_opts=opts.AxisOpts( name=&#x27;PM2.5&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&#x27;value&#x27;, axistick_opts=opts.AxisTickOpts(is_show=True), splitline_opts=opts.SplitLineOpts(is_show=True) ), tooltip_opts=opts.ToolboxOpts(), visualmap_opts=opts.VisualMapOpts( type_=&quot;color&quot;, max_=800, min_=5, dimension=1 ) ))# ToDO ShenYang Scatter Graphsy_precipitation_scatter = ( Scatter() .add_xaxis(xaxis_data=sy_precipitation.values) .add_yaxis( series_name=&#x27;PM2.5&#x27;, y_axis=sy_PM_precipitation.values, symbol_size=5, label_opts=opts.LabelOpts(is_show=False) ) .set_series_opts() .set_global_opts( title_opts=opts.TitleOpts(title=&quot;累计降雨量对PM2.5的影响&quot;), xaxis_opts=opts.AxisOpts( name=&#x27;累计降雨量(mm)&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&quot;value&quot;, splitline_opts=opts.SplitLineOpts(is_show=True) ), yaxis_opts=opts.AxisOpts( name=&#x27;PM2.5&#x27;, name_location=&#x27;middle&#x27;, name_gap=30, type_=&#x27;value&#x27;, axistick_opts=opts.AxisTickOpts(is_show=True), splitline_opts=opts.SplitLineOpts(is_show=True) ), tooltip_opts=opts.ToolboxOpts(), visualmap_opts=opts.VisualMapOpts( type_=&quot;color&quot;, max_=800, min_=5, dimension=1 ) ))bj_precipitation_scatter.render(&#x27;./picture/precipitation_scatter/precipitation_BeiJing.html&#x27;)sh_precipitation_scatter.render(&#x27;./picture/precipitation_scatter/precipitation_ShangHai.html&#x27;)cd_precipitation_scatter.render(&#x27;./picture/precipitation_scatter/precipitation_ChengDu.html&#x27;)gz_precipitation_scatter.render(&#x27;./picture/precipitation_scatter/precipitation_GuangZhou.html&#x27;)sy_precipitation_scatter.render(&#x27;./picture/precipitation_scatter/precipitation_ShenYang.html&#x27;) 北京 成都 广州 上海 沈阳 五城市每个区空气质量的月度差异(month_PM25_line.py) 先将不同城区数据按照月份聚类 1234567891011121314151617181920212223242526272829303132333435import pursue_meanimport matplotlib.pyplot as pltimport numpy as np# TODO group by monthbj_month_PM_mean_1 = pursue_mean.df_bj.loc[pursue_mean.df_bj[&#x27;PM_Dongsi&#x27;].notnull(), [&#x27;PM_Dongsi&#x27;]]. \\ groupby(pursue_mean.df_bj[&#x27;month&#x27;]).mean()bj_month_PM_mean_2 = pursue_mean.df_bj.loc[pursue_mean.df_bj[&#x27;PM_Dongsihuan&#x27;].notnull(), [&#x27;PM_Dongsihuan&#x27;]]. \\ groupby(pursue_mean.df_bj[&#x27;month&#x27;]).mean()bj_month_PM_mean_3 = pursue_mean.df_bj.loc[pursue_mean.df_bj[&#x27;PM_Nongzhanguan&#x27;].notnull(), [&#x27;PM_Nongzhanguan&#x27;]]. \\ groupby(pursue_mean.df_bj[&#x27;month&#x27;]).mean()sh_month_PM_mean_1 = pursue_mean.df_sh.loc[pursue_mean.df_sh[&#x27;PM_Jingan&#x27;].notnull(), [&#x27;PM_Jingan&#x27;]]. \\ groupby(pursue_mean.df_sh[&#x27;month&#x27;]).mean()sh_month_PM_mean_2 = pursue_mean.df_sh.loc[pursue_mean.df_sh[&#x27;PM_Xuhui&#x27;].notnull(), [&#x27;PM_Xuhui&#x27;]]. \\ groupby(pursue_mean.df_sh[&#x27;month&#x27;]).mean()cd_month_PM_mean_1 = pursue_mean.df_cd.loc[pursue_mean.df_cd[&#x27;PM_Caotangsi&#x27;].notnull(), [&#x27;PM_Caotangsi&#x27;]]. \\ groupby(pursue_mean.df_cd[&#x27;month&#x27;]).mean()cd_month_PM_mean_2 = pursue_mean.df_cd.loc[pursue_mean.df_cd[&#x27;PM_Shahepu&#x27;].notnull(), [&#x27;PM_Shahepu&#x27;]]. \\ groupby(pursue_mean.df_cd[&#x27;month&#x27;]).mean()gz_month_PM_mean_1 = pursue_mean.df_gz.loc[pursue_mean.df_gz[&#x27;PM_City Station&#x27;].notnull(), [&#x27;PM_City Station&#x27;]]. \\ groupby(pursue_mean.df_gz[&#x27;month&#x27;]).mean()gz_month_PM_mean_2 = pursue_mean.df_gz.loc[pursue_mean.df_gz[&#x27;PM_5th Middle School&#x27;].notnull(), [&#x27;PM_5th Middle School&#x27;]]\\ .groupby(pursue_mean.df_gz[&#x27;month&#x27;]).mean()sy_month_PM_mean_1 = pursue_mean.df_sy.loc[pursue_mean.df_sy[&#x27;PM_Taiyuanjie&#x27;].notnull(), [&#x27;PM_Taiyuanjie&#x27;]]. \\ groupby(pursue_mean.df_sy[&#x27;month&#x27;]).mean()sy_month_PM_mean_2 = pursue_mean.df_sy.loc[pursue_mean.df_sy[&#x27;PM_Xiaoheyan&#x27;].notnull(), [&#x27;PM_Xiaoheyan&#x27;]]. \\ groupby(pursue_mean.df_sy[&#x27;month&#x27;]).mean() 作折线图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185plt.rcParams[&#x27;font.sans-serif&#x27;] = [&#x27;SimHei&#x27;] # 如果要显示中文字体,则在此处设为：SimHeiplt.rcParams[&#x27;axes.unicode_minus&#x27;] = False # 显示负号x = np.array([i for i in range(1, 13)])BeiJing_1 = np.array(bj_month_PM_mean_1.values)BeiJing_2 = np.array(bj_month_PM_mean_2.values)BeiJing_3 = np.array(bj_month_PM_mean_3.values)ShangHai_1 = np.array(sh_month_PM_mean_1.values)ShangHai_2 = np.array(sh_month_PM_mean_2.values)ChengDu_1 = np.array(cd_month_PM_mean_1.values)ChengDu_2 = np.array(cd_month_PM_mean_2.values)GuangZhou_1 = np.array(gz_month_PM_mean_1.values)GuangZhou_2 = np.array(gz_month_PM_mean_2.values)ShenYang_1 = np.array(sy_month_PM_mean_1.values)ShenYang_2 = np.array(sy_month_PM_mean_2.values)# TODO BeiJing line graph# label在图示(legend)中显示。若为数学公式,则最好在字符串前后添加&quot;$&quot;符号# color：b:blue、g:green、r:red、c:cyan、m:magenta、y:yellow、k:black、w:white、、、# 线型：- -- -. : ,# marker：. , o v &lt; * + 1plt.figure(num=&#x27;北京&#x27;, figsize=(10, 5))plt.grid(linestyle=&quot;--&quot;) # 设置背景网格线为虚线ax = plt.gca()ax.spines[&#x27;top&#x27;].set_visible(False) # 去掉上边框ax.spines[&#x27;right&#x27;].set_visible(False) # 去掉右边框plt.plot(x, BeiJing_1, marker=&#x27;o&#x27;, color=&quot;blue&quot;, label=&quot;Dongsi&quot;, linewidth=1.5)plt.plot(x, BeiJing_2, marker=&#x27;o&#x27;, color=&quot;red&quot;, label=&quot;Dongsihuan&quot;, linewidth=1.5)plt.plot(x, BeiJing_3, marker=&#x27;o&#x27;, color=&quot;magenta&quot;, label=&quot;Nongzhanguan&quot;, linewidth=1.5)group_labels = [&#x27;&#123;&#125;月&#x27;.format(i) for i in range(1, 13)] # x轴刻度的标识plt.xticks(x, group_labels, fontsize=12, fontweight=&#x27;bold&#x27;) # 默认字体大小为10plt.yticks(fontsize=12, fontweight=&#x27;bold&#x27;)plt.title(&quot;北京市不同城区PM2.5均值逐月变化&quot;, fontsize=12, fontweight=&#x27;bold&#x27;) # 默认字体大小为12plt.xlabel(&quot;月份&quot;, fontsize=13, fontweight=&#x27;bold&#x27;)plt.ylabel(&quot;PM2.5均值&quot;, fontsize=13, fontweight=&#x27;bold&#x27;)plt.xlim(0, 13) # 设置x轴的范围plt.ylim(30, 140)# plt.legend() #显示各曲线的图例plt.legend(loc=0, numpoints=1)leg = plt.gca().get_legend()ltext = leg.get_texts()plt.setp(ltext, fontsize=12, fontweight=&#x27;bold&#x27;) # 设置图例字体的大小和粗细plt.savefig(&#x27;./picture/district_month_line/BeiJing_month_line_graph.jpg&#x27;) # 建议保存为svg格式,再用inkscape转为矢量图emf后插入word中plt.show()# TODO ShangHai line graph# label在图示(legend)中显示。若为数学公式,则最好在字符串前后添加&quot;$&quot;符号# color：b:blue、g:green、r:red、c:cyan、m:magenta、y:yellow、k:black、w:white、、、# 线型：- -- -. : ,# marker：. , o v &lt; * + 1plt.figure(num=&#x27;上海&#x27;, figsize=(10, 5))plt.grid(linestyle=&quot;--&quot;) # 设置背景网格线为虚线ax = plt.gca()ax.spines[&#x27;top&#x27;].set_visible(False) # 去掉上边框ax.spines[&#x27;right&#x27;].set_visible(False) # 去掉右边框plt.plot(x, ShangHai_1, marker=&#x27;o&#x27;, color=&quot;green&quot;, label=&quot;Jingan&quot;, linewidth=1.5)plt.plot(x, ShangHai_2, marker=&#x27;o&#x27;, color=&quot;blue&quot;, label=&quot;Xuhui&quot;, linewidth=1.5)group_labels = [&#x27;&#123;&#125;月&#x27;.format(i) for i in range(1, 13)] # x轴刻度的标识plt.xticks(x, group_labels, fontsize=12, fontweight=&#x27;bold&#x27;) # 默认字体大小为10plt.yticks(fontsize=12, fontweight=&#x27;bold&#x27;)plt.title(&quot;上海市不同城区PM2.5均值逐月变化&quot;, fontsize=12, fontweight=&#x27;bold&#x27;) # 默认字体大小为12plt.xlabel(&quot;月份&quot;, fontsize=13, fontweight=&#x27;bold&#x27;)plt.ylabel(&quot;PM2.5均值&quot;, fontsize=13, fontweight=&#x27;bold&#x27;)plt.xlim(0, 13) # 设置x轴的范围plt.ylim(25, 120)# plt.legend() #显示各曲线的图例plt.legend(loc=0, numpoints=1)leg = plt.gca().get_legend()ltext = leg.get_texts()plt.setp(ltext, fontsize=12, fontweight=&#x27;bold&#x27;) # 设置图例字体的大小和粗细plt.savefig(&#x27;./picture/district_month_line/ShangHai_month_line_graph.jpg&#x27;) # 建议保存为svg格式,再用inkscape转为矢量图emf后插入word中plt.show()# TODO ChengDu line graph# label在图示(legend)中显示。若为数学公式,则最好在字符串前后添加&quot;$&quot;符号# color：b:blue、g:green、r:red、c:cyan、m:magenta、y:yellow、k:black、w:white、、、# 线型：- -- -. : ,# marker：. , o v &lt; * + 1plt.figure(num=&#x27;成都&#x27;, figsize=(10, 5))plt.grid(linestyle=&quot;--&quot;) # 设置背景网格线为虚线ax = plt.gca()ax.spines[&#x27;top&#x27;].set_visible(False) # 去掉上边框ax.spines[&#x27;right&#x27;].set_visible(False) # 去掉右边框plt.plot(x, ChengDu_1, marker=&#x27;o&#x27;, color=&quot;red&quot;, label=&quot;Caotangsi&quot;, linewidth=1.5)plt.plot(x, ChengDu_2, marker=&#x27;o&#x27;, color=&quot;black&quot;, label=&quot;Shahepu&quot;, linewidth=1.5)group_labels = [&#x27;&#123;&#125;月&#x27;.format(i) for i in range(1, 13)] # x轴刻度的标识plt.xticks(x, group_labels, fontsize=12, fontweight=&#x27;bold&#x27;) # 默认字体大小为10plt.yticks(fontsize=12, fontweight=&#x27;bold&#x27;)plt.title(&quot;成都市不同城区PM2.5均值逐月变化&quot;, fontsize=12, fontweight=&#x27;bold&#x27;) # 默认字体大小为12plt.xlabel(&quot;月份&quot;, fontsize=13, fontweight=&#x27;bold&#x27;)plt.ylabel(&quot;PM2.5均值&quot;, fontsize=13, fontweight=&#x27;bold&#x27;)plt.xlim(0, 13) # 设置x轴的范围plt.ylim(30, )# plt.legend() #显示各曲线的图例plt.legend(loc=0, numpoints=1)leg = plt.gca().get_legend()ltext = leg.get_texts()plt.setp(ltext, fontsize=12, fontweight=&#x27;bold&#x27;) # 设置图例字体的大小和粗细plt.savefig(&#x27;./picture/district_month_line/ChengDu_month_line_graph.jpg&#x27;) # 建议保存为svg格式,再用inkscape转为矢量图emf后插入word中plt.show()# TODO GuangZhou line graph# label在图示(legend)中显示。若为数学公式,则最好在字符串前后添加&quot;$&quot;符号# color：b:blue、g:green、r:red、c:cyan、m:magenta、y:yellow、k:black、w:white、、、# 线型：- -- -. : ,# marker：. , o v &lt; * + 1plt.figure(num=&#x27;广州&#x27;, figsize=(10, 5))plt.grid(linestyle=&quot;--&quot;) # 设置背景网格线为虚线ax = plt.gca()ax.spines[&#x27;top&#x27;].set_visible(False) # 去掉上边框ax.spines[&#x27;right&#x27;].set_visible(False) # 去掉右边框plt.plot(x, GuangZhou_1, marker=&#x27;o&#x27;, color=&quot;magenta&quot;, label=&quot;City Station&quot;, linewidth=1.5)plt.plot(x, GuangZhou_2, marker=&#x27;o&#x27;, color=&quot;green&quot;, label=&quot;5th Middle School&quot;, linewidth=1.5)group_labels = [&#x27;&#123;&#125;月&#x27;.format(i) for i in range(1, 13)] # x轴刻度的标识plt.xticks(x, group_labels, fontsize=12, fontweight=&#x27;bold&#x27;) # 默认字体大小为10plt.yticks(fontsize=12, fontweight=&#x27;bold&#x27;)plt.title(&quot;广州市不同城区PM2.5均值逐月变化&quot;, fontsize=12, fontweight=&#x27;bold&#x27;) # 默认字体大小为12plt.xlabel(&quot;月份&quot;, fontsize=13, fontweight=&#x27;bold&#x27;)plt.ylabel(&quot;PM2.5均值&quot;, fontsize=13, fontweight=&#x27;bold&#x27;)plt.xlim(0, 13) # 设置x轴的范围plt.ylim(15, 100)# plt.legend() #显示各曲线的图例plt.legend(loc=0, numpoints=1)leg = plt.gca().get_legend()ltext = leg.get_texts()plt.setp(ltext, fontsize=12, fontweight=&#x27;bold&#x27;) # 设置图例字体的大小和粗细plt.savefig(&#x27;./picture/district_month_line/GuangZhou_month_line_graph.jpg&#x27;) # 建议保存为svg格式,再用inkscape转为矢量图emf后插入word中plt.show()# TODO ShenYang line graph# label在图示(legend)中显示。若为数学公式,则最好在字符串前后添加&quot;$&quot;符号# color：b:blue、g:green、r:red、c:cyan、m:magenta、y:yellow、k:black、w:white、、、# 线型：- -- -. : ,# marker：. , o v &lt; * + 1plt.figure(num=&#x27;北京&#x27;, figsize=(10, 5))plt.grid(linestyle=&quot;--&quot;) # 设置背景网格线为虚线ax = plt.gca()ax.spines[&#x27;top&#x27;].set_visible(False) # 去掉上边框ax.spines[&#x27;right&#x27;].set_visible(False) # 去掉右边框plt.plot(x, ShenYang_1, marker=&#x27;o&#x27;, color=&quot;magenta&quot;, label=&quot;Taiyuanjie&quot;, linewidth=1.5)plt.plot(x, ShenYang_2, marker=&#x27;o&#x27;, color=&quot;blue&quot;, label=&quot;Xiaoheyan&quot;, linewidth=1.5)group_labels = [&#x27;&#123;&#125;月&#x27;.format(i) for i in range(1, 13)] # x轴刻度的标识plt.xticks(x, group_labels, fontsize=12, fontweight=&#x27;bold&#x27;) # 默认字体大小为10plt.yticks(fontsize=12, fontweight=&#x27;bold&#x27;)plt.title(&quot;沈阳市不同城区PM2.5均值逐月变化&quot;, fontsize=12, fontweight=&#x27;bold&#x27;) # 默认字体大小为12plt.xlabel(&quot;月份&quot;, fontsize=13, fontweight=&#x27;bold&#x27;)plt.ylabel(&quot;PM2.5均值&quot;, fontsize=13, fontweight=&#x27;bold&#x27;)plt.xlim(0, 13) # 设置x轴的范围plt.ylim(30, 145)# plt.legend() #显示各曲线的图例plt.legend(loc=0, numpoints=1)leg = plt.gca().get_legend()ltext = leg.get_texts()plt.setp(ltext, fontsize=12, fontweight=&#x27;bold&#x27;) # 设置图例字体的大小和粗细plt.savefig(&#x27;./picture/district_month_line/ShenYang_month_line_graph.jpg&#x27;) # 建议保存为svg格式,再用inkscape转为矢量图emf后插入word中plt.show() 北京 成都 广州 上海 沈阳 可以看出，夏季各大城市空气质量都是一年中最好的时候，冬季则相反 统计每个城市每天的平均PM2.5的数值(avergeDay_PM25_bar.py) 借助地理分布图的数据 1import geo_map 作条形图 12345678910111213141516171819from pyecharts import options as optsfrom pyecharts.charts import Barfrom pyecharts.globals import ThemeTypeaverageDay = ( Bar(&#123;&quot;theme&quot;: ThemeType.MACARONS&#125;) .add_xaxis([&#x27;北京&#x27;, &#x27;上海&#x27;, &#x27;成都&#x27;, &#x27;广州&#x27;, &#x27;沈阳&#x27;]) .add_yaxis(series_name=&#x27;城市&#x27;, y_axis=[int(geo_map.bj_PM_mean), int(geo_map.sh_PM_mean), int(geo_map.cd_PM_mean), int(geo_map.gz_PM_mean), int(geo_map.sy_PM_mean)]) .set_series_opts(label_opts=opts.LabelOpts(is_show=True)) .set_global_opts( title_opts=opts.TitleOpts(title=&quot;五大城市每天平均PM2.5数值&quot;), xaxis_opts=opts.AxisOpts(name=&#x27;城市&#x27;, name_location=&#x27;middle&#x27;, name_gap=30), yaxis_opts=opts.AxisOpts(name=&#x27;PM2.5日均值(含USA数据)&#x27;, name_location=&#x27;middle&#x27;, name_gap=30), toolbox_opts=opts.ToolboxOpts() ) .render(&#x27;./picture/averageDay_bar_graph.html&#x27;)) 基于天数对比中国环保部和美国驻华大使馆统计的污染状态(compare_CN_USA_bar.py) 先将5城市数据按天聚类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485from pyecharts import options as optsfrom pyecharts.charts import Barfrom pyecharts.globals import ThemeTypefrom itertools import chainimport pursue_mean# TODO BeiJing&#x27;s datapursue_mean.df_bj[&#x27;year&#x27;] = pursue_mean.df_bj[&#x27;year&#x27;].astype(&#x27;str&#x27;)pursue_mean.df_bj[&#x27;month&#x27;] = pursue_mean.df_bj[&#x27;month&#x27;].astype(&#x27;str&#x27;)pursue_mean.df_bj[&#x27;day&#x27;] = pursue_mean.df_bj[&#x27;day&#x27;].astype(&#x27;str&#x27;)pursue_mean.df_bj[&#x27;per day&#x27;] = pursue_mean.df_bj[&#x27;year&#x27;] + &#x27;-&#x27; + pursue_mean.df_bj[&#x27;month&#x27;] + &#x27;-&#x27; + pursue_mean.df_bj[ &#x27;day&#x27;]bj_CN = pursue_mean.df_bj.loc[pursue_mean.df_bj[&#x27;PM_mean_CN&#x27;].notnull(), [&#x27;PM_mean_CN&#x27;]]. \\ groupby(pursue_mean.df_bj[&#x27;per day&#x27;]).mean()bj_CN_fresh = int(bj_CN[bj_CN[&#x27;PM_mean_CN&#x27;] &lt;= 100].count().values)bj_CN_pollute = int(bj_CN[bj_CN[&#x27;PM_mean_CN&#x27;] &gt; 100].count().values)bj_USA = pursue_mean.df_bj.loc[pursue_mean.df_bj[&#x27;PM_US Post&#x27;].notnull(), [&#x27;PM_US Post&#x27;]]. \\ groupby(pursue_mean.df_bj[&#x27;per day&#x27;]).mean()bj_USA_fresh = int(bj_USA[bj_USA[&#x27;PM_US Post&#x27;] &lt;= 100].count().values)bj_USA_pollute = int(bj_USA[bj_USA[&#x27;PM_US Post&#x27;] &gt; 100].count().values)# TODO ShangHai&#x27;s datapursue_mean.df_sh[&#x27;year&#x27;] = pursue_mean.df_sh[&#x27;year&#x27;].astype(&#x27;str&#x27;)pursue_mean.df_sh[&#x27;month&#x27;] = pursue_mean.df_sh[&#x27;month&#x27;].astype(&#x27;str&#x27;)pursue_mean.df_sh[&#x27;day&#x27;] = pursue_mean.df_sh[&#x27;day&#x27;].astype(&#x27;str&#x27;)pursue_mean.df_sh[&#x27;per day&#x27;] = pursue_mean.df_sh[&#x27;year&#x27;] + &#x27;-&#x27; + pursue_mean.df_sh[&#x27;month&#x27;] + &#x27;-&#x27; + pursue_mean.df_sh[ &#x27;day&#x27;]sh_CN = pursue_mean.df_sh.loc[pursue_mean.df_sh[&#x27;PM_mean_CN&#x27;].notnull(), [&#x27;PM_mean_CN&#x27;]]. \\ groupby(pursue_mean.df_sh[&#x27;per day&#x27;]).mean()sh_CN_fresh = int(sh_CN[sh_CN[&#x27;PM_mean_CN&#x27;] &lt;= 100].count().values)sh_CN_pollute = int(sh_CN[sh_CN[&#x27;PM_mean_CN&#x27;] &gt; 100].count().values)sh_USA = pursue_mean.df_sh.loc[pursue_mean.df_sh[&#x27;PM_US Post&#x27;].notnull(), [&#x27;PM_US Post&#x27;]]. \\ groupby(pursue_mean.df_sh[&#x27;per day&#x27;]).mean()sh_USA_fresh = int(sh_USA[sh_USA[&#x27;PM_US Post&#x27;] &lt;= 100].count().values)sh_USA_pollute = int(sh_USA[sh_USA[&#x27;PM_US Post&#x27;] &gt; 100].count().values)# TODO ChengDu&#x27;s datapursue_mean.df_cd[&#x27;year&#x27;] = pursue_mean.df_cd[&#x27;year&#x27;].astype(&#x27;str&#x27;)pursue_mean.df_cd[&#x27;month&#x27;] = pursue_mean.df_cd[&#x27;month&#x27;].astype(&#x27;str&#x27;)pursue_mean.df_cd[&#x27;day&#x27;] = pursue_mean.df_cd[&#x27;day&#x27;].astype(&#x27;str&#x27;)pursue_mean.df_cd[&#x27;per day&#x27;] = pursue_mean.df_cd[&#x27;year&#x27;] + &#x27;-&#x27; + pursue_mean.df_cd[&#x27;month&#x27;] + &#x27;-&#x27; + pursue_mean.df_cd[ &#x27;day&#x27;]cd_CN = pursue_mean.df_cd.loc[pursue_mean.df_cd[&#x27;PM_mean_CN&#x27;].notnull(), [&#x27;PM_mean_CN&#x27;]]. \\ groupby(pursue_mean.df_cd[&#x27;per day&#x27;]).mean()cd_CN_fresh = int(cd_CN[cd_CN[&#x27;PM_mean_CN&#x27;] &lt;= 100].count().values)cd_CN_pollute = int(cd_CN[cd_CN[&#x27;PM_mean_CN&#x27;] &gt; 100].count().values)cd_USA = pursue_mean.df_cd.loc[pursue_mean.df_cd[&#x27;PM_US Post&#x27;].notnull(), [&#x27;PM_US Post&#x27;]]. \\ groupby(pursue_mean.df_cd[&#x27;per day&#x27;]).mean()cd_USA_fresh = int(cd_USA[cd_USA[&#x27;PM_US Post&#x27;] &lt;= 100].count().values)cd_USA_pollute = int(cd_USA[cd_USA[&#x27;PM_US Post&#x27;] &gt; 100].count().values)# TODO GuangZhou&#x27;s datapursue_mean.df_gz[&#x27;year&#x27;] = pursue_mean.df_gz[&#x27;year&#x27;].astype(&#x27;str&#x27;)pursue_mean.df_gz[&#x27;month&#x27;] = pursue_mean.df_gz[&#x27;month&#x27;].astype(&#x27;str&#x27;)pursue_mean.df_gz[&#x27;day&#x27;] = pursue_mean.df_gz[&#x27;day&#x27;].astype(&#x27;str&#x27;)pursue_mean.df_gz[&#x27;per day&#x27;] = pursue_mean.df_gz[&#x27;year&#x27;] + &#x27;-&#x27; + pursue_mean.df_gz[&#x27;month&#x27;] + &#x27;-&#x27; + pursue_mean.df_gz[ &#x27;day&#x27;]gz_CN = pursue_mean.df_gz.loc[pursue_mean.df_gz[&#x27;PM_mean_CN&#x27;].notnull(), [&#x27;PM_mean_CN&#x27;]]. \\ groupby(pursue_mean.df_gz[&#x27;per day&#x27;]).mean()gz_CN_fresh = int(gz_CN[gz_CN[&#x27;PM_mean_CN&#x27;] &lt;= 100].count().values)gz_CN_pollute = int(gz_CN[gz_CN[&#x27;PM_mean_CN&#x27;] &gt; 100].count().values)gz_USA = pursue_mean.df_gz.loc[pursue_mean.df_gz[&#x27;PM_US Post&#x27;].notnull(), [&#x27;PM_US Post&#x27;]]. \\ groupby(pursue_mean.df_gz[&#x27;per day&#x27;]).mean()gz_USA_fresh = int(gz_USA[gz_USA[&#x27;PM_US Post&#x27;] &lt;= 100].count().values)gz_USA_pollute = int(gz_USA[gz_USA[&#x27;PM_US Post&#x27;] &gt; 100].count().values)# TODO ShenYang&#x27;s datapursue_mean.df_sy[&#x27;year&#x27;] = pursue_mean.df_sy[&#x27;year&#x27;].astype(&#x27;str&#x27;)pursue_mean.df_sy[&#x27;month&#x27;] = pursue_mean.df_sy[&#x27;month&#x27;].astype(&#x27;str&#x27;)pursue_mean.df_sy[&#x27;day&#x27;] = pursue_mean.df_sy[&#x27;day&#x27;].astype(&#x27;str&#x27;)pursue_mean.df_sy[&#x27;per day&#x27;] = pursue_mean.df_sy[&#x27;year&#x27;] + &#x27;-&#x27; + pursue_mean.df_sy[&#x27;month&#x27;] + &#x27;-&#x27; + pursue_mean.df_sy[ &#x27;day&#x27;]sy_CN = pursue_mean.df_sy.loc[pursue_mean.df_sy[&#x27;PM_mean_CN&#x27;].notnull(), [&#x27;PM_mean_CN&#x27;]]. \\ groupby(pursue_mean.df_sy[&#x27;per day&#x27;]).mean()sy_CN_fresh = int(sy_CN[sy_CN[&#x27;PM_mean_CN&#x27;] &lt;= 100].count().values)sy_CN_pollute = int(sy_CN[sy_CN[&#x27;PM_mean_CN&#x27;] &gt; 100].count().values)sy_USA = pursue_mean.df_sy.loc[pursue_mean.df_sy[&#x27;PM_US Post&#x27;].notnull(), [&#x27;PM_US Post&#x27;]]. \\ groupby(pursue_mean.df_sy[&#x27;per day&#x27;]).mean()sy_USA_fresh = int(sy_USA[sy_USA[&#x27;PM_US Post&#x27;] &lt;= 100].count().values)sy_USA_pollute = int(sy_USA[sy_USA[&#x27;PM_US Post&#x27;] &gt; 100].count().values) 作条形图 1234567891011121314151617181920212223# TODO graphgraph = ( Bar(&#123;&quot;theme&quot;: ThemeType.MACARONS&#125;) .add_xaxis([&#x27;北京&#x27;, &#x27;上海&#x27;, &#x27;成都&#x27;, &#x27;广州&#x27;, &#x27;沈阳&#x27;]) .add_yaxis(series_name=&#x27;CN-该市空气优良天数&#x27;, y_axis=[bj_CN_fresh, sh_CN_fresh, cd_CN_fresh, gz_CN_fresh, sy_CN_fresh]) .add_yaxis(series_name=&#x27;USA-该市空气优良天数&#x27;, y_axis=[bj_USA_fresh, sh_USA_fresh, cd_USA_fresh, gz_USA_fresh, sy_USA_fresh]) .add_yaxis(series_name=&#x27;CN-该市空气污染天数&#x27;, y_axis=[bj_CN_pollute, sh_CN_pollute, cd_CN_pollute, gz_CN_pollute, sy_CN_pollute]) .add_yaxis(series_name=&#x27;USA-该市空气污染天数&#x27;, y_axis=[bj_USA_pollute, sh_USA_pollute, cd_USA_pollute, gz_USA_pollute, sy_USA_pollute]) .set_series_opts(label_opts=opts.LabelOpts(is_show=True)) .set_global_opts( title_opts=opts.TitleOpts(title=&quot;&quot;), xaxis_opts=opts.AxisOpts(name=&#x27;基于天数对比中国环保部和美国驻华大使馆统计的污染状态&#x27;, name_location=&#x27;middle&#x27;, name_gap=40), yaxis_opts=opts.AxisOpts(name=&#x27;中美各自统计的五大城市空气优良与污染天数&#x27;, name_location=&#x27;middle&#x27;, name_gap=40), toolbox_opts=opts.ToolboxOpts() ) .render(&#x27;./picture/compare_CN_USA_bar_graph.html&#x27;)) 可以看出，美国的数据统计的较为全面，中美两国统计的优良和污染天数并无特别大的差距 思考与总结 这次python实验报告，我学习了百度开源作图库 pyecharts 的使用，以及 NumPy、pandas 、matplotlib 库的使用。在整个学习过程中，我体验了一般用python操作excel表的乐趣，并惊叹于python作图模块的强大。这是区别于C语言、JAVA的重大特征。 同时也了解了我们国家五大城市过去6年的空气质量状况。由美国使领馆和邻近的环保部站点的原始PM2.5数据计算得出的评价空气质量的统计指标，具有很高的一致性与可比性。 附录 完整源代码在文件夹 PM25ProJ 中。 所有生成的图片在文件夹 PM25ProJ 下的 picture 目录中 PM2.5_five_cities.md 文档是PM2.5_five_cities.pdf的markdown文件 实验报告的标题处均有这个标题所对应的 .py 文件名","categories":[],"tags":[]},{"title":"Web程序设计","slug":"Web_PHP_Learn","date":"2022-09-24T07:42:10.000Z","updated":"2022-11-21T16:26:24.554Z","comments":true,"path":"2022/09/24/Web_PHP_Learn/","link":"","permalink":"http://example.com/2022/09/24/Web_PHP_Learn/","excerpt":"","text":"第1次作业 1 PHP脚本运行程序的运行，需要借助php预处理器，Web浏览器，Web服务器，的支持，必要时需要数据库服务器的支持。 浏览器主要功能是显示HTML的内容，由于PHP在发送到浏览器的时候已经被解析成其他代码，所以PHP对浏览器没有任何限制。 php预处理器，是将php程序中的php代码解释为文本信息。单纯的Web服务器，只能响应静态界面，比如不含任何php代码的html页面，如果浏览器请求的是动态页面，那Web服务器会调用php预处理器将其解释为静态页面，再将静态页面返回给浏览器。其实现对PHP文件的解析和编译。 Web服务器存储大量的网络资源，供用户访问和处理HTTP请求，可以向浏览器提供文档，放置文件让用户浏览，下载； 数据库服务器是存储和管理数据的容器。 2 常见的Web服务器：Apache、IIS、Nginx 常见的数据库服务器：MySQL、SQL Sever、Oracle、DB2 3 客户端浏览器向Web服务器请求访问指定界面； Web服务器接到客户端请求后，查找相关页面； 如果代码需要连接数据库，Web服务器则转给PHP预处理器，预处理器再转给SQL，数据库服务器处理以后，返回数据库的处理结果； 通过PHP预处理器将PHP脚本处理后的结果返回给Web服务器； Web服务器将预处理器解释好的HTML静态页面返给浏览器； 浏览器渲染； 需要注意的是：Web服务器，看到浏览器请求的是动态还是静态，静态自己就直接解决了，不求人，解决完返给浏览器；动态的才求人，求助于PHP预处理器。预处理器会把动态的解释成静态的。 4 静态网页：网页的内容是固定的，其修改和更新必须通过专用的网页制作工具。这种网页不是由程序制作出来的。 动态网页：是用网页脚本语言，如PHP，将网页内容动态存储在数据库中，是由数据库动态生成的网页，网站上只有一些框架，内容都是数据库动态提供的。 二者最大的区别就是，动态网页内容可以在线更新，静态网页不行。 5 网页通常是HTML文件，要通过浏览器来阅读，通常由图片，链接，文字，音视频等元素构成。 HTML表单控件： 1234567891011&lt;input&gt;&lt;label&gt;&lt;select&gt;&lt;textarea&gt;&lt;button&gt;&lt;fieldset&gt;&lt;legend&gt;&lt;datalist&gt;&lt;output&gt;&lt;option&gt;&lt;optgroup&gt; 6-20 D C B B A C A D D A B B A D D 第2次作业 链接的跳转 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;欢迎访问详情页&lt;/h2&gt; &lt;a href=&quot;index.html&quot;&gt;首页&lt;/a&gt;&amp;nbsp;&amp;nbsp; &lt;a href=&quot;list.html&quot;&gt;列表页&lt;/a&gt;&amp;nbsp;&amp;nbsp; &lt;a href=&quot;detail.html&quot;&gt;详情页&lt;/a&gt;&amp;nbsp;&amp;nbsp; &lt;a href=&quot;product.html&quot;&gt;产品页&lt;/a&gt;&amp;nbsp;&amp;nbsp; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;div&gt; &lt;img src=&quot;img/r1.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;欢迎访问首页&lt;/h2&gt; &lt;a href=&quot;index.html&quot;&gt;首页&lt;/a&gt;&amp;nbsp;&amp;nbsp; &lt;a href=&quot;list.html&quot;&gt;列表页&lt;/a&gt;&amp;nbsp;&amp;nbsp; &lt;a href=&quot;detail.html&quot;&gt;详情页&lt;/a&gt;&amp;nbsp;&amp;nbsp; &lt;a href=&quot;product.html&quot;&gt;产品页&lt;/a&gt;&amp;nbsp;&amp;nbsp; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;div&gt; &lt;img src=&quot;img/jst.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;欢迎访问详情页&lt;/h2&gt; &lt;a href=&quot;index.html&quot;&gt;首页&lt;/a&gt;&amp;nbsp;&amp;nbsp; &lt;a href=&quot;list.html&quot;&gt;列表页&lt;/a&gt;&amp;nbsp;&amp;nbsp; &lt;a href=&quot;detail.html&quot;&gt;详情页&lt;/a&gt;&amp;nbsp;&amp;nbsp; &lt;a href=&quot;product.html&quot;&gt;产品页&lt;/a&gt;&amp;nbsp;&amp;nbsp; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;div&gt; &lt;img src=&quot;img/r1.jpg&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;img/r2.jpg&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;img/r3.jpg&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;img/r4.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;欢迎访问产品页&lt;/h2&gt; &lt;a href=&quot;index.html&quot;&gt;首页&lt;/a&gt;&amp;nbsp;&amp;nbsp; &lt;a href=&quot;list.html&quot;&gt;列表页&lt;/a&gt;&amp;nbsp;&amp;nbsp; &lt;a href=&quot;detail.html&quot;&gt;详情页&lt;/a&gt;&amp;nbsp;&amp;nbsp; &lt;a href=&quot;product.html&quot;&gt;产品页&lt;/a&gt;&amp;nbsp;&amp;nbsp; &lt;br&gt; &lt;br&gt; &lt;br&gt; 当前是产品的详情 此处省略1万字&lt;/body&gt;&lt;/html&gt; 路径 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;img src=&quot;../../../image1/image2/image3/a.jpg&quot; alt=&quot;&quot;&gt; &lt;/body&gt;&lt;/html&gt; 表格练习 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;个人简历&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table border=&quot;1&quot; width=&quot;500&quot;&gt; &lt;tr bgcolor=&quot;#adff2f&quot;&gt; &lt;td colspan=&quot;5&quot; align=&quot;center&quot; width=&quot;500&quot;&gt;个人简历&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;姓&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;名:&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;性&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;别:&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;&lt;/td&gt; &lt;td rowspan=&quot;4&quot; align=&quot;center&quot; width=&quot;100&quot;&gt;照片&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;婚姻状况:&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;出生年月:&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;民&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;族:&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;政治面貌:&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;身&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;高:&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;学&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;历:&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Hot Bot&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table border=&quot;2&quot; width=&quot;600&quot; cellspacing=&quot;0&quot; style=&quot;border-collapse: collapse&quot;&gt; &lt;tr&gt; &lt;td align=&quot;center&quot; width=&quot;50&quot;&gt;&lt;b&gt;排名&lt;/b&gt;&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;&lt;b&gt;关键词&lt;/b&gt;&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;80&quot;&gt;&lt;b&gt;趋势&lt;/b&gt;&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;&lt;b&gt;今日搜索&lt;/b&gt;&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;&lt;b&gt;最近七日&lt;/b&gt;&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;170&quot;&gt;&lt;b&gt;相关链接&lt;/b&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;center&quot; width=&quot;50&quot;&gt;1&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;鬼吹灯&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;80&quot;&gt;&lt;img src=&quot;image2/down.jpg&quot; alt=&quot;&quot;&gt;&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;345&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;123&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;170&quot;&gt;&lt;font color=&quot;#8a2be2&quot;&gt;&lt;u&gt;贴吧&lt;/u&gt;&amp;nbsp;&lt;u&gt;图片&lt;/u&gt;&amp;nbsp;&lt;u&gt;百科&lt;/u&gt;&lt;/font&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;center&quot; width=&quot;50&quot;&gt;2&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;盗墓笔记&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;80&quot;&gt;&lt;img src=&quot;image2/down.jpg&quot; alt=&quot;&quot;&gt;&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;124&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;675432&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;170&quot;&gt;&lt;font color=&quot;#8a2be2&quot;&gt;&lt;u&gt;贴吧&lt;/u&gt;&amp;nbsp;&lt;u&gt;图片&lt;/u&gt;&amp;nbsp;&lt;u&gt;百科&lt;/u&gt;&lt;/font&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;center&quot; width=&quot;50&quot;&gt;3&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;西游记&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;80&quot;&gt;&lt;img src=&quot;image2/up.jpg&quot; alt=&quot;&quot;&gt;&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;212&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;7654&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;170&quot;&gt;&lt;font color=&quot;#8a2be2&quot;&gt;&lt;u&gt;贴吧&lt;/u&gt;&amp;nbsp;&lt;u&gt;图片&lt;/u&gt;&amp;nbsp;&lt;u&gt;百科&lt;/u&gt;&lt;/font&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;center&quot; width=&quot;50&quot;&gt;4&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;东游记&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;80&quot;&gt;&lt;img src=&quot;image2/up.jpg&quot; alt=&quot;&quot;&gt;&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;23&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;75645&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;170&quot;&gt;&lt;font color=&quot;#8a2be2&quot;&gt;&lt;u&gt;贴吧&lt;/u&gt;&amp;nbsp;&lt;u&gt;图片&lt;/u&gt;&amp;nbsp;&lt;u&gt;百科&lt;/u&gt;&lt;/font&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;center&quot; width=&quot;50&quot;&gt;5&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;甄嬛传&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;80&quot;&gt;&lt;img src=&quot;image2/down.jpg&quot; alt=&quot;&quot;&gt;&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;121&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;7676&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;170&quot;&gt;&lt;font color=&quot;#8a2be2&quot;&gt;&lt;u&gt;贴吧&lt;/u&gt;&amp;nbsp;&lt;u&gt;图片&lt;/u&gt;&amp;nbsp;&lt;u&gt;百科&lt;/u&gt;&lt;/font&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;center&quot; width=&quot;50&quot;&gt;6&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;水浒传&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;80&quot;&gt;&lt;img src=&quot;image2/up.jpg&quot; alt=&quot;&quot;&gt;&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;576576&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;1231421&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;170&quot;&gt;&lt;font color=&quot;#8a2be2&quot;&gt;&lt;u&gt;贴吧&lt;/u&gt;&amp;nbsp;&lt;u&gt;图片&lt;/u&gt;&amp;nbsp;&lt;u&gt;百科&lt;/u&gt;&lt;/font&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;center&quot; width=&quot;50&quot;&gt;7&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;三国演义&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;80&quot;&gt;&lt;img src=&quot;image2/up.jpg&quot; alt=&quot;&quot;&gt;&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;234&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;100&quot;&gt;7686&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;170&quot;&gt;&lt;font color=&quot;#8a2be2&quot;&gt;&lt;u&gt;贴吧&lt;/u&gt;&amp;nbsp;&lt;u&gt;图片&lt;/u&gt;&amp;nbsp;&lt;u&gt;百科&lt;/u&gt;&lt;/font&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 第3次作业 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;大卖场&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;?php $good1 = &#x27;香蕉&#x27;; $good2 = &#x27;苹果&#x27;; $good3 = &#x27;橘子&#x27;; $num1 = 2; $num2 = 1; $num3 = 3; $price1 = 7.99; $price2 = 6.89; $price3 = 3.99; $discount = 0.8; $sumprice = ($num1 * $price1 + $num2 * $price2 + $num3 * $price3) * $discount; ?&gt;&lt;table border=&quot;2&quot; style=&quot;border-collapse: collapse&quot; cellspacing=&quot;0&quot;&gt; &lt;tr&gt; &lt;td&gt;商品名称&lt;/td&gt; &lt;td&gt;购买数量(斤)&lt;/td&gt; &lt;td&gt;商品价格(元/斤)&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;?php echo $good1 ?&gt;&lt;/td&gt; &lt;td&gt;&lt;?php echo $num1 ?&gt;&lt;/td&gt; &lt;td&gt;&lt;?php echo $price1 ?&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;?php echo $good2 ?&gt;&lt;/td&gt; &lt;td&gt;&lt;?php echo $num2 ?&gt;&lt;/td&gt; &lt;td&gt;&lt;?php echo $price2 ?&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;?php echo $good3 ?&gt;&lt;/td&gt; &lt;td&gt;&lt;?php echo $num3 ?&gt;&lt;/td&gt; &lt;td&gt;&lt;?php echo $price3 ?&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;3&quot;&gt;商品折扣：&lt;?php echo $discount ?&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;3&quot;&gt;打折后购买商品总价格：&lt;?php echo $sumprice ?&gt;元&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 第4次作业 1 XML标记风格(标准标记)：推荐使用这种标记123&lt;?php?&gt; 脚本标记风格：仅需了解1234&lt;script language=&quot;php&quot;&gt;&lt;/script&gt; 简短标记风格：需要到PHP配置文件修改才能使用123&lt;??&gt; ASP标记风格：需要到PHP配置文件修改才能使用123&lt;%%&gt; 2 PHP注释种类 /* */ 多行注释：当我们需要写很多注释，一行写不下时用多行注释； // 单行注释：只写一行注释，简洁； shell脚本风格注释：还是推荐单行注释； 注释标签 用于在 HTML 插入注释。 3 PHP数据类型: 标量数据类型: bool类型:仅有TRUE和FALSE，且不区分大小写。常用于逻辑判断; 整型:存储整数 浮点型:存储实数 字符串类型:存储连续的字符序列; 复合数据类型: 数组:存储一组数据； 对象:将客观事物抽象成类，类是对象的模板，对象是类的实例。每个类都有自己的特征和行为，其特征就是字段，其行为就是方法。同属于一个类的每个对象都有相同的属性和方法。 特殊数据类型: 资源数据类型:句柄 空数据类型:没有为该变量设置任何值，NULL和null不区分大小写。被赋空值的三种情况: 在定义变量时，没有被赋任何值； 被赋值为null； 用unset()函数处理过的变量； 伪类型 4 使用define()函数声明自定义常量。比如define(&quot;-_-&quot;, “我爱你”); 使用const关键字定义常量，比如，const PI = 3.14; 二者区别： const定义常量，标识符大小写敏感；但是define()就不一定了，define()可以通过第三个参数指定是否大小写敏感。 const不能在函数，循环，分支结构中被访问；但define()可以； define()不能在类中被访问到，但是const可以； 获取常量值有2种方法： 使用constant()函数可以获取常量的值； 直接取它的变量名； 5 “===” 是恒等于运算符，$a === $b， 当二者数据类型而且值也相同时，返回true，否则返回false； 6 检查一个变量是否设置，用 bool isset(mixed var) 函数，若该变量已经定义，并且该值不是NULL，那么返回布尔值true，否则返回false。 is_null()来判断变量是否为null，若是null，返回true，否则返回false. 区别： 123$c = null;var_dump(isset($c));var_dump(is_null($c)); 输出是 bool(false) bool(true) 7 echo语句： echo是一个语言结构，可以带括号或不带括号使用： echo或echo()，都可以用来输出，它是最常用的输出语句。在平时，echo或echo()的输出是一样的，只有在将多个参数传递给echo语句，进行输出时，则使用括号将生成解析错误。不能加@；没有返回值。 print语句： print语句也可以实现输出，且有返回值。当输出成功会返回1，失败就会返回0；因此它可以在表达式中使用。print语句同样可以带括号或不带括号使用，没有多大区别。一次只能输出1个值。 printf()函数 printf()函数也可以实现输出，可以输出普通的字符串，也格式化输出。 print_r() print_r()函数是用来输出变量的，可以用人类容易读取的格式来显示这个变量的信息。 var_dump() var_dump()函数用于输出变量，可以显示变量的结构化信息。 8 双引号和单引号的区别： 双引号中包含的变量会被自动替换成实际数值，而单引号中的变量按照普通字符串输出； 单引号的速度比双引号快； 9 传值赋值，改变其中一个变量的值，不会影响到另一个变量的值。但引用赋值会，引用赋值传的是地址。 10 检查一个变量是否设置，用 bool isset(mixed var) 函数，若该变量已经定义，并且该值不是NULL，那么返回布尔值true，否则返回false。 is_null()来判断变量是否为null，若是null，返回true，否则返回false. (PHP 4, PHP 5, PHP 7, PHP 8) empty — 检查一个变量是否为空 判断一个变量是否被认为是空的。当一个变量并不存在，或者它的值等同于false，那么它会被认为不存在。如果变量不存在的话，empty()并不会产生警告。没有警告会产生，哪怕变量并不存在。 这意味着 empty() 本质上与 !isset($var) || $var == false 等价。 当var存在，并且是一个非空****非零的值时返回 false ，否则返回 true. 以下的东西被认为是空的： “” (空字符串) 0 (作为整数的0) 0.0 (作为浮点数的0) “0” (作为字符串的0) null false array() (一个空数组) $var; (一个声明了，但是没有值的变量) 11 1234$x = 5;$y = 6;$z = 7;$max = $x&gt;$y ? ( $x&gt;$z ? $x : $z ) : ($y&gt;$z ?$y :$z); 12-30 D C B B D B C B B D C D D D D A C B A 第5次作业 成绩等级判断 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;学生成绩&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;请输入您的姓名和分数&lt;/h2&gt; &lt;form action=&quot;#&quot; method=&quot;post&quot;&gt; 请输入姓名：&lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot;&gt; &lt;hr&gt; 请输入成绩：&lt;input type=&quot;text&quot; name=&quot;score&quot; id=&quot;score&quot;&gt; &lt;hr&gt; &lt;input type=&quot;submit&quot; name=&quot;btn&quot; id=&quot;btn&quot;&gt; &lt;/form&gt; &lt;?php if (isset($_POST[&#x27;btn&#x27;]))&#123; $Name = $_POST[&#x27;name&#x27;]; $Score = $_POST[&#x27;score&#x27;]; if (is_numeric($Score))&#123; echo &quot;您好&#123;$Name&#125;，很高兴你能在CAU学习！&lt;hr&gt;&quot;; switch ($Score)&#123; case $Score &gt;= 90: echo &#x27;A&lt;br/&gt;&#x27;; break; case $Score &gt;= 80: echo &#x27;B&lt;br/&gt;&#x27;; break; case $Score &gt;= 70: echo &#x27;C&lt;br/&gt;&#x27;; break; case $Score &gt;= 60: echo &#x27;D&lt;br/&gt;&#x27;; break; default: echo &#x27;E&lt;br/&gt;&#x27;; &#125; &#125; &#125; ?&gt;&lt;/body&gt;&lt;/html&gt; 更改文字颜色 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;改变颜色&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;my_color&quot;&gt; 轻轻的你走了，&lt;br&gt; 正如你轻轻的来。&lt;br&gt; 我轻轻的招手，&lt;br&gt; 作别西天的云彩。 &lt;/div&gt; &lt;form action=&quot;#&quot; method=&quot;post&quot;&gt; &lt;select name=&quot;color&quot; id=&quot;color&quot;&gt; &lt;option value=&quot;0&quot;&gt;请选择颜色&lt;/option&gt; &lt;option value=&quot;1&quot;&gt;红色&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;绿色&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;蓝色&lt;/option&gt; &lt;/select&gt; &lt;input type=&quot;submit&quot; name=&quot;btn&quot; value=&quot;更改颜色&quot;&gt; &lt;/form&gt; &lt;?php if (isset($_POST[&#x27;btn&#x27;]))&#123; switch ($_POST[&#x27;color&#x27;])&#123; case &#x27;1&#x27;: $color = &#x27;#FF0000&#x27;; break; case &#x27;2&#x27;: $color = &#x27;#009900&#x27;; break; case &#x27;3&#x27;: $color = &#x27;#0000FF&#x27;; break; default: $color = &#x27;#000000&#x27;; &#125; echo &lt;&lt;&lt;str &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function()&#123; document.getElementById(&#x27;my_color&#x27;).style.color=&#x27;$color&#x27;; &#125; &lt;/script&gt;str; &#125; ?&gt;&lt;/body&gt;&lt;/html&gt; 第6次作业 1 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;今日距离您的生日还有几天？&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;#&quot; method=&quot;post&quot;&gt; 请输入您的生日年份：&lt;input type=&quot;text&quot; name=&quot;birth_year&quot; id=&quot;birth_year&quot;&gt;&lt;br&gt; 请输入您的生日月份：&lt;input type=&quot;text&quot; name=&quot;birth_month&quot; id=&quot;birth_month&quot;&gt;&lt;br&gt; 请输入您的生日日期：&lt;input type=&quot;text&quot; name=&quot;birth_day&quot; id=&quot;birth_day&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; name=&quot;btn&quot; value=&quot;提交您的生日&quot;&gt; &lt;/form&gt; &lt;?php if (isset($_POST[&#x27;btn&#x27;]))&#123; $now_year = date(&quot;Y&quot;); $next_year = date(&quot;Y&quot;); $now_month = date(&quot;m&quot;); $now_day = date(&quot;d&quot;); $birth_month = $_POST[&quot;birth_month&quot;]; $birth_day = $_POST[&quot;birth_day&quot;]; if ($now_month &gt; $birth_month)&#123; $next_year = $next_year + 1; &#125;elseif ($birth_month == $now_month)&#123; if ($now_day &gt; $birth_day)&#123; $next_year = $next_year + 1; &#125; &#125; $date1=date_create(&quot;$next_year-$birth_month-$birth_day&quot;); $date2=date_create(&quot;$now_year-$now_month-$now_day&quot;); $diff=date_diff($date2,$date1); echo $diff-&gt;format(&quot;%R%a days&quot;); &#125; ?&gt;&lt;/body&gt;&lt;/html&gt; 2 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;逢七过&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;?php $cnt = 0; for ($n = 1; $n &lt;= 99; $n++)&#123; if (($n % 10 == 7) || ($n % 7 == 0))&#123; $cnt++; &#125; &#125; echo $cnt; ?&gt;&lt;/body&gt;&lt;/html&gt; 3 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;大卖场&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;?php $num1 = mt_rand(); $num2 = mt_rand(); echo $num1 + $num2; ?&gt;&lt;/body&gt;&lt;/html&gt; 4 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;大卖场&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;?php $sum = 0; for ($n = 1; $n &lt;= 100; $n++)&#123; if (($n % 3 )== 0)&#123; $sum += $n; &#125; &#125; echo $sum; ?&gt;&lt;/body&gt;&lt;/html&gt; 5 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;大卖场&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;table border=&quot;1&quot; align=&quot;center&quot; width=&quot;1000&quot;&gt; &lt;?php for ($i = 1; $i &lt;= 9; ++$i): ?&gt; &lt;tr&gt; &lt;?php for ($j = 1; $j &lt;= $i; $j++): $product = $i * $j; ?&gt; &lt;td&gt;&lt;?=&quot;&#123;$i&#125; × &#123;$j&#125; = &#123;$product&#125;&quot; ?&gt;&lt;/td&gt; &lt;?php endfor; ?&gt; &lt;/tr&gt; &lt;?php endfor; ?&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 6 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;ATM&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;#&quot; method=&quot;post&quot;&gt; 请输入您的账号:&lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;username&quot;&gt;&lt;br&gt; 请输入您的密码:&lt;input type=&quot;password&quot; name=&quot;pwd&quot; id=&quot;pwd&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; name=&quot;btn&quot; value=&quot;登录&quot;&gt;&lt;br&gt; &lt;input type=&quot;hidden&quot; name=&quot;cnt&quot; value=&quot;1&quot; id=&quot;failed&quot;&gt; &lt;/form&gt; &lt;?php if (isset($_POST[&#x27;btn&#x27;]))&#123; $name = $_POST[&#x27;username&#x27;]; $password = $_POST[&#x27;pwd&#x27;]; $count = $_POST[&#x27;cnt&#x27;]; if ($count &gt; 3)&#123; echo &#x27;您已经登录3次以上且均失败，将要吞卡&lt;br/&gt;&#x27;; die(&quot;寄了&quot;); &#125;elseif (($name != &#x27;admin&#x27;))&#123; echo &#x27;用户名错误 登录失败&lt;br/&gt;&#x27;; $count++; &#125;elseif ($password != &#x27;abc&#x27;)&#123; echo &#x27;用户名正确 密码错误 登录失败&lt;br/&gt;&#x27;; $count++; &#125;else &#123; echo &#x27;用户名正确 密码正确，登录成功&lt;br/&gt;&#x27;; &#125; echo &lt;&lt;&lt;str &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function()&#123; document.getElementById(&#x27;failed&#x27;).style.color=&#x27;$count&#x27;; &#125; &lt;/script&gt;str; &#125; ?&gt;&lt;/body&gt;&lt;/html&gt; 第7次作业 Include_And_Require_index.php 12345678910111213141516171819202122232425262728293031&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;网页布局&lt;/title&gt; &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;/&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;这部分是网页的表头&lt;/div&gt;&lt;div&gt; &lt;div&gt;&lt;?php include &quot;./Include_And_Require_content.php&quot;;?&gt;&lt;/div&gt; &lt;div&gt;&lt;?php include &quot;./Include_And_Require_side.php&quot;;?&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;这不是网页尾部信息&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; Include_And_Require_content.php 12345678910111213141516171819&lt;?php$books = [&#x27;php.jpg&#x27;, &#x27;mysql.jpg&#x27;, &#x27;python.jpg&#x27;, &#x27;database.jpg&#x27;];?&gt;&lt;div&gt; &lt;?php foreach($books as $book):?&gt; &lt;div&gt; &lt;img src=&quot;./img_index/&lt;?php echo $book;?&gt;&quot; width=&quot;75&quot; height=&quot;100&quot;&gt; &lt;/div&gt; &lt;?php endforeach;?&gt;&lt;/div&gt; Include_And_Require_side.php 1234567891011121314151617181920212223&lt;?php$arr = [[&#x27;编程基础类&#x27;, &#x27;程序设计I&#x27;, &#x27;Web程雪设计&#x27;,&#x27;Python语言程序设计&#x27;], [&#x27;数据处理类&#x27;, &#x27;数据分析&#x27;, &#x27;数据库原理&#x27;]];?&gt;&lt;h2&gt;开设课程信息&lt;/h2&gt;&lt;ul&gt; &lt;?php foreach($arr as $values): ?&gt; &lt;?php foreach($values as $k =&gt; $v): ?&gt; &lt;?php echo $k &gt; 0 ? &quot;&lt;li&gt;$v&lt;/li&gt;&quot; : &quot;&lt;p&gt;$v&lt;/p&gt;&quot;; ?&gt; &lt;?php endforeach; ?&gt; &lt;?php endforeach; ?&gt;&lt;/ul&gt; 第8次作业 1 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;大卖场&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;?php function Pascal_Triangle($n)&#123; $a = array(); for ($i = 0; $i &lt; $n; ++$i)&#123; $a[$i][0] = 1; $a[$i][$i] = 1; &#125; for ($i = 1; $i &lt; $n; ++$i)&#123; for ($j = 1; $j &lt; $i; ++$j)&#123; $a[$i][$j] = $a[$i - 1][$j - 1] + $a[$i - 1][$j]; &#125; &#125; for ($i = 0; $i &lt; $n; ++$i)&#123; for ($j = 0; $j &lt;= $i; ++$j)&#123; echo $a[$i][$j].&#x27;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&#x27;; &#125; echo &#x27;&lt;br/&gt;&#x27;; &#125; &#125; Pascal_Triangle(10); ?&gt;&lt;/body&gt;&lt;/html&gt; 2 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;大卖场&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;?php $arr = array(9, 8, 7, 6, 5, 4, 3, 2, 1); $len = 10; function Bubble_Selection($arr, $len)&#123; if (is_array($arr))&#123; for ($i = 0; $i &lt; $len - 1; ++$i)&#123; for ($j = 0; $j &lt; $len - $i - 1; ++$j)&#123; if (isset($arr[$j]) &amp;&amp; isset($arr[$j + 1]))&#123; if ($arr[$j] &gt; $arr[$j + 1])&#123; $t = $arr[$j]; $arr[$j] = $arr[$j + 1]; $arr[$j + 1] = $t; &#125; &#125; &#125; &#125; return $arr; &#125; &#125; print_r(Bubble_Selection($arr, $len)); ?&gt;&lt;/body&gt;&lt;/html&gt; 3 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;大卖场&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;?php $date1 = strtotime(&quot;2022-5-1 13:12:12&quot;); $date2 = strtotime(&quot;2022-5-2 12:45:11&quot;); $diff = abs($date1 - $date2); $days = floor($diff / 3600 / 24); $hours = floor(($diff - $days * 86400) / 3600); $mins = floor(($diff - $days * 86400 - $hours * 3600) / 60); $seconds = floor($diff - $days * 86400 - $hours * 3600 - $mins * 60); printf(&quot;相差: %f 日，%f 小时，%f 分钟，%f 秒&quot;, $days, $hours, $mins, $hours); echo &#x27;&lt;br/&gt;&#x27;; echo &quot;相差: &#123;$days&#125; 日，&#123;$hours&#125; 小时，&#123;$mins&#125; 分钟，&#123;$seconds&#125; 秒&quot; ?&gt;&lt;/body&gt;&lt;/html&gt; 4 快排 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;大卖场&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;?php $arr2 = array(9, 8, 7, 6, 5, 4, 3, 2, 1); $L2 = 0; $R2 = 8; function Quick_Sort(&amp;$arr, $L, $R)&#123; if ($L &gt;= $R)&#123; return $arr; &#125; $left = $L; //这样移动left就好，不去动L，因为后面递归要用到L $right = $R; //这样移动right就好，不去动R，因为后面递归要用到R $pivot = $arr[$left]; while ($left &lt; $right)&#123; // 外层循环不能少，因为left和right在一次循环中各自最多找到一个要变动的元素，要找到更多需要变动的元素，只能进入下一个循环 while (($left &lt; $right) &amp;&amp; ($arr[$right] &gt;= $pivot))&#123; //等于的话，就不去动它.($left &lt; $right)一定不能省略，防止right减成left还继续减 $right--; &#125; if ($left &lt; $right)&#123; // 这个判断也不能少，因为出了上面那个循环，right可能已经变了很多了，但此时left还是0 $arr[$left] = $arr[$right]; &#125; while (($left &lt; $right) &amp;&amp; ($arr[$left] &lt;= $pivot))&#123; //right已经成功找到了一个比pivot小的了，该left找了 $left++; &#125; if ($left &lt; $right)&#123; $arr[$right] = $arr[$left]; &#125; if ($left == $right)&#123; $arr[$left] = $pivot; &#125; &#125; Quick_Sort($arr, $L, $right - 1); // 此时 $left = $right，新一轮的函数调用会有自己的$left和$right Quick_Sort($arr, $left + 1, $R); // 此时 $left = $right，新一轮的函数调用会有自己的$left和$right return $arr; &#125; print_r(Quick_Sort($arr2, $L2, $R2)); ?&gt;&lt;/body&gt;&lt;/html&gt; 冒泡 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;大卖场&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;?php $arr = array(9, 8, 7, 6, 5, 4, 3, 2, 1); $len = 10; function Bubble_Selection($arr, $len)&#123; if (is_array($arr))&#123; for ($i = 0; $i &lt; $len - 1; ++$i)&#123; for ($j = 0; $j &lt; $len - $i - 1; ++$j)&#123; if (isset($arr[$j]) &amp;&amp; isset($arr[$j + 1]))&#123; if ($arr[$j] &gt; $arr[$j + 1])&#123; $t = $arr[$j]; $arr[$j] = $arr[$j + 1]; $arr[$j + 1] = $t; &#125; &#125; &#125; &#125; return $arr; &#125; &#125; print_r(Bubble_Selection($arr, $len)); ?&gt;&lt;/body&gt;&lt;/html&gt; 5 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;大卖场&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;?php function sortByKeyDesc($arr, $key) &#123; //降序 array_multisort(array_column($arr, $key), SORT_DESC, $arr); return $arr; &#125; function sortByKeyAsc($arr, $key) &#123; //升序 array_multisort(array_column($arr, $key), SORT_ASC, $arr); return $arr; &#125; ?&gt;&lt;/body&gt;&lt;/html&gt; 6 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;大卖场&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;?php function FileName_Suffix($path)&#123; $position = strrpos($path, &#x27;.&#x27;); $suffix = substr($path, $position); return $suffix; &#125; ?&gt;&lt;/body&gt;&lt;/html&gt; 第9次作业 1 break和continue都是用来控制循环结构的，主要作用是停止循环。 不管是哪种循环，一旦在循环体中遇到break，系统将完全结束循环，开始执行循环之后的代码。 continue语句的作用是跳过本次循环体中剩下尚未执行的语句，立即进行下一次的循环条件判定，可以理解为只是中止(跳过)本次循环，接着开始下一次循环。 continue语句并没有使整个循环终止。 continue 只能在循环语句中使用，即只能在 for、while 和 do…while 语句中使用。只能在循环体内和switch语句体内使用break。 2 require()和include()函数作用类似，但是区别如下： 若引用文件发生错误或者无法找到，require()将给出警告并终止程序运行，include()只会给出警告，但是不会终止程序运行。 require()只要程序开始执行，就会立即调用外部文件，但是include()只会待到程序执行到该函数时，才会调用外部文件。 3 while循环执行时只有当满足条件时才会进入循环，进入循环后，执行完循环体内全部语句直到条件不满足时，再跳出循环。do-while循环将先运行一次，在经过第一次do循环后，执行完一次后检查条件表达式的值是否成立，其值为不成立时才会退出循环。while循环是先判断后执行，如果判断条件不成立可以不执行中间循环体。do-while循环是先执行后判断，执行次数至少为一次，执行一次后判断条件是否成立，如果不成立跳出循环，成立则继续运行循环体。 1234567&lt;?php$i=0;//控制变量初始化while($i&lt;10)&#123;//表达式执行语句;//反复执行直到表达式为假$i++;//控制变量自增长&#125;?&gt; 123456&lt;?php$i = 0;//控制变量初始化do &#123; &lt;span style=&quot;font-family: monospace; white-space: pre; background-color: rgb(240, 240, 240);&quot;&gt;执行语句&lt;/span&gt;;//先执行一次&#125; while ($i &gt;0);//表达式?&gt; 4-10 C B A A C D C 第10次作业 1 1234function max($a, $b, $c)&#123; $max1 = $a &gt; $b ? $a : $b; return $max1 &gt; $c ? $max1 : $c; &#125; 2 1234function get_url_extention($url)&#123; $path_parts = pathinfo($url); return $path_parts[&#x27;extension&#x27;]; &#125; 3 传值赋值： 值传递是 PHP 中函数的默认传值方式，也称为“拷贝传值”。 顾名思义值赋值的方式会将实参的值复制一份再传递给函数的形参，所以在函数中操作参数的值并不会对函数外的实参造成影响。 因此如果不希望函数修改实参的值，就可以通过值传递的方式。 传地址赋值 参数的引用传递就是把实参的内存地址复制一份，然后传递给函数的形参，进而将实参值赋值给形参。 实参和形参都指向同一个内存地址，因此函数对形参的操作，会影响到函数外的实参。 按引用传递就是将实参的内存地址传递到函数的形参中。因此实参和形参指向的是同一个内存地址。这时在函数内部的所有操作都会影响到函数外实参的值。 4 require()和include()函数作用类似，但是区别如下： 若引用文件发生错误或者无法找到，require()将给出警告并终止程序运行，include()只会给出警告，但是不会终止程序运行。 require()只要程序开始执行，就会立即调用外部文件，但是include()只会待到程序执行到该函数时，才会调用外部文件。 5 ‘/[1]\\d{4,}/’ 6 7-22 B C A B B A D B C C B C B B C D 第11次作业 1 sort()函数将数组中的元素按照值正排序； asort()函数将数组中的元素按照值倒排序； ksort()函数将数组中的元素按照键正排序； 2 123456789101112131415161718192021222324252627282930313233343536373839$b = array(9, 6, 7, 5, 3, 8); $L2 = 0; $R2 = 5; function Quick_Sort(&amp;$arr, $L, $R)&#123; //必须是引用传递数组，否则递归无效 if ($L &gt;= $R)&#123; return $arr; &#125; $left = $L; //这样移动left就好，不去动L，因为后面递归要用到L $right = $R; //这样移动right就好，不去动R，因为后面递归要用到R $pivot = $arr[$left]; while ($left &lt; $right)&#123; // 外层循环不能少，因为left和right在一次循环中各自最多找到一个要变动的元素，要找到更多需要变动的元素，只能进入下一个循环 while (($left &lt; $right) &amp;&amp; ($arr[$right] &gt;= $pivot))&#123; //等于的话，就不去动它.($left &lt; $right)一定不能省略，防止right减成left还继续减 $right--; &#125; if ($left &lt; $right)&#123; // 这个判断也不能少，因为出了上面那个循环，right可能已经变了很多了，但此时left还是0 $arr[$left] = $arr[$right]; &#125; while (($left &lt; $right) &amp;&amp; ($arr[$left] &lt;= $pivot))&#123; //right已经成功找到了一个比pivot小的了，该left找了 $left++; &#125; if ($left &lt; $right)&#123; $arr[$right] = $arr[$left]; &#125; if ($left == $right)&#123; $arr[$left] = $pivot; &#125; &#125; Quick_Sort($arr, $L, $right - 1); // 此时 $left = $right，新一轮的函数调用会有自己的$left和$right Quick_Sort($arr, $left + 1, $R); // 此时 $left = $right，新一轮的函数调用会有自己的$left和$right return $arr; &#125; print_r(Quick_Sort($b, $L2, $R2)); 3 D B A A D B C A C A C A C D 第12次作业 1 GET方式提交 POST方式提交 php接受通过HTML表单提交的信息时，会将提交的数据保存在全局数组中，我们可以调用系统特定的自动全局变量数组来获取这些值。常用的自动全局变量如下所示： $_GET $_POST REQUEST在获取表单数据中，最常用的自动全局变量是_REQUEST 在获取表单数据中，最常用的自动全局变量是R​EQUEST在获取表单数据中，最常用的自动全局变量是_GET和$_POST,它们分别获取通过GET方法提交的数据和通过POST方法提交的数据。 2 当客户没有禁止Cookie时 使用session_set_cookie_params()函数，它必须在session_start前面调用，但不推荐使用该方法； 和cookie一样，用setcookie()函数手动设置失效时间； 客户端禁用cookie 必须打开cookie； 设置php.ini文件； 使用GET方式隐藏表单传递session_id； 使用文件或者数据库存储session_id，在页面间传递时手动调用； 3 禁用cookie后，Session页面间的传递会失效，但我们可以用一些方法去让它生效： 当客户没有禁止Cookie时 使用session_set_cookie_params()函数，它必须在session_start前面调用，但不推荐使用该方法； 和cookie一样，用setcookie()函数手动设置失效时间； 客户端禁用cookie 必须打开cookie； 设置php.ini文件； 使用GET方式隐藏表单传递session_id； 使用文件或者数据库存储session_id，在页面间传递时手动调用； 4 cookie和session的区别： 存储位置：cookie数据存放在客户的浏览器上，session数据放在服务器上。 隐私策略不同，Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些。 session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用COOKIE。 存储大小不同，单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie。 存取方式的不同，Cookie 只能保存 ASCII，Session 可以存任意数据类型，一般情况下我们可以在 Session 中保持一些常用变量信息，比如说 UserId 等。 有效期不同，Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效。 cookie原理： HTTP Cookie（也叫 Web Cookie或浏览器 Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。 Cookie 主要用于以下三个方面： 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息） 个性化设置（如用户自定义设置、主题等） 浏览器行为跟踪（如跟踪分析用户行为等） session原理： Session 代表着服务器和客户端一次会话的过程。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 Session 超时失效时会话结束。 Cookie 和 Session 的配合 用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建创建对应的 Session ，请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器，浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名。 当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。 根据以上流程可知，SessionID 是连接 Cookie 和 Session 的一道桥梁，大部分系统也是根据此原理来验证用户登录状态。 既然服务端是根据 Cookie 中的信息判断用户是否登录，那么如果浏览器中禁止了 Cookie，如何保障整个机制的正常运转。 第一种方案，每次请求中都携带一个 SessionID 的参数，也可以 Post 的方式提交，也可以在请求的地址后面拼接。 第二种方案，Token 机制。Token 机制多用于 App 客户端和服务器交互的模式，也可以用于 Web 端做用户状态管理。Token 的意思是“令牌”，是服务端生成的一串字符串，作为客户端进行请求的一个标识。Token 机制和 Cookie 和 Session 的使用机制比较类似。当用户第一次登录后，服务器根据提交的用户信息生成一个 Token，响应时将 Token 返回给客户端，以后客户端只需带上这个 Token 前来请求数据即可，无需再次登录验证。 5 123456789101112&lt;?php function get_url($url) &#123; $url_para = parse_url($url); $query = explode(&quot;&amp;&quot;, $url_para[&quot;query&quot;]); foreach ($query as $item) &#123; echo &quot;$item&quot;.&quot;&lt;br&gt;&quot;; &#125; &#125; $url = &quot;https://www.bilibili.com/video/BV18U4y1j7o1/?spm_id_from=333.788.recommend_more_video.2&amp;vd_source=86560676da6f4c30de25eecbfa96c918&quot;; get_url($url);?&gt; 6 Cookie在客户端存储数据； Session在服务器端存储数据； Session更安全； 7-20 C A D C B B D A A A C D D A 21 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;大卖场&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;#&quot; method=&quot;post&quot;&gt; &lt;center&gt;注册账号&lt;/center&gt; &lt;table align=&quot;center&quot; border=&quot;1&quot;&gt; &lt;tr&gt; &lt;td&gt;用户名:&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;content[username]&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;email:&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;content[email]&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码:&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;content[pwd]&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;确认密码:&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;content[confirm_pwd]&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;性别:&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;radio&quot; name=&quot;content[sex]&quot; value=&quot;男&quot;&gt;男 &lt;input type=&quot;radio&quot; name=&quot;content[sex]&quot; value=&quot;女&quot; checked&gt;女 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;手机号码:&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;content[phone]&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;喜欢的编程技术:&lt;/td&gt; &lt;td&gt; &lt;select name=&quot;content[loveLanguage]&quot;&gt; &lt;option selected&gt;PHP&lt;/option&gt; &lt;option &gt;Python&lt;/option&gt; &lt;option&gt;Java&lt;/option&gt; &lt;option&gt;C&lt;/option&gt; &lt;option&gt;C++&lt;/option&gt; &lt;option&gt;Go&lt;/option&gt; &lt;option&gt;Rust&lt;/option&gt; &lt;option&gt;C#&lt;/option&gt; &lt;/select&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td COLSPAN=&quot;2&quot;&gt; &lt;input type=&quot;checkbox&quot; checked name=&quot;content[check]&quot;&gt;我已经看过并接受&lt;a href=&quot;https://www.bilibili.com/&quot; target=&quot;_blank&quot;&gt; &lt;b&gt;用户协议&lt;/b&gt;&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;立即注册&quot; name=&quot;bnt&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/form&gt; &lt;?php if (isset($_POST[&quot;bnt&quot;])) &#123; if (isset($_POST[&quot;content&quot;][&quot;check&quot;])) &#123; if ($_POST[&quot;content&quot;][&quot;username&quot;] == &quot;&quot; || $_POST[&quot;content&quot;][&quot;email&quot;] == &quot;&quot; || $_POST[&quot;content&quot;][&quot;pwd&quot;] == &quot;&quot; || $_POST[&quot;content&quot;][&quot;confirm_pwd&quot;] == &quot;&quot; || $_POST[&quot;content&quot;][&quot;sex&quot;] == &quot;&quot; || $_POST[&quot;content&quot;][&quot;phone&quot;] == &quot;&quot; || $_POST[&quot;content&quot;][&quot;loveLanguage&quot;] == &quot;&quot;) &#123; echo &quot;不能有不填的！&quot; or exit(&quot;回去填&quot;); &#125;else &#123; echo &quot;你好&quot;; echo &quot;用户名:&quot;.$_POST[&quot;content&quot;][&quot;username&quot;].&quot;&lt;br&gt;&quot;; echo &quot;邮箱:&quot;.$_POST[&quot;content&quot;][&quot;email&quot;].&quot;&lt;br&gt;&quot;; echo &quot;密码:&quot;.$_POST[&quot;content&quot;][&quot;pwd&quot;].&quot;&lt;br&gt;&quot;; echo &quot;确认密码:&quot;.$_POST[&quot;content&quot;][&quot;confirm_pwd&quot;].&quot;&lt;br&gt;&quot;; echo &quot;性别:&quot;.$_POST[&quot;content&quot;][&quot;sex&quot;].&quot;&lt;br&gt;&quot;; echo &quot;手机号:&quot;.$_POST[&quot;content&quot;][&quot;phone&quot;].&quot;&lt;br&gt;&quot;; echo &quot;你喜欢的编程预言:&quot;.$_POST[&quot;content&quot;][&quot;loveLanguage&quot;].&quot;&lt;br&gt;&quot;; &#125; &#125; &#125; ?&gt;&lt;/body&gt;&lt;/html&gt; 第13次作业 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;给排2班&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;?php $_red = range(1, 33); $_red_keys = array_rand($_red, 6); shuffle($_red_keys); foreach ($_red_keys as $key) &#123; if ($_red[$key] &lt; 10) &#123; echo &quot;0&quot;.$_red[$key].&quot;&lt;br&gt;&quot;; &#125;else &#123; echo $_red[$key].&quot;&lt;br&gt;&quot;; &#125; &#125; $_blue = range(1, 16); $_blue_key = array_rand($_blue, 1); echo $_blue[$_blue_key]; ?&gt;&lt;/body&gt;&lt;/html&gt; 第14次作业 1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;大卖场&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;#&quot; method=&quot;post&quot;&gt; &lt;center&gt;注册账号&lt;/center&gt; &lt;table align=&quot;center&quot; border=&quot;1&quot;&gt; &lt;tr&gt; &lt;td&gt;用户名:&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;content[username]&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;email:&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;content[email]&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码:&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;content[pwd]&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;确认密码:&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;content[confirm_pwd]&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;性别:&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;radio&quot; name=&quot;content[sex]&quot; value=&quot;男&quot;&gt;男 &lt;input type=&quot;radio&quot; name=&quot;content[sex]&quot; value=&quot;女&quot; checked&gt;女 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;手机号码:&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;content[phone]&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;喜欢的编程技术:&lt;/td&gt; &lt;td&gt; &lt;select name=&quot;content[loveLanguage]&quot;&gt; &lt;option selected&gt;PHP&lt;/option&gt; &lt;option &gt;Python&lt;/option&gt; &lt;option&gt;Java&lt;/option&gt; &lt;option&gt;C&lt;/option&gt; &lt;option&gt;C++&lt;/option&gt; &lt;option&gt;Go&lt;/option&gt; &lt;option&gt;Rust&lt;/option&gt; &lt;option&gt;C#&lt;/option&gt; &lt;/select&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td COLSPAN=&quot;2&quot;&gt; &lt;input type=&quot;checkbox&quot; checked name=&quot;content[check]&quot;&gt;我已经看过并接受&lt;a href=&quot;https://www.bilibili.com/&quot; target=&quot;_blank&quot;&gt; &lt;b&gt;用户协议&lt;/b&gt;&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;立即注册&quot; name=&quot;bnt&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/form&gt; &lt;?php if (isset($_POST[&quot;bnt&quot;])) &#123; if (isset($_POST[&quot;content&quot;][&quot;check&quot;])) &#123; if ($_POST[&quot;content&quot;][&quot;username&quot;] == &quot;&quot; || $_POST[&quot;content&quot;][&quot;email&quot;] == &quot;&quot; || $_POST[&quot;content&quot;][&quot;pwd&quot;] == &quot;&quot; || $_POST[&quot;content&quot;][&quot;confirm_pwd&quot;] == &quot;&quot; || $_POST[&quot;content&quot;][&quot;sex&quot;] == &quot;&quot; || $_POST[&quot;content&quot;][&quot;phone&quot;] == &quot;&quot; || $_POST[&quot;content&quot;][&quot;loveLanguage&quot;] == &quot;&quot;) &#123; echo &quot;不能有不填的！&quot; or exit(&quot;回去填&quot;); &#125;else &#123; echo &quot;你好&quot;; echo &quot;用户名:&quot;.$_POST[&quot;content&quot;][&quot;username&quot;].&quot;&lt;br&gt;&quot;; echo &quot;邮箱:&quot;.$_POST[&quot;content&quot;][&quot;email&quot;].&quot;&lt;br&gt;&quot;; echo &quot;密码:&quot;.$_POST[&quot;content&quot;][&quot;pwd&quot;].&quot;&lt;br&gt;&quot;; echo &quot;确认密码:&quot;.$_POST[&quot;content&quot;][&quot;confirm_pwd&quot;].&quot;&lt;br&gt;&quot;; echo &quot;性别:&quot;.$_POST[&quot;content&quot;][&quot;sex&quot;].&quot;&lt;br&gt;&quot;; echo &quot;手机号:&quot;.$_POST[&quot;content&quot;][&quot;phone&quot;].&quot;&lt;br&gt;&quot;; echo &quot;你喜欢的编程预言:&quot;.$_POST[&quot;content&quot;][&quot;loveLanguage&quot;].&quot;&lt;br&gt;&quot;; &#125; &#125; &#125; ?&gt;&lt;/body&gt;&lt;/html&gt; 2 login_index.php 1234567891011121314&lt;?phpsession_start();if (! isset($_SESSION[&quot;is_login&quot;])) &#123; $_SESSION[&quot;is_login&quot;] = FALSE; echo &quot;亲爱的，请先&lt;a href=&#x27;login.html&#x27;&gt;&lt;b&gt;登录&lt;b&gt;&lt;a&gt;&quot;.&quot;&lt;br&gt;&quot;;&#125;else &#123; if ($_SESSION[&quot;is_login&quot;]) &#123; $name = $_SESSION[&quot;name&quot;]; echo $name.&quot;! 您好，欢迎光临本会所！&quot;.&quot;&lt;br&gt;&quot;; echo &quot;&lt;a href=&#x27;logout.php&#x27;&gt;&lt;b&gt;退出&lt;b&gt;&lt;a&gt;&quot;.&quot;&lt;br&gt;&quot;; &#125;else &#123; echo &quot;亲爱的，请先&lt;a href=&#x27;login.html&#x27;&gt;&lt;b&gt;登录&lt;b&gt;&lt;a&gt;&quot;.&quot;&lt;br&gt;&quot;; &#125;&#125; login.html 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;登陆系统&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3 align=&quot;center&quot;&gt;请登录！&lt;/h3&gt; &lt;form action=&quot;login.php&quot; method=&quot;post&quot;&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;您的昵称:&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;text&quot; name=&quot;user_name&quot; placeholder=&quot;最少一个汉字，最多10个汉字&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;您的密码:&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;password&quot; name=&quot;user_password&quot; placeholder=&quot;至少包含数字、字母，特殊字符中的2种&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;center&quot; colspan=&quot;2&quot;&gt;&lt;input type=&quot;checkbox&quot; value=&quot;7&quot; name=&quot;ok_boy&quot;&gt;&lt;i&gt;七天内自动登录&lt;/i&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;center&quot; colspan=&quot;2&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;登录&quot; name=&quot;bnt&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; login.php 123456789101112131415161718192021222324252627282930313233&lt;?phpsession_start();if (isset($_POST[&quot;bnt&quot;])) &#123; $user_name = trim($_POST[&quot;user_name&quot;]); $user_password = trim($_POST[&quot;user_password&quot;]); if ($user_name == &quot;&quot; || $user_password == &quot;&quot;) &#123; $_SESSION[&quot;is_login&quot;] = FALSE; echo &quot;您输入的昵称和密码不能为空，请重新输入！&lt;br&gt;3秒后自动跳转&lt;br&gt;&quot;; header(&quot;refresh:3;url = login.html&quot;); die(); &#125;elseif ($user_name != &quot;辉哥&quot; || $user_password != &quot;辉哥要发财&quot;)&#123; $_SESSION[&quot;is_login&quot;] = FALSE; echo &quot;您输入的昵称或密码有误，请重新输入！&lt;br&gt;3秒后自动跳转&lt;br&gt;&quot;; header(&quot;refresh:3;url = login.html&quot;); die(); &#125;else &#123; $_SESSION[&quot;is_login&quot;] = TRUE; $_SESSION[&quot;name&quot;] = $user_name; $_SESSION[&quot;password&quot;] = $user_password; if (isset($_POST[&quot;ok_boy&quot;])) &#123; if ($_POST[&quot;ok_boy&quot;] == &quot;7&quot;) &#123; setcookie(&quot;name&quot;, $user_name, time() + 7 * 24 * 3600); setcookie(&quot;password&quot;, $user_password, time() + 7 * 24 * 3600); &#125; &#125;else &#123; setcookie(&quot;name&quot;, $user_name, time() + 3600); setcookie(&quot;password&quot;, $user_password, time() + 3600); &#125; echo &quot;恭喜您！登陆成功！&lt;br&gt;3秒后自动跳转&lt;br&gt;&quot;; header(&quot;refresh:3;url = login_index.php&quot;); &#125;&#125; logout.php 123456789&lt;?phpsession_start();$name = $_SESSION[&quot;name&quot;];echo $name.&quot;，相逢何必曾相识，再见！&lt;br&gt;&quot;;setcookie(&quot;name&quot;, &quot;&quot;, 0);setcookie(&quot;password&quot;, &quot;&quot;, 0);$_SESSION = array();session_destroy();echo &quot;&lt;a href=&#x27;login_index.php&#x27;&gt;重新来一次&lt;a&gt;&quot;; 第15次作业 1 1INSERT INTO department VALUES (&#x27;1005&#x27;, &#x27;财务部&#x27;, &#x27;财务管理&#x27;, &#x27;天津&#x27;) 2 1SELECT d_id, d_name, function FROM department 3 1SELECT * FROM employee WHERE birthday BETWEEN 25 AND 30 4 1SELECT name, birthday, address FROM employee WHERE address LIKE(&#x27;%北京%&#x27;) 5 1UPDATE employee SET salary * 1.1 WHERE d_id = &#x27;1002&#x27; 6 1DELETE FROM employee WHERE id = &#x27;9006&#x27; 一个模板 12345678910111213141516171819$link = mysqli_connect(&quot;localhost&quot;, &quot;root&quot;, &quot;&quot;, &quot;jxgl&quot;);if ($link) &#123; echo &quot;连接本地mysql服务器成功！&lt;br&gt;&quot;; $data = mysqli_select_db($link, &quot;jxgl&quot;); if ($data)&#123; echo &quot;选择jxgl成功&lt;br&gt;&quot;; $query = &quot;SELECT * FROM student&quot;; $result = mysqli_query($link, $query); if ($result)&#123; ; # 处理数据结果集 &#125;else&#123; echo &quot;读取数据集失败&lt;br&gt;&quot;; &#125; &#125;else&#123; echo &quot;选择jxgl失败&lt;br&gt;&quot;; &#125;&#125;else &#123; echo &quot;连接本地mysql服务器失败！&quot;;&#125; 第16次作业 前面已经连接过一次数据库了，这里就不再重复连接了，只需要执行sql语句即可，比如下面的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;majors enquiry&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;?php $link = mysqli_connect(&quot;localhost&quot;, &quot;root&quot;, &quot;&quot;, &quot;jxgl&quot;); if ($link) &#123; echo &quot;连接本地mysql服务器成功！&lt;br&gt;&quot;; $data = mysqli_select_db($link, &quot;jxgl&quot;); if ($data)&#123; echo &quot;选择jxgl成功&lt;br&gt;&quot;; $query = &quot;SELECT * FROM specialty&quot;; $result = mysqli_query($link, $query); if ($result)&#123; echo &quot;读取数据集成功&lt;br&gt;&quot;; ; &#125;else&#123; echo &quot;读取数据集失败&lt;br&gt;&quot;; &#125; &#125;else&#123; echo &quot;选择jxgl失败&lt;br&gt;&quot;; &#125; &#125;else &#123; echo &quot;连接本地mysql服务器失败！&quot;; &#125;?&gt;&lt;?php if (isset($result)): ?&gt; &lt;form action=&quot;#&quot; method=&quot;post&quot;&gt; 请选择专业： &lt;select name=&quot;majors_zno&quot;&gt; &lt;?php while ($rs = mysqli_fetch_array($result, MYSQLI_ASSOC)): ?&gt; &lt;option value=&quot;&lt;?=$rs[&#x27;zno&#x27;]?&gt;&quot;&gt;&lt;?=$rs[&#x27;zname&#x27;]?&gt;&lt;/option&gt; &lt;?php endwhile; ?&gt; &lt;/select&gt; &lt;br&gt; &lt;input type=&quot;submit&quot; name=&quot;btn&quot; value=&quot;enquire&quot;&gt;&lt;!-- 先连接连接服务器查询专业再提交--&gt; &lt;/form&gt;&lt;?php endif; ?&gt;&lt;?php if (isset($_POST[&#x27;btn&#x27;]))&#123; $zno = $_POST[&#x27;majors_zno&#x27;]; echo $zno.&quot;&lt;hr&gt;&quot;;//前面已经连接过一次数据库了，这里就不再重复连接了，只需要执行sql语句即可 $query2 = &quot;SELECT * FROM student WHERE BINARY zno = &#x27;&#123;$zno&#125;&#x27;&quot;; $result2 = mysqli_query($link, $query2); if ($result2)&#123; echo &quot;读取数据集成功&lt;br&gt;&quot;; ; &#125;else&#123; echo &quot;读取数据集失败&lt;br&gt;&quot;; &#125; &#125;?&gt; &lt;?php if (isset($result2)): ?&gt;&lt;!--必须点击查询按钮之后，才会有result2，有result2才会有下面的学生信息表，没有if (isset($result2))，不提交查询按钮也会显示下面的表头--&gt; &lt;center&gt;&lt;h2&gt;学生信息&lt;/h2&gt;&lt;/center&gt; &lt;table border=&quot;1&quot; align=&quot;center&quot; width=&quot;1000&quot;&gt; &lt;tr&gt; &lt;th&gt;学号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;班级&lt;/th&gt; &lt;th&gt;查看出生日期&lt;/th&gt; &lt;/tr&gt; &lt;?php while ($rs2 = mysqli_fetch_array($result2, MYSQLI_ASSOC)): ?&gt; &lt;?php if ($rs2[&#x27;ssex&#x27;] == &#x27;男&#x27;): ?&gt; &lt;tr bgcolor=&quot;#dc143c&quot;&gt; &lt;?php endif; ?&gt; &lt;td&gt;&lt;?=$rs2[&#x27;sno&#x27;]?&gt;&lt;/td&gt; &lt;td&gt;&lt;?=$rs2[&#x27;sname&#x27;]?&gt;&lt;/td&gt; &lt;td&gt;&lt;?=$rs2[&#x27;ssex&#x27;]?&gt;&lt;/td&gt; &lt;td&gt;&lt;?=$rs2[&#x27;sclass&#x27;]?&gt;&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;detail.php?sbirth=&lt;?=$rs2[&#x27;sbirth&#x27;]?&gt;&quot; target=&quot;_blank&quot;&gt;查看出生日期&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;?php endwhile; ?&gt; &lt;?php echo &quot;共有数据：&quot;.mysqli_num_rows($result2).&quot;条&quot;; ?&gt; &lt;?php endif; ?&gt;&lt;/body&gt;&lt;/html&gt; 第17次作业 UPDATE 更新数据表必须加 WHERE，否则要么报错，要么修改所有行 JS if语句和C语言一样，一定要加{}，否则只会执行下面第一行 JS点击链接不跳转的3个方法： href属性设置为 1href = &quot;javascript:void(0);&quot; onclick属性设置为 1onclick = &quot;return false;&quot; 如果onclick 后面跟了一个函数，这个函数返回true or false，函数返回false则终止链接的跳转，那么必须这样写： 1onclick = &quot;return Checkme()&quot; Checkme()前面的return是必不可少的，否则达不到想要的效果 update_delete_student_info.php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Redden Boy&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;?php$link = mysqli_connect(&quot;localhost&quot;, &quot;root&quot;, &quot;&quot;, &quot;jxgl&quot;);if ($link) &#123; echo &quot;连接本地mysql服务器成功！&lt;br&gt;&quot;; $data = mysqli_select_db($link, &quot;jxgl&quot;); mysqli_set_charset($link, &#x27;utf8&#x27;); if ($data)&#123; echo &quot;选择jxgl成功&lt;br&gt;&quot;; $query = &quot;SELECT * FROM student&quot;; $result = mysqli_query($link, $query); if ($result)&#123; echo &quot;读取数据集成功&lt;br&gt;&quot;; ; &#125;else&#123; echo &quot;读取数据集失败&lt;br&gt;&quot;; &#125; &#125;else&#123; echo &quot;选择jxgl失败&lt;br&gt;&quot;; &#125;&#125;else &#123; echo &quot;连接本地mysql服务器失败！&quot;;&#125;?&gt;&lt;center&gt;&lt;h2&gt;学生信息&lt;/h2&gt;&lt;/center&gt;&lt;table border=&quot;1&quot; align=&quot;center&quot; width=&quot;1000&quot;&gt; &lt;tr&gt; &lt;th&gt;学号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;班级&lt;/th&gt; &lt;th&gt;更新&lt;/th&gt; &lt;th&gt;删除&lt;/th&gt; &lt;/tr&gt; &lt;script language=&quot;JavaScript&quot;&gt; function Checkme() &#123; if (confirm(&quot;是否确定删除数据？&quot;) === true)&#123; alert(&quot;成功删除数据&quot;); return true; &#125; else &#123; alert(&quot;没有删除数据&quot;); return false; &#125; &#125; &lt;/script&gt; &lt;?php if (isset($result)): ?&gt; &lt;?php while ($rs = mysqli_fetch_array($result, MYSQLI_ASSOC)): ?&gt; &lt;?php if ($rs[&#x27;ssex&#x27;] == &#x27;男&#x27;): ?&gt; &lt;tr bgcolor=&quot;#dc143c&quot;&gt; &lt;?php endif; ?&gt; &lt;td&gt;&lt;?=$rs[&#x27;sno&#x27;]?&gt;&lt;/td&gt; &lt;td&gt;&lt;?=$rs[&#x27;sname&#x27;]?&gt;&lt;/td&gt; &lt;td&gt;&lt;?=$rs[&#x27;ssex&#x27;]?&gt;&lt;/td&gt; &lt;td&gt;&lt;?=$rs[&#x27;sclass&#x27;]?&gt;&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;update.php?sno=&lt;?=$rs[&#x27;sno&#x27;]?&gt;&quot; target=&quot;_blank&quot;&gt;update&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;deletion.php?sno=&lt;?=$rs[&#x27;sno&#x27;]?&gt;&quot; target=&quot;_blank&quot; onclick=&quot;return Checkme()&quot;&gt;delete&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;?php endwhile; ?&gt; &lt;?php endif; ?&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; update.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Crud Boy&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;?php$sno = $_GET[&#x27;sno&#x27;];$link = mysqli_connect(&quot;localhost&quot;, &quot;root&quot;, &quot;&quot;, &quot;jxgl&quot;);if ($link) &#123; echo &quot;连接本地mysql服务器成功！&lt;br&gt;&quot;; $data = mysqli_select_db($link, &quot;jxgl&quot;); mysqli_set_charset($link, &#x27;utf8&#x27;); if ($data)&#123; echo &quot;选择jxgl成功&lt;br&gt;&quot;; $query = &quot;SELECT * FROM specialty&quot;; $result = mysqli_query($link, $query); $query2 = &quot;SELECT * FROM student WHERE sno = &#x27;&#123;$sno&#125;&#x27;&quot;; $result2 = mysqli_query($link, $query2); $rs2 = mysqli_fetch_array($result2, MYSQLI_ASSOC); if ($result and $result2)&#123; echo &quot;读取数据集成功&lt;br&gt;&quot;; &#125;else&#123; echo &quot;读取数据集失败&lt;br&gt;&quot;; &#125; &#125;else&#123; echo &quot;选择jxgl失败&lt;br&gt;&quot;; &#125;&#125;else &#123; echo &quot;连接本地mysql服务器失败！&quot;;&#125;?&gt;&lt;?php if (isset($result) and isset($result2) and isset($rs2)): ?&gt;&lt;form action=&quot;#&quot; method=&quot;post&quot;&gt; &lt;center&gt;&lt;h2&gt;crud学生信息&lt;/h2&gt;&lt;/center&gt; &lt;table border=&quot;1&quot; align=&quot;center&quot; width=&quot;1000&quot;&gt; &lt;tr&gt; &lt;td align=&quot;right&quot;&gt;学号&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;txtsno&quot; value=&quot;&lt;?=$rs2[&#x27;sno&#x27;]?&gt;&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;right&quot;&gt;姓名&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;txtsname&quot; value=&quot;&lt;?=$rs2[&#x27;sname&#x27;]?&gt;&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;right&quot;&gt;性别&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;radio&quot; name=&quot;rdossex&quot; value=&quot;男&quot; &lt;?php if ($rs2[&#x27;ssex&#x27;]==&#x27;男&#x27;)&#123;echo &#x27;checked=&quot;checked&quot;&#x27;;&#125;?&gt;&gt;男 &lt;input type=&quot;radio&quot; name=&quot;rdossex&quot; value=&quot;女&quot; &lt;?php if ($rs2[&#x27;ssex&#x27;]==&#x27;女&#x27;)&#123;echo &#x27;checked=&quot;checked&quot;&#x27;;&#125;?&gt;&gt;女 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;right&quot;&gt;出生日期&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;txtsbirth&quot; value=&quot;&lt;?=$rs2[&#x27;sbirth&#x27;]?&gt;&quot;&gt;(形如：YYYY-MM-DD)&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;right&quot;&gt;专业&lt;/td&gt; &lt;td&gt; &lt;select name=&quot;majors_zno&quot;&gt; &lt;?php while ($rs = mysqli_fetch_array($result, MYSQLI_ASSOC)): ?&gt; &lt;?php if ($rs[&#x27;zno&#x27;]==$rs2[&#x27;zno&#x27;]): ?&gt; &lt;option value=&quot;&lt;?=$rs[&#x27;zno&#x27;]?&gt;&quot; selected=&quot;selected&quot;&gt;&lt;?=$rs[&#x27;zname&#x27;]?&gt;&lt;/option&gt; &lt;?php else: ?&gt; &lt;option value=&quot;&lt;?=$rs[&#x27;zno&#x27;]?&gt;&quot;&gt;&lt;?=$rs[&#x27;zname&#x27;]?&gt;&lt;/option&gt; &lt;?php endif; ?&gt; &lt;?php endwhile; ?&gt; &lt;/select&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;right&quot;&gt;所在班级&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;txtsclass&quot; value=&quot;&lt;?=$rs2[&#x27;sclass&#x27;]?&gt;&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;right&quot;&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;submit&quot; name=&quot;btn_update&quot; value=&quot;update&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/form&gt;&lt;?php endif; ?&gt;&lt;?phpif (isset($_POST[&#x27;btn_update&#x27;]))&#123; $sno = $_POST[&#x27;txtsno&#x27;]; $sname = $_POST[&#x27;txtsname&#x27;]; $ssex = $_POST[&#x27;rdossex&#x27;]; $sbirth = $_POST[&#x27;txtsbirth&#x27;]; $zno = $_POST[&#x27;majors_zno&#x27;]; $sclass = $_POST[&#x27;txtsclass&#x27;]; $query3 = &quot;UPDATE student SET sno=&#x27;$sno&#x27;, sname=&#x27;$sname&#x27;, ssex=&#x27;$ssex&#x27;, sbirth=&#x27;$sbirth&#x27;, zno=&#x27;$zno&#x27;, sclass=&#x27;$sclass&#x27; WHERE sno=&#x27;$sno&#x27;&quot;; $result3 = mysqli_query($link, $query3); if ($result3)&#123; echo &quot;读取数据集成功&lt;br&gt;&quot;; echo &quot;update successfully!&lt;br&gt;&quot;; ; &#125;else&#123; echo &quot;读取数据集失败&lt;br&gt;&quot;; &#125;&#125;?&gt;&lt;/body&gt;&lt;/html&gt; deletion.php 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Crud Boy&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;?php$sno = $_GET[&#x27;sno&#x27;];$link = mysqli_connect(&quot;localhost&quot;, &quot;root&quot;, &quot;&quot;, &quot;jxgl&quot;);if ($link) &#123; echo &quot;连接本地mysql服务器成功！&lt;br&gt;&quot;; $data = mysqli_select_db($link, &quot;jxgl&quot;); mysqli_set_charset($link, &#x27;utf8&#x27;); if ($data)&#123; echo &quot;选择jxgl成功&lt;br&gt;&quot;; $query = &quot;DELETE FROM student WHERE sno = &#x27;&#123;$sno&#125;&#x27;&quot;; $result = mysqli_query($link, $query); $query2 = &quot;DELETE FROM sc WHERE sno = &#x27;&#123;$sno&#125;&#x27;&quot;; $result2 = mysqli_query($link, $query2); if ($result and $result2)&#123; echo &quot;读取数据集成功&lt;br&gt;&quot;; echo &quot;delete successfully!&lt;br&gt;&quot;; &#125;else&#123; echo &quot;读取数据集失败&lt;br&gt;&quot;; &#125; &#125;else&#123; echo &quot;选择jxgl失败&lt;br&gt;&quot;; &#125;&#125;else &#123; echo &quot;连接本地mysql服务器失败！&quot;;&#125;?&gt;&lt;/body&gt;&lt;/html&gt; insert_student_info.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Crud Boy&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;?php$link = mysqli_connect(&quot;localhost&quot;, &quot;root&quot;, &quot;&quot;, &quot;jxgl&quot;);if ($link) &#123; echo &quot;连接本地mysql服务器成功！&lt;br&gt;&quot;; $data = mysqli_select_db($link, &quot;jxgl&quot;); mysqli_set_charset($link, &#x27;utf8&#x27;); if ($data)&#123; echo &quot;选择jxgl成功&lt;br&gt;&quot;; $query = &quot;SELECT * FROM specialty&quot;; $result = mysqli_query($link, $query); if ($result)&#123; echo &quot;读取数据集成功&lt;br&gt;&quot;; ; &#125;else&#123; echo &quot;读取数据集失败&lt;br&gt;&quot;; &#125; &#125;else&#123; echo &quot;选择jxgl失败&lt;br&gt;&quot;; &#125;&#125;else &#123; echo &quot;连接本地mysql服务器失败！&quot;;&#125;?&gt;&lt;form action=&quot;#&quot; method=&quot;post&quot;&gt;&lt;center&gt;&lt;h2&gt;crud学生信息&lt;/h2&gt;&lt;/center&gt;&lt;table border=&quot;1&quot; align=&quot;center&quot; width=&quot;1000&quot;&gt; &lt;tr&gt; &lt;td align=&quot;right&quot;&gt;学号&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;txtsno&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;right&quot;&gt;姓名&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;txtsname&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;right&quot;&gt;性别&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;radio&quot; name=&quot;rdossex&quot; value=&quot;男&quot;&gt;男 &lt;input type=&quot;radio&quot; name=&quot;rdossex&quot; value=&quot;女&quot; checked=&quot;checked&quot;&gt;女 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;right&quot;&gt;出生日期&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;txtsbirth&quot;&gt;(形如：YYYY-MM-DD)&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;right&quot;&gt;专业&lt;/td&gt; &lt;td&gt; &lt;select name=&quot;majors_zno&quot;&gt; &lt;?php if (isset($result)): ?&gt; &lt;?php while ($rs = mysqli_fetch_array($result, MYSQLI_ASSOC)): ?&gt; &lt;option value=&quot;&lt;?=$rs[&#x27;zno&#x27;]?&gt;&quot;&gt;&lt;?=$rs[&#x27;zname&#x27;]?&gt;&lt;/option&gt; &lt;?php endwhile; ?&gt; &lt;?php endif; ?&gt; &lt;/select&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;right&quot;&gt;所在班级&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;txtsclass&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;right&quot;&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;submit&quot; name=&quot;btn_insert&quot; value=&quot;insert&quot;&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/form&gt;&lt;?phpif (isset($_POST[&#x27;btn_insert&#x27;]))&#123; $sno = $_POST[&#x27;txtsno&#x27;]; $sname = $_POST[&#x27;txtsname&#x27;]; $ssex = $_POST[&#x27;rdossex&#x27;]; $sbirth = $_POST[&#x27;txtsbirth&#x27;]; $zno = $_POST[&#x27;majors_zno&#x27;]; $sclass = $_POST[&#x27;txtsclass&#x27;]; $query2 = &quot;INSERT INTO student SET sno=&#x27;$sno&#x27;, sname=&#x27;$sname&#x27;, ssex=&#x27;$ssex&#x27;, sbirth=&#x27;$sbirth&#x27;, zno=&#x27;$zno&#x27;, sclass=&#x27;$sclass&#x27;&quot;; $result2 = mysqli_query($link, $query2); if ($result2)&#123; echo &quot;读取数据集成功&lt;br&gt;&quot;; echo &quot;insert successfully!&lt;br&gt;&quot;; ; &#125;else&#123; echo &quot;读取数据集失败&lt;br&gt;&quot;; &#125; &#125;?&gt;&lt;/body&gt;&lt;/html&gt; 第18次作业 1 整型 浮点型 定点型 日期时间类型 字符型 TINYINT FLOAT DECIMAL YEAY CHAR SMALLINT DOUBLE TIME VARCHAR MEDIUMINT DATE TINYTEXT INT DATETIME TEXT BIGINT TIMETAMP MEDIUMTEXT LONGTEXT ENUM(&quot;&quot;, “”, ……) SET(&quot;&quot;, “”, ……) 2 having是在分组后对数据进行过滤 where是在分组前对数据进行过滤 having后面可以使用聚合函数 where后面不可以使用聚合 3 count()函数：实现统计表中数据的条数 avg()函数：实现计算字段值的平均值 sum()函数：实现计算字段值的总和 max()函数：实现查询字段值的最大值 min()函数：实现查询字段值的最小值 4-27 D C B A A A A C B C A B B A A D C B C D C B B 第19次作业 1 连接mysql服务器 选择mysql数据库 执行sql语句 关闭结果集 关闭mysql服务器 2 使用mysqli_fetch_array()从结果集中获取一行作为对象 使用mysqli_fetch_array()从结果集中获取一行作为数组 3 1-3 12345678CREATE DATABASE tom;USE tom;CREATE TABLE &#x27;tomcat&#x27; (&#x27;name&#x27; char(10), &#x27;age&#x27; int(6));INSERT INTO tomcat SET name = &#x27;li1&#x27;, age = 15;INSERT INTO tomcat SET name = &#x27;li2&#x27;, age = 16;INSERT INTO tomcat SET name = &#x27;li3&#x27;, age = 17;INSERT INTO tomcat SET name = &#x27;li4&#x27;, age = 18;INSERT INTO tomcat SET name = &#x27;li5&#x27;, age = 19; 4 123456789101112131415161718192021222324$link = mysqli_connect(&quot;localhost&quot;, &quot;root&quot;, &quot;&quot;, &quot;tom&quot;);if ($link) &#123; echo &quot;连接本地mysql服务器成功！&lt;br&gt;&quot;; $data = mysqli_select_db($link, &quot;tom&quot;); mysqli_set_charset($link, &#x27;utf8&#x27;); if ($data)&#123; echo &quot;选择tom成功&lt;br&gt;&quot;; $query = &quot;SELECT * FROM tomcat&quot;; $result = mysqli_query($link, $query); if ($result)&#123; echo &quot;读取数据集成功&lt;br&gt;&quot;; while ($rs = mysqli_fetch_array($result, MYSQLI_ASSOC))&#123; echo $rs[&#x27;name&#x27;].&quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;.$rs[&#x27;age&#x27;].&quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;; &#125; echo &quot;共有数据：&quot;.mysqli_num_rows($result).&quot;条&quot;; &#125;else&#123; echo &quot;读取数据集失败&lt;br&gt;&quot;; &#125; &#125;else&#123; echo &quot;选择jxgl失败&lt;br&gt;&quot;; &#125;&#125;else &#123; echo &quot;连接本地mysql服务器失败！&quot;;&#125; 4-10 D B D A D A D 构造方法可以带参数，但不能有return 第20次作业 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?php class Circle &#123; private $radius; const pi = 3.1415926; public function __construct($radius = 0) &#123; $this-&gt;radius = $radius; &#125; public function __set($name, $value) &#123; // TODO: Implement __set() method. if ($value &gt;= 0) &#123; $this-&gt;$name = $value; &#125; else &#123; exit(&#x27;your radius is illegal&#x27;); &#125; &#125; public function __get($name) &#123; // TODO: Implement __get() method. if (isset($this-&gt;$name)) &#123; return $this-&gt;$name; &#125; else &#123; return null; &#125; &#125; public function getPerimeter() &#123; return 2 * self::pi * $this-&gt;radius; &#125; public function getArea() &#123; return self::pi * pow($this-&gt;radius, 2); &#125; &#125; $circle1 = new Circle(3); echo &quot;&lt;hr&gt;perimeter is &quot;.$circle1-&gt;getPerimeter(); echo &quot;&lt;hr&gt;area is &quot;.$circle1-&gt;getArea(); 面向对象编程时，所有方法和成员变量都要带上关键字，倒不是说必须，而是一种好的编程习惯 每个类尽量放在单独的一个php文件中，并且该php文件与存放的类名保持一致，这是一个好习惯。 1-9 ↩︎","categories":[],"tags":[]},{"title":"C语言控制台打印图标小技巧","slug":"C_Print_icon","date":"2022-09-18T16:00:00.000Z","updated":"2022-10-19T09:06:43.750Z","comments":true,"path":"2022/09/19/C_Print_icon/","link":"","permalink":"http://example.com/2022/09/19/C_Print_icon/","excerpt":"","text":"打印左直角三角形： 123456789101112131415#include &lt;stdio.h&gt;int main(void) &#123; for(int i = 1; i &lt;= 7; ++i)&#123; for (int j = 1; j &lt;= i; ++j)&#123; // 技巧在于 j &lt;= i printf(&quot;*&quot;); &#125; // for(int j = 1; j &lt;= i; ++j)&#123; // printf(&quot;*&quot;); // &#125; printf(&quot;\\n&quot;); &#125; return 0;&#125; 打印右直角三角形： 1234567891011121314151617#include &lt;stdio.h&gt;int main(void) &#123; for(int i = 1; i &lt;= 7; ++i)&#123; for (int j = 6; j &gt;= i; --j)&#123; /* 这里是 j = 6开始，为什么不是7呢， 因为如果是7，在最后一行就会多打一个空格出来。*/ printf(&quot; &quot;); &#125; for(int j = 1; j &lt;= i; ++j)&#123; // 其实我们打印左直角三角形，还是打印右直角三角形，还是等腰，每行打印的 * 号数量都不变，他的形状变化主要用空格来调控。 printf(&quot;*&quot;); &#125; printf(&quot;\\n&quot;); &#125; return 0;&#125; 打印等腰三角形： 12345678910111213141516#include &lt;stdio.h&gt;int main(void) &#123; for(int i = 1; i &lt;= 7; ++i)&#123; for (int j = 6; j &gt;= i; --j)&#123; printf(&quot; &quot;); &#125; for(int j = 1; j &lt;= i; ++j)&#123; printf(&quot;* &quot;); // 只需在右直角三角形的*后面加空格。 //加一个空格为什么就能变成等腰三角形呢？第一行多打印了1个空格，第2行多打印了2个空格，以此类推 &#125; printf(&quot;\\n&quot;); &#125; return 0;&#125; 打印图形这种题目，把它化成函数很容易解决，比如下面这个： 1234567891011121314int main()&#123; int n = 0; scanf(&quot;%d&quot;, &amp;n); char c = &#x27;A&#x27;; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt;= i; ++j) &#123; printf(&quot;%c&quot;, c); &#125; printf(&quot;\\n&quot;); ++c; &#125; return 0;&#125; 我们输入6，输出： 123456ABBCCCDDDDEEEEEFFFFFF 其中第1个循环相当于给出x的范围，第2个循环相当于在坐标轴上打印 y &lt;= x 我们改一下第2个循环的函数曲线： 123456789101112131415int main()&#123; int n = 0; scanf(&quot;%d&quot;, &amp;n); char c = &#x27;A&#x27;; for (int i = 0; i &lt; n; ++i) &#123; int n2 = n / 2; for (int j = 0; j &lt;= (n2 - abs(n2 - i)); ++j) &#123; printf(&quot;%c&quot;, c); &#125; printf(&quot;\\n&quot;); ++c; &#125; return 0;&#125; 我们输入7，输出： 1234567ABBCCCDDDDEEEFFG 如果我们想让输出的每一行的字母个数都是奇数，该这样做： 1234567891011121314int main()&#123; int n = 0; scanf(&quot;%d&quot;, &amp;n); char c = &#x27;A&#x27;; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 1; j &lt;= 2 * i + 1; ++j) &#123; printf(&quot;%c&quot;, c); &#125; printf(&quot;\\n&quot;); ++c; &#125; return 0;&#125; 我们输入5，输出： 12345ABBBCCCCCDDDDDDDEEEEEEEEE 同样的，更改y函数也可以让输出的每一行的字母个数都是奇数： 123456789101112131415int main()&#123; int n = 0; scanf(&quot;%d&quot;, &amp;n); char c = &#x27;A&#x27;; for (int i = 0; i &lt; n; ++i) &#123; int n2 = n / 2; for (int j = 1; j &lt;= 2 * (n2 - abs(n2 - i)) + 1; ++j) &#123; printf(&quot;%c&quot;, c); &#125; printf(&quot;\\n&quot;); ++c; &#125; return 0;&#125; 我们输入7，输出： 1234567ABBBCCCCCDDDDDDDEEEEEFFFG","categories":[],"tags":[]},{"title":"解决CLion中建立多个c/cpp文件(多个main函数共存)的问题","slug":"CLion-Single-File-Execution","date":"2022-09-05T07:08:12.000Z","updated":"2022-09-05T07:49:14.241Z","comments":true,"path":"2022/09/05/CLion-Single-File-Execution/","link":"","permalink":"http://example.com/2022/09/05/CLion-Single-File-Execution/","excerpt":"","text":"用下面这些方法需要注意，既然在 Cmakelists.text 文件里多了几行add_executable(……)，那么删除项目里c文件或者cpp文件时，就必须记得连同Cmakelists.text 文件里相应的add_executable(……)一同删去，否则会警告。 另外，add executable for simple C/C++ file 后别忘了Cmakelists.text重新加载变更，否则会有警告。 另外，一个project里面貌似不能既有cpp又有c文件。我不确定哈，只是我目前这样做cpp会报错。 贴链接： 使用CLion 刷题解决多个main函数问题的终极方法 解决CLion中建立多个c/cpp文件(多个main函数共存)的问题 Clion如何编译运行多个源文件 感谢Kosuke Nakago和他的C/C+​+​ Single File Execution","categories":[],"tags":[]},{"title":"小作业1-登录功能(控制台)","slug":"FunctionLogin-1","date":"2022-08-30T10:30:31.000Z","updated":"2022-08-30T14:21:11.315Z","comments":true,"path":"2022/08/30/FunctionLogin-1/","link":"","permalink":"http://example.com/2022/08/30/FunctionLogin-1/","excerpt":"","text":"小作业 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169/* 根据以下要求, 实现一套登录功能 已知有全局变量 int[] ids = &#123;10001,10002,10003,10004&#125;; String[] names = &#123;&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;, &quot;赵六&quot;&#125;; String[] passwords = &#123;&quot;aaaaa&quot;,&quot;bbbbb&quot;,&quot;ccccc&quot;,&quot;ddddd&quot;&#125;; int uNum = 4; 其中 每个下标对应一套用户数据(id, 名称, 密码) 如下标[1]: 对应10002, 李四, bbbbb 根据以下的函数声明和注释, 写出相应的函数实现 */import java.util.Scanner;public class FunctionLogin&#123; public static void main(String[] args) &#123; Function F1 = new Function(); F1.showLoginPage(); &#125;&#125;class Function &#123; // 定义字段 int[] ids = &#123;10001, 10002, 10003, 10004&#125;; String[] names = &#123;&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;, &quot;赵六&quot;&#125;; String[] passwords = &#123;&quot;aaaaa&quot;, &quot;bbbbb&quot;, &quot;ccccc&quot;, &quot;ddddd&quot;&#125;; int uNum = 4; int id; String password; String name;/* 功能: 根据id 查询用户是否存在, 如果存在返回用户名, 如果不存在返回空 参数: uid: 用户id 返回值: 如果用户存在, 返回用户名. 如果用户不存在, 返回NULL*/ public String selectUserById(int uid) &#123; for (int i = 0; i &lt; uNum; i++)&#123; if (ids[i] == uid)&#123; this.name = names[i]; &#125; &#125; //属性String型如果不初始化则默认赋null return this.name; &#125;/* 功能: 根据id 查询用户密码, 如果存在返回用户密码, 如果不存在返回空 参数: uid: 用户id 返回值: 如果密码存在, 返回密码. 如果密码不存在, 返回NULL*/ public String selectPassById(int uid) &#123; for (int i = 0; i &lt; uNum; i++)&#123; if (ids[i] == uid)&#123; this.password = passwords[i]; &#125; &#125; //属性String型如果不初始化则默认赋null return this.password; &#125;/* 功能: 传入用户id和密码, 根据上面两个函数(selectUserById, selectPassById)来获取相应用户数据, 并判断是否登录成功 传入用户id 查询用户名是否存在, 并获取用户密码 如果用户存在 则判断密码是否正确 参数: uid: 用户账户 password: 用户密码 返回值: 如果账号不存在, 返回1 如果密码错误, 返回2 如果登录成功, 返回0*/ public int login(int uid, String uPassword)&#123; int res = 0; this.name = selectUserById(uid); this.password = selectPassById(uid); if (this.name == null)&#123; res = 1; &#125; if (this.password == null)&#123; res = 2; &#125; if (res == 0) &#123; if (this.password.equals(uPassword)) &#123; System.out.println(&quot;您输入的密码正确！\\n&quot;); &#125; else &#123; System.out.println(&quot;您输入id正确，但密码有误\\n&quot;); res = 3; &#125; &#125; return res; &#125;/* 功能: 提示用户输入账号密码, 根据login函数判断是否登录成功, 如果登录成功提示正在进入首页 如果登录失败 密码错误: 提示密码错误, 并让用户重新登录 账号不存在: 提示账号不存在, 并提示正在进入注册界面 参数: 无 返回值: 无*/ public void showLoginPage() &#123; Scanner myScanner = new Scanner(System.in); System.out.println(&quot;请依次输入您的id和密码\\n&quot;); int uid2 = myScanner.nextInt(); String uPassword2 = myScanner.next(); int rly = login(uid2, uPassword2); switch (rly) &#123; case 0 -&gt; System.out.println(&quot;登录成功，正在进入首页……\\n&quot;); case 1 -&gt; System.out.println(&quot;您输入的id不存在，正在重新进入注册界面……\\n&quot;); case 2 -&gt; System.out.println(&quot;根据您的id查询不到相应密码，正在重新进入注册界面……\\n&quot;); case 3 -&gt; System.out.println(&quot;您的id输入正确，但密码输入错误，清重新登录！\\n&quot;); default -&gt; System.out.println(&quot;Who care ?\\n&quot;); &#125; &#125;/* 实现一套注册功能 */ public void registerYou()&#123; Scanner myScanner = new Scanner(System.in); System.out.println(&quot;请给您的账户起一个好听的名字\\n&quot;); String newName = myScanner.next(); System.out.println(&quot;请给您的账户输入一个密码\\n&quot;); String newPassWord = myScanner.next(); int[] ids2 = new int[1000]; String[] names2 = new String[1000]; String[] passwords2 = new String[1000]; for (int i = 0; i &lt; uNum; i++)&#123; ids2[i] = this.ids[i]; names2[i] = this.names[i]; passwords2[i] = this.passwords[i]; &#125; ids2[uNum] = 10000 + (uNum + 1); names2[uNum] = newName; passwords2[uNum] = newPassWord; ++uNum; this.ids = ids2; this.names = names2; this.passwords = passwords2; int rly2 = login(this.ids[uNum - 1], this.passwords[uNum - 1]); if (rly2 == 0)&#123; System.out.println(&quot;恭喜您，注册成功！&quot;); &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"韩总Java修仙","slug":"Java-learning","date":"2022-08-21T08:23:00.000Z","updated":"2022-11-15T02:56:13.762Z","comments":true,"path":"2022/08/21/Java-learning/","link":"","permalink":"http://example.com/2022/08/21/Java-learning/","excerpt":"","text":"环境搭建 IDEA自带JDK吗 下载idea的时候可以选带JDK的或者不带的，默认带JDK的，理论上也可以不用外部的，配置自带的JDK即可，不过Idea自带的是OpenJDK，不是oracle jdk; idea自带jdk，是openjdk，idea是使用Java开发的，所以为了在一台没有配置过Java环境的电脑上也可以运行idea，又考虑了商业版权问题，所以采用了OpenJDK JDK、JRE、JVM之间的关系 JDK(Java Development Kit):Java开发工具包，提供给Java程序员使用，包含了JRE，同时还包含了编译器javac与自带的调试工具Jconsole、jstack等。，它提供了Java的开发环境(提供了编译器javac等工具，用于将java文件编译为class文件)和运行环境(提供了JVM和Runtime辅助包，用于解析class文件使其得到运行)。如果你下载并安装了JDK，那么你不仅可以开发Java程序，也同时拥有了运行Java程序的平台。 JDK是整个Java的核心，包括了Java运行环境(JRE)，一堆Java工具tools.jar和Java标准类库 (rt.jar)。当今最流行的两个Java开发工具包(JDK):Oracle JDK和 OpenJDK，常用Oracle JDK。 JRE(Java Runtime Environment):Java运行时环境，包含了JVM，Java基础类库。是使用Java语言编写程序运行的所需环境。JRE面向Java程序的使用者，而不是开发者。如果你仅下载并安装了JRE，那么你的系统只能运行Java的class程序。JRE是运行Java程序所必须环境的集合，包含JVM标准实现及 Java核心类库。它包括Java虚拟机、Java平台核心类和支持文件。 它不包含开发工具(编译器、调试器等)。 JVM(Java Virtual Machine)：Java虚拟机，运行Java代码。不同的操作系统需要安装不同版本的JVM，而JVM是JDK的子集，因此，JDK也有对应不同操作系统的各种版本。JVM屏蔽底层运行平台的差别，从而实现“一次编译，到处运行”。 JDK=JRE+开发工具集(比如:javac) JRE=JVM+JavaSE标准类库 综上，JDK是JRE的超集，而JRE又是JVM的超集 JavaSE、JavaEE、JavaME Java是一门编程语言, 分为 JavaSE、JavaEE、JavaME 三大版本. JavaSE (Java Platform，Standard Edition, 标准版) also known as Java 2 Platform 可以开发和部署在桌面、服务器、嵌入式环境和实时环境中使用的 Java 应用程 序。 Java SE 包含了支持 Java Web 服务开发的类是EE，和ME的基础。javaSE是java的基石，如果将java程序想象成一座高楼大厦，那么javaSE就是地基。 主要做一般的java应用, 比如, 应用软件/ QQ之类的通信软件等等. 此前叫做J2SE Java EE (Java Platform，Enterprise Edition, 企业版) 是Sun公司为企业级应用推出的标准平台。JavaEE是个大杂烩，包括Applet、EJB、JDBC、JNDI、Servlet、JSP等技术的标准，运行在一个完整的应用服务器上，用来开发大规模、分布式、健壮的网络应用。 其实是一套规范，就是用java语言做企业开发, 比如公司网站, 企业解决方案等 在JavaSE的基础上构建 提供Web 服务、组建模型、管理和通信API.可以用来实现企业级的面向服务体系结构(service-oriented architecture,SOA)和web2.0应用程序 此前叫做J2EE JavaWeb 主要指以Java语言为基础 可以粗略地认为JavaWeb就是JavaEE的一部分 利用JavaEE中的Servlet, JSP等技术开发动态页面, 方便用户通过浏览器与服务器后台交互 Java Web应用程序可运行在一个轻量级的Web服务器中，比如Tomcat。 Java ME (Java Platform，Micro Edition, 微型版) 写移动端(移动设备和嵌入式设备（比如手机、PDA、电视机顶盒和打印机）。javaME这一块只需要了解就可以了，因为现在很少有使用这个东西的了， SDK 与 JDK的区别 SDK（Software Development Kit） 软件开发工具包，是一个相当广泛的名词， 可以这么说辅助开发某一类软件的相关文档，范例和工具的集合都可以叫做“SDK”。SDK是一系列文件的组合，它为软件的开发提供了一个平台。 JDK（Java Development Kit）Java 开发工具包，是针对Java开发的产品。 JDK是SDK的一个子集，因为它是开发java程序的一个平台，开发其他程序的SDK可以没有JDK。比如你下载了一个软件平台eclipse-SDK-3.2.2-win32.zip，它本身里面是没有JDK的。但是只要开发Java程序就必须使用JDK（Java EE和Java SE） Day 1 java是编译型语言还是解释型语言？ 现在用编译型、解释型来分类编程语言已经有点力不从心了。java的javac编译器(全称java compiler)先将其编译为class文件，也就是字节码；然后将字节码交由jvm(java虚拟机)解释执行；所以很多地方都说“java是一种半编译、半解释执行”的语言；现在倾向于避开把编程语言描述为“编译型”或者“解释性”的。 java诞生 1990年 SUN公司启动绿色计划，希望在一些设备，比如电视、冰箱、微波炉、机顶盒上编程。 1992年创建oak(橡树)语言，最开始叫“Oak”，是一种在硅谷很常见的橡树。但开发公司在申请注册商标时发现，Oak已经被使用了。如果没有一个合适的名字，他们不得不延后这个语言的面世。没有办法，开发公司只好召开了一个命名征集会，在命名顾问一系列名字之后，最终，使用了Java这一名字。Java其实是印度尼西亚爪哇岛的英文名称，当地因盛产咖啡而闻名。据说，命名者就是在与同事品尝Java咖啡时得到的灵感。 1994年gosling在硅谷大会上演示Java一个可以在网页上展示动态图的功能震惊了世界，当时网页只能展示静态图。 1995年SUN正式发布Java第一个版本 2009甲骨文(Oracle)公司宣布收收购SUN。2011，发布java7。目前java是Oracle的，也是由它维护的。 2014发布java8，该版本也是现在企业用的最广泛的。因为该版本∈LTS(long-term-support)，即长期支持版。Java11也是LTS，像什么第9版第10版，第12版第13版，都不是LTS，都已经不可获得了，所以8和11版本也是现在企业用的最广泛的。因此我们一般学习8和11的特性。 第一个程序入门 123456789101112131415//这是java的快速入门，演示java的开发步骤//对代码的相关说明//1. public class HelloWorld是一个java 类，这也是我们创建时点类的原因，是一个public公有类//2. HelloWorld&#123;&#125; 表示一个类的开始和结束。//3. public static void main(String[] args) 表示一个主方法，即我们程序的入口。//4. main()&#123;&#125; 表示方法的开始和结束。//5. System.out.println(&quot;Hello World !&quot;); 表示输出&quot;Hello World !&quot;到屏幕。//6. ; 表示语句的结束。public class HelloWorld &#123; // 编写一个main方法 public static void main(String[] args) &#123; System.out.println(&quot;Hello World !!&quot;); &#125;&#125; JAVA运行机制 .java 文件称为源文件，经过javac编译为 .class 文件，又称字节码文件，再装载给JVM运行。修改源文件记得重新编译为新的字节码文件。 JAVA开发注意事项 JAVA源文件以.java为扩展名，不要乱改。 JAVA语言严格区分大小写。 JAVA方法由一条条语句构成，每个语句以 ; 结束。 {} 只能成对出现。 源文件的基本组成部分是类(class)，如HelloWorld类 一个源文件中最多只能有一个public类，其它类的个数不限。 如果源文件中包含一个public类，则文件名必须按照该类名命名。 JAVA应用程序的执行入口是main()方法，它有固定的书写格式，即：public static void main(String[] args) {} ，不得乱改。 也可以将main()方法写在非public类中，然后指定运行非public类，这样入口方法就是非public的main方法。一个class文件中只能有一个mian()方法，否则在编译运行的时候会出错。 如果一个java文件中有多个类,除去内部类,剩下的每个普通类都会生成一个class文件。 12345678910111213141516171819202122232425262728//这是java的快速入门，演示java的开发步骤//对代码的相关说明//1. public class HelloWorld是一个java 类，这也是我们创建时点类的原因，是一个public公有类//2. HelloWorld&#123;&#125; 表示一个类的开始和结束。//3. public static void main(String[] args) 表示一个主方法，即我们程序的入口。//4. main()&#123;&#125; 表示方法的开始和结束。//5. System.out.println(&quot;Hello World !&quot;); 表示输出&quot;Hello World !&quot;到屏幕。//6. ; 表示语句的结束。public class HelloWorld &#123; // 编写一个main方法 public static void main(String[] args) &#123; System.out.println(&quot;Hello World !!&quot;); &#125;&#125;// Dog也是一个类，//编译后，每一个类，都对应一个.class文件class Dog&#123; //也可以将main()方法写在非public类中，然后指定运行非public类，这样入口方法就是非public的main方法 public static void main(String[] args) &#123; System.out.println(&quot;Hello Dog !!&quot;); &#125;&#125;class Cat &#123; public static void main(String[] args) &#123; System.out.println(&quot;Hello Cat !!&quot;); &#125;&#125; JAVA常见错误 常见的语法错误是最容易修改的，因为编译器一般会报错并给出原因，虽然有时候原因会很笼统。业务错误和环境错误更难改，业务错误指语法没有错误，编译不会报错，但是代码逻辑写错了，达不到业主需求。环境错误指，我在本地跑没有任何问题，在另一台机器上run就报错。 comment 单行注释：//注释文字 多行注释：/* 注释文字 */，注意，多行注释不允许嵌套使用，即 / * 注释文字 * /里面不允许再有/ * 文档注释：注释内容可以被JDK提供的工具 javadoc 所解析，生成一套以网页文件形式体现的该程序的说明文档，一般写在类。文档注释用的还是蛮多的。文档注释只放在类、接口、成员变量、方法之前，因为 Javadoc 只处理这些地方的文档注释，而忽略其它地方的文档注释。 Javadoc 是 Sun 公司提供的一种工具，它可以从程序源代码中抽取类、方法、成员等注释，然后形成一个和源代码配套的 API 帮助文档。也就是说，只要在编写程序时以一套特定的标签注释，在程序编写完成后，通过 Javadoc 就形成了程序的 API 帮助文档。API 帮助文档相当于产品说明书，而说明书只需要介绍那些供用户使用的部分，所以 Javadoc 默认只提取 public、protected 修饰的部分。如果要提取 private 修饰的部分，需要使用 -private。 java代码规范 截止目前，我们所学甚少，所以java代码规范先讲8条，后面会增加。 类、方法的注释，要以 javadoc 的方式来写，因为 Javadoc 只处理这些地方的文档注释，而忽略其它地方的文档注释。JAVA的设计者就是经常用文档注释；javadoc往往给用户看的。 单行注释，、多行注释，往往是给代码的维护者看的，着重告诉读者为什么要这么写。 使用TAB键，实现代码的缩进和自动补全，使用shift+tab，可以取消一个缩进； 运算符两边习惯性加一个空格(Spacebar)，JAVA设计者就是这么做的。如 int a = 1 + 2; 源文件使用UTF-8编码； 一行的宽度不超过80个字符，太宽了读起来不方便； 代码编写推荐行尾风格，但是次行风格也是正确的； 行尾风格： if (a &gt; b){ a=; } 次行风格： if (a &gt; b) { a=; } Day 2 DOS命令是什么 DOS : Disk Operating System 磁盘操作系统 我们在控制台输入DOS指令时，控制台会把指令发送给DOS系统，DOS系统会对windows文件系统进行相应的操作。 Linux下用DOS命令比较多。 相对路径和绝对路径 文件夹在编程里面称为目录。 比如，D盘下面有abc1文件夹和abc2文件夹，abc1文件夹下面有一个test1文件夹，abc2文件夹下面有一个test2文件夹. 相对路径：从当前目录(当前文件夹)开始定位，形成的一个路径。 绝对路径：从顶级目录(例子中是D盘)，开始定位，形成的一个路径。 如果当前目录在test1，我们想访问test2， 相对路径是 …\\abc2\\test2 绝对路径是 D:\\abc2\\test2 …\\是返回上一级目录。 JAVA中+号的使用 当+号左右两边都是数值型时，则做数学上的加法运算。 当+号左右两边有任何一方为字符串时，则做拼接运算。 举例： 100+98 输出：198 “100”+98 输出：“10098” 100+3+“hello” 输出：“103hello” “hello”+100+3 输出：“hello1003” JAVA的数据类型 JAVA是强类型语言，分为两种， 基本数据类型： 数值型： 整数类型： byte:1个字节； short:2个字节； int:4个字节； long:8个字节； 浮点类型： float:4个字节； double:8个字节； 字符型：char:2个字节(C语言里char类型占用1个字节)； 布尔类型：boolean:占用1个字节，存放true,false。 引用数据类型(复杂数据类型)： 类(class);(string就是类) 接口(interface); 数组([]); JAVA整型细节 JAVA里面的各种整型的长度是固定的，不受具体OS的影响，以保证java程序的可移植性，这一点与C不同，C语言里int和long的长度取决于编译器和CPU。 java中通常用int声明整型即可，除非超出int范围了。如果我们不能保证一定不会超过int范围，就用long。 java的整型的字面量默认为int型(这一点和C一样)，如果声明long类型，则字面量后面必须加上&quot;l&quot;或&quot;L&quot;，建议大写L结尾。比如long a=2147483648，则默认a是int型，会超出int范围而报错，long a=2147483648L a才是long型。 Day 3 JAVA浮点数细节 与整型类似，java浮点数也是固定长度，和OS无关； JAVA的浮点数的字面量默认是double型，声明float时，字面量必须加“f”或“F”， float a=1.1; 是错的，因为1.1默认是double是8个字节，而float是4个字节； float b=1.1F; 是对的； double c=1.1F; 是对的； 浮点数如果是0.几，允许把个位的0省略。比如double a=0.52，可以写成dpuble a= .52 通常情况下，我们一般使用double型，而且JAVA也是默认double型。 由于计算机的缺陷，导致小数在计算机内部并不能被准确表达，这一点已经在C语言里了解过了，所以不能轻易将浮点数的运算结果和某个小数做相等判断，应该用两值之差的绝对值做精度判断，小于一个很小的数就能得出两个浮点数相等。但是如果是 double a=2.7; double b=2.7; a和b可以直接判断相等，因为这是直接赋的。 JAVA API文档 API:(Application Programming Interface),即应用程序编程接口，是java设计者给我们提供的一些类，还有一些方法。也即java标准类库提供的函数，android开发的api是指android sdk函数库。也可以解释为一些预先定义的接口，目的是提供应用程序与开发人员基于某软件或硬件的以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。还有一个很泛的解释，即可以直接调用的东西都可以称作API。 JAVA API文档：是指把这些API收录在一个字典里，这个字典就叫JAVA API文档。 JAVA语言提供了大量基础类，Oracle也为这些基础类提供了相应的API文档。 想知道怎么使用JAVA API文档，有必要先了解JAVA类的组织形式。 JAVA类的组织形式： JDK 8、11、17 包1 包2 包3 …… 异常 接口1 接口2 接口3 …… 类1 类2 类3 …… 字段(又叫属性又叫成员变量) 构造器(构造方法) 成员方法(方法) 方法一：想查找一个方法，可以先弄清在哪个包下面，再找对应的类，就能找到这个方法。 方法二：直接搜索。 JAVA字符型介绍 字符类型char占2个字节，可以用来表示单个字符。可以存放汉字也可以存放英文。 多个字符我们可以用字符串string。 12345678910111213public class HelloWorld &#123; // 编写一个main方法 public static void main(String[] args) &#123; char c1 = &#x27;a&#x27;; char c2 = &#x27;韩&#x27;; char c3 = &#x27;\\t&#x27;; char c4 = 97; System.out.println(c1); System.out.println(c2); System.out.println(c3); System.out.println(c4); &#125;&#125; 输出： a 韩 a 字符型细节 字符型字面量是用‘’引起的，如果用“”，则代表字符串类型，编译器会报告错误； 逃逸字符看起来是2个字符，其实是1个字符； JAVA用的是Unicode编码规则； char的本质是一个整数型，它可以参与运算，这一点和C是一样的，它在计算机内存里面就是个数字，取决于我们输出时用整数型格式还是字符型格式。但是JAVA里char占2个字节，C里面占1个字节。 1234567891011121314151617181920212223public class HelloWorld &#123; // 编写一个main方法 public static void main(String[] args) &#123; /* 和C语言的char本质是一样的，输出什么取决于我们怎么选择什么格式，但在计算机里面始终是个整数， 和C不同的是，C的char类型窄字符采用ASCII码，JAVA采用Unicode；C的char占1个字节，java的char占2个字节*/ char c1 = 97; char c2 = &#x27;a&#x27;; char c3 = &#x27;韩&#x27;; char c4 = 38889; System.out.println(c1); System.out.println((int)c2); System.out.println((double)c2); System.out.println((int)c3); System.out.println(c3); System.out.println(c4); System.out.println(&#x27;a&#x27; + 10); char c5 = &#x27;b&#x27; + 1; System.out.println(c5); System.out.println((int)c5); int c = &#x27;a&#x27;; System.out.println(c); &#125;&#125; 输出： a 97 97.0 38889 韩 韩 107 c 99 97 boolean 在JAVA里面，不允许用0或者非0的整数代替false或true，这一点与C语言不同。在JAVA里，bool类型只能是true 或者 false，不能是其它值。 boolean isPass = true; √ if (isPass = ture){} boolean isPass = 1; × if (isPass = ture){} Day 4 JAVA 自动类型转换 当JAVA程序在进行赋值或者运算时，精度小的类型自动转换为精度大的数据类型。 数据类型按精度从小到大按下面2条路线可以实现自动转换： char——&gt;int——&gt;long——&gt;float——&gt;double byte——&gt;short——&gt;int——&gt;long——&gt;float——&gt;double byte 和 short 不会和 char 类型之间自动转换。 byte b1 = 10; char c1 = b1; × 虽然char容量比byte大，但是也不能这样赋值，原因就是byte类型不能自动转成char类型。编译器就是这么规定的，可以把它当成一个规则来理解。 short b2 = 10; char c1 = b2; × 原因同上 byte char short 三个类型的数，不管是同类型之间的运算，还是不同类型混合运算，在运算时首先转为int型才会运算。 byte b2 = 1; short s1 = 1; short s2 = b1 + s1; √ int s2 = b1 + s1; × byte b3 = 1; byte b4 = 1; byte b5 = b3 + b4; × 因为已经转为int了 int s3 = b3 + s4; √ int a = ‘a’; 对的，而且输出a是97，而且这个97在计算机内部占4个字节，说明char已经自动转换为int了，等价于：int a = 97; double b = 80; 对的，而且输出80.0，说明已经自动转换了. 有多种类型数据混合运算时，系统首先将所有数据转换成容量最大的那种数据类型，然后再1进行计算。 把容量大的赋值给容量小的数据类型，编译器会报错。 byte b1 = 10; 这个语句是对的，之前虽然说过java的整型的字面量默认为int型，我们猜测int赋给byte会报错，然而编译器并未报错，原因是，编译器会先检查该字面量10是否在byte范围内，如果在就可以；如果不行，再进行类型检查。这一点和C一样，比如C里面将一个double赋给float，先将双精度转为单精度，即只取6-7位有效数字，存储到float型变量的4个字节中，当double的数值大小不超出float的数值范围时，也不会报错，只是IDE会给警告。 int n1 = 1; byte b2 = n1; 这样编译就过不了，因为1在内存中已经是4个字节存放了，再赋给一个字节的b2就小了，所以如果是变量赋值，则不再检查是否在数据类型范围内，而是直接做类型检查。 但是可以强制类型转换： byte b2 = (byte)n1; √ JAVA/C++ 在类型转换上和C不同，虽然三种语言都是强类型语言，但JAVA/C类型检查要比C严格，举例，C语言中，int a = 1.1; 不会报错，而且会自动向下取整，最后a=1，我们还利用C语言的这个弱点实现了一些编程小套路，但是在JAVA/C中，这种把double赋给int是绝对不行的；再比如，调用函数时，给的参数类型和函数定义的参数类型不匹配，则C语言编译器会偷偷进行类型转换再传递给函数，但这可能不是你所期望的，所以这是C语言传统上最大的漏洞，JAVA/C++则会报错。 boolean不参与类型的自动转换。 boolean pass = true; int num = pass; 会报错 JAVA 强制类型转换 强制类型转换是自动类型转换的逆过程，将容量大的数据类型转为容量小的数据类型，但是一般会造成精度降低或者溢出，所以一般我们都是有意为之才这么做。 1234567public class HelloWorld &#123; // 编写一个main方法 public static void main(String[] args) &#123; int n1 = (int)1.9; //强制类型转换造成精度降低 System.out.println(&quot;n1=&quot; + n1); &#125;&#125; 输出：n1=1 ，造成精度降低 int n2 = 2000; byte b1 = (byte)n2; System.out.println(“b1=” + b1); 输出 b1 = -48 ,造成数据溢出。 强制转换只针对最近的操作数有效，往往会使用小括号提升优先级， int x = (int)10 * 3.5 + 6; 编译会报错，因为这里只会把10转换成int，3.5还是double，所以最后结果是dounle， int x = (int)(10 * 3.5 + 6); 这么写是对的 String和基本数据类型之间的转换 string是引用数据类型，是一种类，但我们优势需要将基本数据类型和string类型相互转换。 基本数据类型转string： 语法：将基本数据类型的值+&quot;&quot;即可 1234567891011121314public class HelloWorld &#123; // 编写一个main方法 public static void main(String[] args) &#123; int n1 = 100; float n2 = 100F; double n3 = 100; boolean n4 = true; String s1 = n1 + &quot;&quot;; //当+号左右两边有任何一方为字符串时，则做拼接运算。 String s2 = n2 + &quot;&quot;; String s3 = n3 + &quot;&quot;; String s4 = n4 + &quot;&quot;; System.out.println(s1 + &quot; &quot; + s2 + &quot; &quot; + s3 + &quot; &quot; + s4); &#125;&#125; 输出：100 100.0 100.0 true String转基本数据类型 在java里每一个基本数据类型都对应一个包装类，包装类提供一个方法，叫parseXX，XX是相应的数据类型，用这个方法就能转换成对应类型。 String转char类型只能取出String的一个字符，因为char只能存一个字符 1234567891011121314151617public class HelloWorld &#123; // 编写一个main方法 public static void main(String[] args) &#123; String s5 = &quot;123&quot;; int a = Integer.parseInt(s5); double b = Double.parseDouble(s5); float c = Float.parseFloat(s5); boolean d = Boolean.parseBoolean(&quot;true&quot;); System.out.println(a); System.out.println(b); System.out.println(c); System.out.println(d); System.out.println(s5.charAt(0)); System.out.println(s5.charAt(1)); System.out.println(s5.charAt(2)); &#125;&#125; 输出： 123 123.0 123.0 true 1 2 3 int这个基本数据类型对应的包装类就是Integer,这个包装类提供一个parseInt方法可以把String转换成int型。 在将String类型转成基本数据类型时，要确保String类型能够转成有效的数据，比如可以把“123”转成一个整数，但是不能把“hello”转成一个整数，否则虽然编译能过，但是执行时就会抛出异常，程序就会终止。反之，基本数据类型转字符串不存在这个问题。 md 文件写成 { {} }即可，否则hexo g 会报错 jdk8 怎么着都得装上，因为一些软件需要jdk8的环境，只装jd17满足不了","categories":[],"tags":[]},{"title":"走马观花《Code》第13章-如何实现减法","slug":"Code-chapter13","date":"2022-08-07T08:23:22.000Z","updated":"2022-08-10T06:45:52.483Z","comments":true,"path":"2022/08/07/Code-chapter13/","link":"","permalink":"http://example.com/2022/08/07/Code-chapter13/","excerpt":"","text":"继电器可以连接起来构成二进制加法器，那么减法器怎么实现？其实加法和减法在某些方面是相互补充的，但两者计算机制不同，加法用到进位这种机制，从最右边一列向左进位；减法不用进位而是借位。 比如,253-176这道题，3-6不够减，向十位借10，再减6得4，4再加个位剩下得3得7，好了，到十位了，十位本身不够用，还被个位借走1位，得，只能向百位借，10减7加4得7，百位被借走只剩1，1-1=0，故差为77。 如何用逻辑门实现这种逻辑呢？ 答：我们不会用这种借位逻辑，取而代之得是一个小技巧。还是那道题，要想不借位，首先将减数176用999减去，即999-176=823，一位都不用借，注意，这里因为操作数是3位，所以用999，操作数是4位我们则用9999，以此类推。把一个数从一串9999……中减去得到的结果我们称之为9的补码。176的9的补码就是823，反之823的9的补码是176，这样做的好处就是，无论减数是几，计算其9的补码时永远不会借位。 在计算出减数的9的补码后，将补码加到原来的被减数上，即823+253=1076，最后再加1并减去1000得77，看，是不是没用到借位！ 原理很简单，253-176=153-176+1000-1000=253-176+999+1-1000=(999-176)+253+1-1000，这样用2个减法和2个加法代替原来的1个减法，其中2个减法，计算减数9的补码和减1000，永远不需要借位，不信你随便找个比1000大的数减1000试试需不需要借位。这样可以省去借位。 那么问题来了，被减数比减数小怎么办？我们如果还用上面的方法，最后得到923-1000，遇到这种情况，小学的我们此时都是减数和被减数换个位子，得到的正数差取反即可，所以我们聪明地让1000-923企图取反，但是傻眼了，这样做还是不能绕过借位，我们用上面的方法，又是用999减，又是+1又是减1000的，不就是想不借位吗，本来被减数&gt;减数时，这种方法是可以绕过借位的，但被减数&lt;减数该方法就不灵了，即使我们耍小聪明让被减数和减数互换位置的情况下。 这种情况要绕过借位与前文略有不同，仍然是先求出减数253的9的补码为746，再746+176=922，好，从下面开始和前文不同，既然前面加了999，我们再减999，只不过反过来，999-922，这样不用借位，999-922=77，此时我们再取反得-77，整个过程就是，176-253=176-253+999-999=999-253+176-999=922-999(互换位置再取反)=-77，看，我们又绕过了借位。 这种绕借位的方法可以用在二进制数减法，而且比十进制数简单。 253二进制数是11111101，176二进制数是10110000，我们还用上面教的方法，11111101-10110000=(11111101-10110000)+(100000000-100000000)=11111111-10110000+11111101+00000001-100000000=101001101-100000000=01001101，01001101转十进制便是77，整个过程中没有借位。 得到一个十进制数的9的补码，我们是用一串9去减该数，对于一个二进制数，我们是用一串1去减，称为该数的1的补码，但请注意，求1的不码不仅不需要借位，减法也不用做，因为在求1的补码过程中，无非是将那个二进制数的0变为1，1变为0，所以二进制数的1的补码，也叫它的反码，计算机中有专门的反向器来做这个事。 相同地，再解决 10110000-11111101 的问题，与十进制情况类似，先求11111101的1的补码(反码)即00000010，再加被减数得10110010，再减11111111，如果我们加00000001再减100000000，则会用到借位。同样，先让11111111和10110000互换位置，即11111111-10110010=01001101，再取反为-01001101，完美避过借位。整个过程是，10110000-11111101+11111111-11111111=(11111111-11111101)+10110000-11111111。 现在我们弄清了怎么绕开借位实现减法，那么计算机内部怎么表示负数呢？ 从小就学，负数前面添一个负号，这个数就是负数，因此很容易想到，0和1可以分别代表正负号，比如8位二进制数，最高位定为符号位，可规定0正1负，余下数字定为数字位，这样也能表达有符号数。但是有个更好的方法，不仅能表示负数，还很适合计算正负数之间的加法，但该方法有个不足之处即，需要提前决定数字需要多少位。 我们小学学的正负号表示正负数的方法，可以表示所有的正负数，我们把0想象成向一个方向延伸的无穷的正数流和向相反方向延伸的负数流的中点，如果我们不需要无限的正数和负数，可以清楚的确定我们能用到的数的范围，那么我们或许不需要规定正负号来表达正负数。 比如银行给我们一个账号，账户存款上限是$499，可以透支$500，意味着账户上的数字在[-500.499]区间内，-500(-1)和0499共1000个整数，我们只需3位十进制000999就可以表达完全，且不用多余的位来表达正负号，我们用000499表示0499，然后500999不会在账户中出现闲着也是闲着，恰好拿来表示-500(-1)，500表示-500，501表示-499，502表示-498…………998表示-2、，999表示-1。换句话说，以5、6、7、8、9开头的三位数实际上都表示负数。注意这样形成了一个环形排序，想象两个圆圈，一个在内环，一个在外环，内环是0999顺时针排成一个环，外环先是0499顺时针排成一个半圆环，内外环的0499依次对应，从内环的500开始，外环开始变成负数，内环500对应外环-500，内环501对应外环-499，内环502对应外环-498，还是顺时针依次对应，直到内环998对应外环-2，内环999对应外环-1，最后内环回到0，外环也回到0。从外环看，最小的负数-500看上去好似外环最大正数499的延续；从内环看，数字999代表比0小的第一个负数。 说到这，我们绕开了借位做减法，也摒弃了用了多年的正负号来表示有符号数，还辛辛苦苦弄了两个圈表示一定范围的正负数，有什么用呢？ 如果给999加1，通常得到1000，但由于我们已经限制了3位十进制数，所以实际上得到000。这种处理称为10的补码，要把三位负数转换成10的补码，需要用999减它的绝对值再加1，换句话说就是求9的补码再加1.比如-255，其10的补码就是999-255+1=745，745+255=1000，某三位负数10的补码就是1000减去它的绝对值得到的数。 了解过负数的的补码，再回头看那两个圆环，有没有发现什么？对于我们苦心孤诣构造的两个圆环，前半部分都是非负数，内外环的数字都一样；对于后半圈，内环是外环数字的10的补码。在外圈我们想求-3+1=-2，我们用内圈-3的10的补码997，去加内圈正数区的1，得到结果998，再去对应外圈得-2，是不是很神奇！这也是我们规定500对应-500，501对应-499……的用意。 假设我现在账户上有 $143，并花出去了 $78，还剩多少？即求143-78=143+(-78)，-78的10的补码是922，故我们可以这样求143-78，143+922=1065，忽略上溢，即结果是065。如果我们提前知道-78的10的补码是922，是不是就没有用到减法！ 之前我们求十进制数的9的补码是用一串9……去减那个数，求十进制数的10的补码是用其9的补码加1得到，那么在二进制中也可以这么干。求二进制数1的补码是用一串1……去减那个数，得到该数的1的补码也称该数的反码，计算机内部有专门的反相器来求二进制数的反码。求该数的2的补码，就用该数的反码(该数1的补码)加1就可得到。 比如求十进制负数-237的10的补码，可以先求其9的补码999-237=762，再加1=763，即求得，也可以直接用1000-237=763，这样也能得到-273的10的补码，但是在求1000-237时需要用到借位。同理，我们求3的二进制数的1的补码(00000011的反码)，用11111111减它得到11111100，再加1得到11111101，11111101+00000011=100000000，由于只于一个字节所以把第9位1扔了，因此求00000011的2的补码也可以直接用100000000-00000011，但这样求会用到借位而且会用到减法。而先求00000011的反码，计算机做这一步有反向器所以不用11111111去做减法，再加1得2得补码，全程不用做减法。-3的二进制数在计算机内部只能用11111101来表示，其它二进制数没法表示-3，所谓的最高位是0正1负，不是把000000011最高位变成1，(注意：10000011在计算机内部表示-125而不是-3)，而是指00000011的2的补码算出来，为11111101，其最高位天然就是1。补码不能用常规的二进制转十进制方法计算它对应的十进制数，而是人为规定这个补码对应哪个十进制数。 只需求正数对应的二进制数的2的补码，就可得到该正数的相反数在计算机内部对应的二进制数；只需求负数对应的二进制数的2的补码，就可得到该负数的相反数在计算机内部对应的二进制数。比如我们想知道-3在计算机内部用什么二进制数表示，先用3转换为二进制数00000011，再求00000011的2的补码为11111101，这个11111101就是-3在计算机内部对应的二进制数。同理，求11111101的2的补码，先对11111101求反码得00000010，再加1得到00000011，就是3在计算机内部对应的二进制数。 好了，对于二进制，我们还能比着十进制的葫芦画2个圈。 我们在十进制中，用0-999这1000个数，成功对应了-500-499，并通过巧妙的对应方法和溢出，使得做减法时只需要加法就能得到。同理，我们用00000000-11111111这256个数对应-128-127，最内圈00000000-11111111顺时针排成最内圈，00000000-01111111在内环的前半圈，分别对应外圈的0-127，内圈后半圈是10000000-11111111，分别对应外环的(-128)-(-1)，其中10000000对应-128，10000001对应-127，10000010对应-126……11111110对应-2，11111111对应-1，仔细观察，我们发现在这种对应规则下，正数对应地二进制数最高位都是0，负数对应二进制数最高位都是1，但计算机其实不会特意注意这个最高位，它只会把它当作普通的二进制数。其实内环后半圈我们如果用正常的二进制转十进制的方法算，比如10000010，算出来的结果是130，表示无符号数时这么对应是对的，但我们这不是想让减法变成加法算嘛，所以我们用这种人为对应的方法强行让10000010对应-126，看看有什么好处。我们计算2-126，在计算机内部就是2+(-126)，2按照那两个圈的对应规则对应二进制数00000010，-126对应10000010，2+(-126)在计算机内部就是做00000010+10000010=10000100，然后根据对应规则，10000100对应-124，在计算机内部成功地用加法实现了减法 需要特别注意的是，计算机在做负数有关计算时，并不会跑过去特地判断最高位是0还是1，对于计算机来说这就是个2个普通的二进制数，计算机只需把他们加起来，多的位溢出即完成任务，只是，这普通的加法在我们对二进制人为设置的对应关系下，并结合溢出的特性，变成了减法。 特别需要注意上溢和下溢，即结果在[-128，127]区间之外的情况，例如，125+125，计算机内部就是01111101+01111101=11111010，根据我们规定的对应关系，11111010代表-6；再看10000011+10000011，即-125-125，得到100000110，由于限制了8位，所以最高位的1被计算机扔掉为00000110，该数表示6。一般而言，若两个操作数同号，而结果的符号与2个操作数符号不同，则这样的加法八成产生了溢出，我们一般认为这样的加法是无效的。 到此为止，二进制有两种使用方法，二进制数可以用来表示有符号数和无符号数，同是8位二进制数，可以表示无符号数的范围是0-255，可以表示有符号数的范围是(-128)-127，但这些二进制数本身不会告诉你它此刻表示的是有符号数还是无符号数。假设有人问你，10110110对应的十进制数是几，你一定不要先急着回答，问清楚是表示有符号数还是无符号数，它可能是182 or -74，-74怎么得到的？，求101101102的的补码，表示正数74，取相反数-74即得到。在C语言中，针对计算机内存里同一个二进制数，我们怎么控制让它输出是有符号数还是无符号数呢，用%d和%u控制。 看，这就是二进制数的麻烦之处，它仅仅是纯粹的0和1，但没有告诉你什么含义。 最后，我们回头看，最开始我们说减法要绕开借位做什么，用补码来做加法实现减法的效果和绕开借位有什么关系？因为我们想借绕开借位实现减法引入补码和反码。对于十进制来说，使用补码可以绕开借位实现减法，对于二进制来说，使用反码和补码不仅可以绕开二进制，还可以做加法实现减法的效果。","categories":[],"tags":[]},{"title":"专升本H哥我的好哥哥","slug":"H-brother","date":"2022-08-02T01:49:55.000Z","updated":"2022-08-27T06:30:53.189Z","comments":true,"path":"2022/08/02/H-brother/","link":"","permalink":"http://example.com/2022/08/02/H-brother/","excerpt":"","text":"计算机的诞生与发展 什么是计算机 电脑（微型机，组装机，大型机，超大型机…），手机，智能手表，ATM，安全系统… 图灵测试：有一台机器和一个人，提问者分别问机器和人相同的问题，提问者如果分不出来哪个是人哪个是机器，则判断那个机器是人工智能。图灵也被称为计算机科学之父，人工智能之父，冯诺伊曼是计算机之父。 机械计算器——&gt;分析机——&gt;布尔规定运算规则，建立逻辑代数——&gt;图灵理论论证了通用计算机可能性(图灵机)——&gt;冯诺依曼提出“存储程序控制原理”，并把二进制引入计算机——&gt;香农，信息论，信息是对数据的解释而数据是信息的载体，比如520就是数据，我爱你是信息。 什么是存储程序控制原理，比如我想制作王者这款游戏，想要在手机上运行，必须先下载到手机外存上，当要运行时这个外存的数据传输到内存里，然后CPU与内存自动交换数据，不是人工，CPU只跟内存交换数据。 1946年，第一台通用计算机ENIAC在美宾夕法尼亚大学研制成功，最初为分析弹道轨迹研制， 但ENIAC并未采用存储程序控制原理，因为冯诺依曼提出来的时候ENIAC已经快成功了， 采用大量电子管和继电器 采用十进制，可见十进制在计算机可以实现，十六进制也能实现，只不过最后发现二进制优势巨大。 无存储器 主要用于军事领域 通常按组成计算机的电子逻辑器件（元器件、元部件），将计算机划分4个阶段： 阶段 基本逻辑器件 存储 特点 第1代 电子管 存储器采用水银延迟线，外存采用纸带 采用机器语言和汇编语言(低级语言) 第2代 晶体管 存储器采用磁芯和磁鼓，外存采用磁盘 出现了高级语言，提出OS的概念 第3代 中、小规模集成电路 第一次采用半导体 出现OS 第4代 大、超大规模集成电路 半导体 出现微型计算机(微机) 微处理器是指微机CPU。服务器，大型计算机也有CPU但那不是微处理器。4位是指一次处理4位数据。 intel 486 中的486是指型号，全称是80486(奔腾)，现在用的是酷睿 微机的性能主要取决于它的核心器件：微处理器(CPU)的性能。 计算机的分类 按结构原理划分 数字计算机：电脉冲的位数和电位的阶变(离散)，这种最常见。 模拟计算机：电压的连续变化(连续) 按照用途划分 通用计算机：可以解决各类问题，最常见。 专用计算机：专为特定目的制造出来，比如ATM机，售票机。 按照规模划分 巨型机，比如太湖之光。 大中型机，比如服务器 小型机 微型计算机： 单片机：处理器，存储器输入输出集成在一个芯片上。比如门禁系统，无人机系统。 单板机：处理器，存储器，输入输出集成在一个电路板上。 个人计算机：PC机 按照字长划分 CPU一次处理多少位数据即字长，字长越大CPU处理数据越快，目前最常见是64位机。 按照工作模式划分 工作站：高档PC 服务器：提供服务，提供资源。我们平时自用的手机电脑叫做客户机，下载的东西叫客户端，我们的客户机访问淘宝请求资源，淘宝的服务器提供资源。 计算机信息的表示及存储 数据信息分为数值型(01001)和非数值型(字母，汉字…)，计算机之所以能识别不同的信息是因为有不同的编码规则。 数制 数值也叫计数制，是指用一组固定符号和统一规则来计数的方法，比如十进制，固定符号就是0-9，统一规则就是比如满十进一，8-2=6这种，十进制全称叫 十进位计数制，生活中最常用。还有16进制一般用于内存编制=址和编号，8进制一般用于权限。 数码 数值中表示基本数值大小的不同数字符号，比如二进制数码就是0和1，八进制数码就是0，1，2，3，4，5，6，7，十六进制是0，1，2，3，4，5，6，7，9，A, B, C, D, E, F，为什么从10开始就是大写英文字母了呢？因为如果还用10，11，12，13，14，15，那比如115，就会产生歧义，所以用A表示10这个数值，以此类推。R进制数码就是0-R-1。 基数 基数就是数码的个数，比如十进制的基数是10，二进制是2. 位权 数制中每个位置的价值，比如十进制中的个位，十位，百位。十进制位权是10n，二进制位权是2n，十六进制位权是16^n。 标识 数制的标识又称后缀，为了区分不同进制，二进制标识B，Q是八进制，十进制一般省略，十六进制是H， 规则 进位规则：9+1为什么等于10，因为十进制规定的规则，二进制下，1+1=10；八进制下，7+1=10，6+3=11；十六进制下，8+2=A(此时还没进位)，8+8=10，总之多少进制就满多少进一。 借位规则：十进制里面10-2为什么等于8，因为0-2不够，向十位借1位当作10，10再减2得8；二进制下面，10-1，0不够，向高位借一位当作2，2-1=1；八进制下，10-2，不够向高位借，当作8-2得6；十六进制下，11-2，借一位得16-2=14，14再加1等于F(15)，总之多少进制下，向高位借1位就当作多少。 Practice 102B是错的，二进制数码没有2； 7Q是对的，Q是八进制得标识，数码有7没有8； ABCDF H是对的；BTW，ABCDF H不能看作 1011121315，就像比如二进制1011100，没法直接看成十进制，想要转换为十进制只能计算出来。 6+3=11，则一定是八进制，因为让11-1=6+3-1，即10=6+2，逢8进一。 进制转换 十进制——&gt;R进制 整数：除以R反向取余 小数：乘R正向取整(取整后变为0) 比如： 20.625D=10100.101B 66.5D=102.4Q 30.5D=1E.8 (十六进制里面有14这个数值，但是是用E来表示)。 29.125D=11101.001B R进制——&gt;十进制 乘权求和法：每一位得值乘以它对应的位权。 需注意两点： 从个位开始标，小数和整数分开 位权是从0指数开始 10110.011B=22.375D 16.6Q=14.75D 8A.4H=138.25 1010.101B=10.625D 二进制——&gt;八进制/十六进制 分组转换法： 二进制——&gt;八进制：3位转成1位 二进制——&gt;十六进制：4位转成1位 在这个转换过程中我们熟悉的十进制成为媒介。 为什么能这么转换呢？ 二进制1位能表示的范围是0-1，2位能表示的范围是0-3，3位能表示的范围是0-7，而八进制1位刚好是0-7的范围，所以3位二进制转换1位八进制；4位二进制能表示的范围是0-15，刚好十六进制1位能表示的数值范围也是0-15； 注意两点： 以小数点为界，整数和小数分开 整数位数不够在前面添0，小数位数不够在后面添0。 10101.1B=25.4Q 110101.1101B=35.DH 110001.11B=61.6Q 八进制/十六进制——&gt;二进制 换组转换法： 八进制——&gt;二进制：1位转成3位 十六进制——&gt;二进制：1位转成4位 在这个转换过程中我们熟悉的十进制成为媒介。 16.32Q=1110.01101B F.3DH=1111.00111101B ABC.DH=101010111100.1101B 八进制&lt;——&gt;十六进制 以二进制为媒介 56.3Q=101110.011B=2E.6H 3D.2H=111101.001B=75.1Q 小数点移位 对于R进制，小数点左移n位，数变为原来的R^(-n)倍； 对于R进制，小数点右移n位，数变为原来的R^(n)倍； 对于二进制数110.11011B，小数点左移2位，则变为原来的2^(-2)=0.25倍；对于一个八进制数，小数点右移2位，则变为原来的64倍。 二进制的算术&amp;逻辑运算 算术运算 加：0+0=0；1+0=1；1+1=10 减：0-0=0；1-0=1；1-1=0；10-1=1； 乘：0×0=0；0×1=0；1×1=1； 除：0/1=0；1/1=1； 101+110=1011B 11001-101=10100B 11001×101=1111101B 11001/101=101B(与十进制除法规则相同) 逻辑运算 与(逻辑乘)：0&amp;&amp;1=0；0&amp;&amp;0=0；1&amp;&amp;1=1； 或(逻辑加)：0||0=0；0||1=1；1||1=1； 非：!1=0；!0=1； 异或(相同为0，不同为1)：0XOR0=0；1XOR1=0；1XOR0=1；0XOR1=1； 1010&amp;&amp;1011=1010B 1010||1101=1111B !1010=0101 1010XOR1101=0111B 千万注意逻辑运算和算术运算不同，逻辑运算前面的0不可省。 计算机中信息的表示 信息的单位 位(bit):计算机中最小的数据单位是二进制的一个数位，简称位(bit)，一般用b表示。 字节(Byte):字节是计算机中存储信息的基本单位，计算机内部是以字节为单位进行处理的，一般用B表示。1B=8b，1个字节=8位二进制。 字:CPU一次性传输，运算或处理的二进制数据。 字长:CPU一次性传输，运算或处理的二进制数据的位数。 比如CPU一次处理10101010B这个二进制数，这个就是字，一共8位，其字长就是8位。注意这是CPU一次(同时)能处理这么多位，但不是指CPU最大能够处理这么多。 单位换算 我们规定8位二进制称为1个字节，1B=8b，以此类推，2B=16b，32b=4B。 2^10=1024 1KB = 2^10 B =1024 B 1MB = 2^10 KB =1024 KB =2^20 B 1GB = 2^10 MB =1024 MB =2^30 B 1TB = 2^10 GB =1024 GB =2^40 B 1PB = 2^10 TB =1024 TB =2^50 B 1EB = 2^10 PB =1024 PB =2^60 B notes:传统数据量一般低于 PB，而大数据处理的数据往往有PB 甚至EB。 2MB = 2×2^20 B = 2^21 B 2^32 B = 232/230 GB = 4 GB 常见的，比如我们常说手机内存是4GB，8GB…… 数值表示 无符号数：0，1，2，3，4…… 有符号数：-2，-1，0，1，2…… 详见《Code》第13章。 n位二进制表达的数字范围 用n位二进制表示无符号数(十进制)的范围是 0-(2n)-1**，共能表示**2n个数。 用n位二进制表示有符号数(十进制)的范围：由于最高位被当作符号位，故只有n-1位可以来表达数字，符号位有两种状态，而剩下的(n-1)位用来表达无符号数可以表达2(n-1)个，可以表达的无符号数范围是0-2(n-1)-1。 故按理说，所能表达正数范围是12^(n-1)-1，所能表达负数范围是-2^(n-1)-1(-1)，符号位和数值位均为0则表达十进制数0，故按理来说，共能表达的有符号数范围是-2(n-1)-1~0~2(n-1)-1，但是是不是有点不对劲？若符号位和数值位均为0则表达十进制数0，那么还有一共=个原码没用到，就是符号位为1数值位全为0的数，它表示什么呢？难道也表达0？那不是重复表达吗？其实计算机将这个数定义为-2^(n-1)，这样n位二进制能表示的有符号数(十进制)的范围就是 -2(n-1)~0~2(n-1)-1，至于计算机为什么能怎么定义，此处先按下不表。(详解请看《Code》13章)，n位二进制能表示有符号数(十进制)的个数是2×2(n-1)=2n，8位二进制可表达的有符号数范围就是经典的-128~127，能表达256个数。 状态数：即数的个数，举例,16位二进制能表达的状态数是216，也就是能表达216个数字。这一点对于表达有符号数还是无符号数都是一样的。 浮点数 根据小数的位置是否固定，将数值分为定点数和浮点数。 浮点数：N = M × R^(e) 其中，M称为数N的尾数，决定数的精度。E是数N的阶码，决定数的范围。 比如12.5×10(3)，和12.51×10(4)，尾数分别是12.5和12.51，显然12.51精度更高；阶码分别是3和4，显然4的范围更大。 信息编码 上面讲的都是数值编码，这里讲非数值在计算机内部怎么表达。非数值比如，字母，汉字，图片，音频…… BCD码 BCD码：Binary-Coded-Decimal 这是一种二进制的数字编码形式，。BCD码这种编码形式利用了四个位元来储存一个十进制的数码，使二进制和十进制之间的转换得以快捷的进行。这种编码技巧最常用于会计系统的设计里，因为会计制度经常需要对很长的数字串作准确的计算。相对于一般的浮点式记数法，采用BCD码，既可保存数值的精确度，又可免去使计算机作浮点运算时所耗费的时间。 由于十进制数码有10个，09，但三位二进制只能表达07，所以至少需要4位二进制码来表示1位十进制数。这种编码方式在中国大陆最常见的是“8421码”。 ASCII码 标准ASCII码：美国信息交换标准代码 标准ASCII码占用1个字节但只用了7位，最高位始终为0。所以十进制数范围是0~127。 其中0~31是控制字符，比如回车，换行，不显示不打印，127是删除，也不显示不打印。从32开始是空格，开始可以显示打印出来，空格是能显示出来的最小的一个ASCII码。 0是48，1是49，A是65，a是97，A和a相差32D。数字&lt;大写字母&lt;小写字母。 扩展ASCII码：由于标准ASCII码没有用到第8位，所以出现了扩展ASCII码，它用到了第8位，标准ASCII码最高位始终为0，扩展ASCII码把第8位变成1，其范围是128~255，其实就是在标准ASCII码后面接了128个数。但是这个编码方式常见于拉丁文，所以我们一般不用。超过128叫高位字节，低于128叫低位字节。 GBK编码 GBK2312-80(GB2312) ASCII码用于西文，由于ASCII码只用1个字节，状态数是256，但汉字个数远远不止256个，所以我们汉字不能用ASCII码，因为不够用。所以出现了GBK2312,GBK2312-80中的80指上世纪80年代产生我们用2个字节表示汉字，两个字节有16位，状态数是2的16次方=65535，可以表达6w多个字符，但此编码标准只收录了6763个常用汉字，导致后来随着中文互联网普及，一些生僻字表达不出来，为了解决这个问题，后面又扩展成GBK。 GBK 1995年，GBK1.0收录了2w多个字符，可以表达我国少数民族字符。 GB18030 2000年GB18030-2000取代GBK，2005年，升级为GB18030-2005。 GBK如何兼容ASCII码 我们平时在计算机上打字，时而英文时而中文，但是我们上面了解到，ASCII码占用1个字节，而GBK占用2个字节，在计算机内部都是连续的010101……，计算机是怎么识别什么时候用两个字节编码，什么时候用1个字节编码呢？有人说，可以用GBK兼容ASCII码，在表示英文字母时可以用两个字节，然后高8位全为0，低8位用ASCII码，这样行是行，但是若全是英文字母的话，用ASCII编码大小如果是2MB，那么用GBK编码就是4MB，很浪费。于是有人就找到了扩展ASCII码一览表，说高位字节都是我们中国人平时用不到的字符，索性我们可以去掉ASCI码的高位字节，将汉字还用2个字节去编码，只不过2个字节每个字节都是高位字节。让电脑以1个字节去识别，出现1个低位字节时，我们用ASCII码编码，当出现2个连续的高位字节时，计算机将连续的2个字节一起识别，然后用GBK编码成汉字。 编码系统的统一(Unicode) 我国有GBK，台湾有BIG 5，日韩也有自己的。但是会产生问题，比如把日本游戏进口中国，但中国电脑上没有日本的编码系统，那么在中国电脑上展示会出现乱码，后来就装语言包，可以使日本游戏显示日文但仍然不显示中文。这时联合国出来搞了一个万国码，就是Unicode，统一天下，Unicode兼容ASCII码，比如’a’的ASCII码是0x61，在Unicode里就是0x0061，都对应97。Unicode现在已经收录了13w+的字符，一个字符占2~4个字节，大部分是占2个字节，支持全球各种语言，并能与各种编码系统相互转换，比如Unicode&lt;——&gt;GBK，Unicode&lt;——&gt;BIG5，为什么不直接用Unicode还要互相转呢，因为Unicode1.01994年才发布，GBK2312八十年代就出来了，当时有很多软件已经基于本国的编码系统开发出来了，不好推到再改；另一个原因就是很多产品只需要在本国用，没有用Unicode的需求。直到现在，全球电脑厂商出厂都支持Unicode，大多数软件也是。 但是Unicode一个字符占2~4个字节，存储和传输时会很大，所以针对传输+存储做了一个新的编码系统，即 UTF(Unicode Transformation Format)，它有3个版本，即UTF-8、UTF-16、UTF-32。其中 UTF-8 优先使用1个字节。无法满足则增加一个字节。最多4个字节，英文占1个字节(兼容ASCII码)，欧陆语系占2个字节，东亚语系占3个字节，其它及特殊字符占4个字节。虽然汉字的大小比Unicode更大了，但是在英文占多数的文件中，比Unicode要小。UTF-16 使用2、4个字节表示，优先2否则4，还是没有解决传输和存储时很大的问题；UTF-32一律用4个字节表示字符，更没人用。 UTF-8是互联网上使用最广泛的一种Unicode的实现方式。现在文字在内存里是Unicode，传输时转成UTF-8，保存在硬盘里也会转成UTF-8.但是需要特别注意，UTF-8不能像Unicode一样和GBK、BIG5这种编码系统互转。 python2开发出来是1990年，那个时候还没有Unicode，python2选的是ASCII码，所有python2不支持中文。","categories":[],"tags":[]},{"title":"翁恺哥哥的C","slug":"WengKai-C","date":"2022-07-24T08:11:23.000Z","updated":"2022-11-12T03:33:40.771Z","comments":true,"path":"2022/07/24/WengKai-C/","link":"","permalink":"http://example.com/2022/07/24/WengKai-C/","excerpt":"","text":"Day 1 计算机如何解决问题 计算机什么也不会，它只会按照指令去做事，我们需要把步骤串起来，所以我们需要使用编程语言去指挥计算机该做什么。 所有计算机去做的东西，我们都叫计算，并不只局限于加减乘除等，包括，画一张图，放一部电影，这些都叫计算。 那计算的步骤呢，就叫算法 algorithm. 算法是程序的灵魂，算法 + 数据结构 = 程序，数据结构即用整型，浮点，字符串，数组，指针还是结构体…… 做一个图书管理系统，下面就是数据的结构设计举例： 123456789101112131415161718192021222324252627282930struct class Book&#123; string 书名 int price; //浮点不精确，不适合算钱 int 页数; int bId; int 出版商ID; int 作者ID; &#125; struct 出版社; struct 作者&#123; int 作者id; 名称 年龄 体重 三围 &#125;; // 本图书管理系统的所有书籍 Book books[1000]; 作者 作者s[100]; 作者1; for(int i= 0; i&lt; 作者.size(); i++))&#123; if(book1.作者id == 作者s[i].id)&#123; 作者1 = 作者s[i]; &#125; &#125; 计算机的思维方式 枚举，二分，… 程序的执行，源代码-&gt;机器语言 解释 有一个程序，能够读懂我写的程序，它会看懂我的程序并读入我的程序并，转身让计算机去做 类似同声传译 编译 有一个程序，它也能读懂我的程序，它能把我的源代码，翻译成机器语言，然后，它会把这个翻译以后的，计算机能懂的机器语言，保存下来，以后，我的程序想执行时，它会直接拿原来翻译好的程序去让计算机执行，这个翻译的过程叫做编译。 类似书面翻译交纸质的。 对于计算机编程语言来说，语言本身是没有编译和解释之分的，任何一种语言既可以解释执行也可以编译执行，这仅仅是传统和习惯问题，只是，这种语言它常用的程序执行方式，比如，也有人去做C语言的解释器。 过去我们常常说，解释语言比较慢，因为需要一条条去执行，但现在计算机的计算速度已经到了一个非常高的程度，和编译型语言的运行效率已经差别不大了。只是传统和喜好的问题。 为什么是C C/C++语言才很多场合时唯一的选择，比如做操作系统，嵌入式系统. 上世纪60-70年代，不同语言的语法差异很大，但现如今，很多语言都可以叫做C—like语言。基本上，他们都和C语言很接近。 做同一件事情： 123456#include &lt;stdio.h&gt;int main()&#123; printf(&quot;Hello World!\\n&quot;); return 0;&#125; 12345class Hello &#123; public static void mian(String[] arg)&#123; System.out.println(&quot;Hello World!&quot;); &#125;&#125; 1print(&quot;Hello World!\\n&quot;) C简单历史 it was the summer of 69 C语言是从B语言发展而来， 但没有A语言，FORTRAN语言是世界上第一个被正式推广使用的高级语言。指针是C语言的灵魂，高级语言中C语言是一种比较底层C99.现在C语言的编译器基本上都支持C99了 以前OS用汇编语言写，汇编是面向硬件的，所以做出来的OS可移植性差，所以贝尔实验室发明了C语言，想用这门高级语言写Unix操作系统，使得Unix的可移植性变强。Mac就是类Unix系统。 编程软件 C语言写，操作系统，嵌入式系统，写驱动程序（比如U盘），游戏引擎。 网站的服务器本身的操作系统是C语言写的，网站的服务器软件是C语言写的，但网站直接提供数据的代码并不是C写的。 因此C是一门工业语言， 开发效率&gt;&gt;学习过程 开发效率&gt;&gt;学习乐趣 编辑器 如VSCode; 编译器 或者，IDE（集成开发环境） Day 2 第一个C程序 12345678#include &lt;stdio.h&gt;int main()&#123; printf(&quot;Hello World!\\n&quot;); return 0;&#125; 详解第一个程序 我们所有的C程序都要有这几行,这是一个框架。 123456#include &lt;stdio.h&gt;int main()&#123; //在这写 return 0;&#125; 对于C语言来说换行不意味着任何事情。 做点计算 计算机刚出现的时候，是使用打字机输入程序的，但打字机上没有乘除的符号所以用*&amp;/代替。 %是俩数做除法，只要余数。 123456#include &lt;stdio.h&gt;int main()&#123; printf(&quot;12+34=%d&quot;, 12+34); //在这写 return 0;&#125; 变量定义 12345678910#include &lt;stdio.h&gt;int main()&#123; int price = 0; printf(&quot;请输入金额(元)&quot;); scanf(&quot;%d&quot;, &amp;price); int change=100-price; printf(&quot;找您%d元\\n&quot;, change); return 0;&#125; 变量的名字叫做price，变量的类型是int，初始值为0. 变量是保存数据的地方。 变量代表一个变化的值。 1int price,amount; 变量的名字是一种标识符，C的关键字/保留字，不能用作标识符，标识符只能由 数字 下划线 字母 组成，数字不能放在开头。 变量赋值与初始化 对于C来说，初始化和赋值的差异不是特别大，但C++的差异大。=表示一个动作故a=b和b=a是两个完全不同的意思，当赋值发生在定义变量时即为初始化，若变量仅仅定义而没有初始化，比如： 1int i; 则在计算机的内存当中，那个变量放在内存的哪个位置，那个位置原来有什么，就是它的值。内存有个特点，即新来旧去，即新的来了，旧的才走。内存上旧的那一块，上面会保留上一个数据，但是会显示free，即可以分配新的数据过去从而覆盖掉旧的，新的来了后会显示busy，表示现在这块内存上正在有数据占用。如果变量没有初始化只是定义，那么这个变量确实会占一块内存并显示free，但是由于我们没有没有给它初值，所以它并不会覆盖掉内存上的旧数据，旧数据还在那，我们打印出来的是旧数据。 传统的ANSI C只允许在代码开头的地方定义变量，C99则不然。 变量VS常量 C99定义常量 1const int AMOUNT = 100; 这里的const是一个修饰符，表示该变量的值一旦被初始化，后面的程序便不能修改之。把某一数字赋予名字，可以增强易读性。 eg,后面再写 AMOUNT=90 便会被编译器发现并报错。 对于一个常量，一般都会把变量名字大写。 对于下面这段代码： 123456789#include &lt;stdio.h&gt;int main()&#123; int a; int b; scanf(&quot;%d %d&quot;, &amp;a,&amp;b); printf(&quot;%d+%d=%d&quot;, a,b,a+b); return 0;&#125; 我们输入1空格2和输入1回车2和输入1回车回车2，结果都是3，但是若输入hello,clion终端便会输出0+0=0，这是因为a和b没有被初始化且没有得到他们想要的值。 浮点数 123456789101112#include &lt;stdio.h&gt;int main()&#123; int foot; int inch; printf(&quot;请分别输入身高的英尺和英寸，&quot; &quot;如输入\\&quot;5 7\\&quot;表示5英尺7英寸：&quot;); scanf(&quot;%d %d&quot;, &amp;foot,&amp;inch); printf(&quot;身高（国际单位）:%f\\n&quot;, (foot+(inch/12))*0.3048); return 0;&#125; 我们首先使用卡西欧计算器计算5英寸7英寸=1.7018米，但是，当我们输入5 7时，程序输出的结果是1.524000，更加奇怪的是，我们输入5 9、5 0、结果均为1.524，但我们如果输入6 7和6 2，则结果均变为1.828。原因是，在C语言中当我们对两个整数进行运算时，它的结果也只能是整数，我们输入5 7 时，其中有7/12这个运算，得到的结果是向下取整后的，即为7/12约等于0，因此inch都不起作用，英尺才起作用。怎么解决呢，方案有俩： 123456#include &lt;stdio.h&gt;int main()&#123; printf(&quot;%f\\n&quot;, 10.0/3); return 0;&#125; 浮点数意思是小数点是浮动的，小数点出现在一个数的第几位，这是可以变的；定点数也有小数点，但它的小数点顾名思义，永远出现在某一位，浮点和定点都是在计算机内部表达有小数点数字的方式，但是我们通常会使用浮点数。运算符两边又有整数又有浮点数，C会强制类型转换，用这种方法改： 123456789101112#include &lt;stdio.h&gt;int main()&#123; int foot; int inch; printf(&quot;请分别输入身高的英尺和英寸，&quot; &quot;如输入\\&quot;5 7\\&quot;表示5英尺7英寸：&quot;); scanf(&quot;%d %d&quot;, &amp;foot,&amp;inch); printf(&quot;身高（国际单位）:%f\\n&quot;, (foot+(inch/12.0))*0.3048); return 0;&#125; 第二种方法是改变量类型： 123456789101112#include &lt;stdio.h&gt;int main()&#123; double foot; double inch; printf(&quot;请分别输入身高的英尺和英寸，&quot; &quot;如输入\\&quot;5 7\\&quot;表示5英尺7英寸：&quot;); scanf(&quot;%lf %lf&quot;, &amp;foot,&amp;inch); printf(&quot;身高（国际单位）:%f\\n&quot;, (foot+(inch/12))*0.3048); return 0;&#125; 对于整型变量，我们输入的时候用%d输出的时候也用%d，但对于double我们输入用%lf输出用%f。 浮点数有两种，一种是 双精度浮点数 double，一种是单精度浮点数 float(不是single)。 那么在计算机里为什么会出现整数这样的东西，其实日常生活中和计算中我们不会特地去想这个数是整数还是小数，但由于计算机只认二进制，整数可以被完整表达，在计算机内部可以比较快地运算，但十进制小数转二进制有时候只能转成近似值，而且计算机计算比较慢。 表达式 ex[ression 一个表达式是一系列算子和运算符的组合。 运算符 比如 + ，- ，= 算子，是指参与运算的值，该值可以是常数也可以是变量也可能是一个方法的返回值。 1234567891011121314#include &lt;stdio.h&gt;#include &lt;math.h&gt;int main()&#123; int hour1, min1; int hour2, min2; scanf(&quot;%d %d&quot;, &amp;hour1,&amp;min1); scanf(&quot;%d %d&quot;, &amp;hour2,&amp;min2); int t1=hour1*60+min1; //不是min1/60是因为避免使用浮点数 int t2=hour2*60+min2; //不是min2/60是因为避免使用浮点数 int t=abs(t2-t1); printf(&quot;时间差是%d小时%d分&quot;, t/60,t%60); return 0;&#125; 表达式：expression 对于C语言来说，表达式是一个非常宽泛的概念，单一的字面量，单一的变量，计算的结果，函数的返回值……都是表达式的范畴。任何表达式都是有返回值的。可以理解为表达式本身也有值。举例：把while（x==10) 写成了 while （x=10)，然后程序就在这里死循环了，永远出不来。编译器不会向我们报错，因为这样的写法其实是合法的，赋值表达式是有（返回）值的。经查询，赋值表达式的返回值是赋值符号右边的值(逗号运算符返回的也是右边的值)。x=10的值就是10，所以while永远不会结束。而关系表达式往往返回bool值。 语句：语句和表达式是两个概念，广义上讲，有;的就是语句，没有分号的就是表达式。C语句可分为以下五类： 表达式语句：表达式语句由表达式加上分号“;”组成。其一般形式为：表达式; 执行表达式语句就是计算表达式的值。例如 c=a+a; 函数调用语句：由函数名、实际参数加上分号“;”组成。其一般形式为：函数名(实际参数表); 例如 printf(“Hello !”); 控制语句：控制语句用于控制程序的流程，以实现程序的各种结构方式。它们由特定的语句定义符组成。C语言有九种控制语句。 可分成以下三类： 条件判断语句：if语句、switch语句；为什么if语句叫语句呢？因为if后面跟一个{}，其实是一个复合语句。 循环执行语句：do while语句、while语句、for语句； 转向语句：break语句、goto语句、continue语句、return语句。 复合语句：把多个语句用括号{}括起来组成的一个语句称复合语句。在程序中应把复合语句看成是单条语句，而不是多条语句。例如：{ x=y+z; a=b+c; printf(&quot;%d%d&quot;, x, a); } 空语句：只有分号“;”组成的语句称为空语句。空语句是什么也不执行的语句。在程序中空语句可用来作空循环体。例如：while( getchar()!=’\\n’ ); 表达式和语句的区别： 功能不同：表达式本身是什么都不做的，只返回值，只是单纯的计算过程。它可以被放在任何需要值的地方。当然赋值表达式是比较特殊的，它虽然也返回值，但主要作用显然是改变变量的值，其实赋值表达式更像一个语句。语句是命令式编程语言的一个语法单元，表示程序要执行的操作。语句则是一个行为，负责执行某种操作，没有返回值。程序就是通过语句来执行功能的。语句由分号(或{})来结尾。 二者本质不同：表达式由操作符（运算符）和操作数(算子)构成的式子。而语句的组成相对复杂，多种多样。 表达式与语句的联系： 表达式语句就是仅有表达式组成的语句（其实就是指赋值语句，或者由赋值语句组成的逗号表达式，如if()里的那些逗号表达式，不然根本没有意义） 很多语句需要用到值，也就是表达式。比如while（）的括号中需要一个值来告诉它循环是否结束且我们一般都会用关系表达式，关系表达式往往返回bool值。 其实深究表达式与语句的区别并没有什么意义。我们只需要记住，表达式是值，而语句是操作。有;的就是语句，没有分号的就是表达式，即可。 Day 3 运算符优先级 单目运算符：一个运算符如果需要两个算子则为双目运算符，仅有一个算子则为单目运算符，单目运算符优先级比乘除高，取余和乘除平级。单目运算符一定出现在算子左边。有的语言赋值是一个语句，但C来说赋值是运算符，赋值这个运算符是自右向左结合，比如a=b=6计算机理解为a=(b=6)。赋值的优先级是最低的。不要做嵌入式赋值，不易读。 取余运算符 % 是双目运算符，该运算符的两边均必须是整型，不能是浮点，否则取什么余呢？ 交换变量 程序表达的是要执行的动作，而不是表达关系。 123456789101112#include &lt;stdio.h&gt;int main()&#123; int a=5; int b=6; int t; t=a; a=b; b=t; printf(&quot;a=%d, b=%d&quot;, a,b); return 0;&#125; 我们想看到程序运行过程中5和6是怎么换的，需要用到调试功能，需要设断点，作用是当程序走到这一行时它会停下来，停在这一行表示这一行还没有执行即将要执行。 编程中一些套路要多阅读别人的程序来获得。 复合赋值和递增递减 四则运算符和取余符号都可以和赋值运算符结合形成复合运算符 eg,a+=5即a=a+5，之所以会出现这种复合运算符，是因为C当时想做成一个底层的编程语言，所以设计C是有一个思想即，能用C表达出机器语言所有的指令，又在PDP-11上做出的C，而PDP-11上刚好有一条机器指令专门去做这样的事情，所以便出现了这个东西。 a+=b+5即为a=a+(b+5) 和–都是单目运算符，其算子必须是变量不可是常量， count即count+=1即count=count+1。运算符都有结果，a++的结果是a加1以前的原值，++a是a加了1以后的值，但无论哪个，a的值都是加1以后的值，这两种运算符的出现与复合运算符一样，对于复合运算符和递增递减运算符可以单独使用但不要组合进表达式，否则很难读， practice 1234567891011#include &lt;stdio.h&gt;int main()&#123; int a; printf(&quot;请输入一个正整数，单位是厘米：&quot;); scanf(&quot;%d&quot;,&amp;a); int foot=a/30.48; int inch=((a/30.48)-foot)*12; printf(&quot;%d %d&quot;, foot,inch); return 0;&#125; 怎么把一个四位数从中间分开呢，比如1120，我们用int a=1120/100得到11，用1120%100得20. 123456789101112#include &lt;stdio.h&gt;int main()&#123; int a; printf(&quot;请输入一个3位正整数：&quot;); scanf(&quot;%d&quot;,&amp;a); int b=a/100; int c=a%10; int d=a%100/10; printf(&quot;%d&quot;, c*100+d*10+b); return 0;&#125; 程序中如果想要表达一个二进制数，直接写二进制会显得太长，所以人们一般使用十六进制来表达， 十进制：18 二进制：0001 0010 十六进制：0x12 BCD：12 0的故事 十九世纪末二十世纪初有电报时开始，英文的O和0很像不容易区分，所以电报里的0不是空心的，中间多了一条斜杠，这个做法延续到计算机出现，最初的程序是程序员手写的，然后交给操作员打在穿孔卡片上，手写程序也有这种字体，到后来终端出现，专门为0设置这种字体. 做判断 if(条件成立){ … } 判断的条件 if 语句后面的小括号里的东西也是一种运算，叫关系运算，以下是关系运算符(比较运算符)，不是逻辑运算符： 运算符 意义 == 相等 ！= 不相等 &gt;= 大于或等于 &lt;= 小于或等于 运算符都有结果，关系运算的结果要么是0要么是1， 12345678#include &lt;stdio.h&gt;int main()&#123; printf(&quot;%d\\n&quot;, 5==3); printf(&quot;%d\\n&quot;, 5&gt;=3); printf(&quot;%d\\n&quot;, 5&lt;=3); return 0;&#125; 关系运算符的优先级比算术运算符优先级低，但是比赋值运算符优先级高，而在关系运算符中，==和！=的优先级又比其它比较运算符低，连续的关系运算符是从左到右进行的， Day 4 找零计算器 //(comment)是C99的注释，ANSIC不支持，//是单行注释，/* */是多行注释。多行注释是C传统的形式，单行注释是C99独有的。 1234567891011121314#include &lt;stdio.h&gt;int main()&#123; const int MINOR=35; int age=0; printf(&quot;请输入您的年龄：&quot;); scanf(&quot;%d&quot;, &amp;age); printf(&quot;您输入的年龄是：%d\\n&quot;, age); //人机交互常用手段 if (age&lt;MINOR)&#123; printf(&quot;青春不常在，抓紧谈恋爱！\\n&quot;); &#125; printf(&quot;三十而立，四十而不惑，五十而知天命，六十而耳顺，七十而从心所欲，不逾矩。\\n&quot;); return 0;&#125; 否则的话 else 123456789101112131415#include &lt;stdio.h&gt;int main()&#123; int a,b; printf(&quot;请输入两个整数：&quot;); scanf(&quot;%d %d&quot;, &amp;a,&amp;b); int max; if (a&lt;b)&#123; max=b; &#125; else&#123; max=a; &#125; printf(&quot;%d大&quot;, max); return 0;&#125; 12345678910111213#include &lt;stdio.h&gt;int main()&#123; int a,b; printf(&quot;请输入两个整数：&quot;); scanf(&quot;%d %d&quot;, &amp;a,&amp;b); int max=a; if (a&lt;b)&#123; max=b; &#125; printf(&quot;%d大&quot;, max); return 0;&#125; 以上两段代码，虽然第二段耍了一下小聪明，更简洁，但第一段更傻，易读性更强，翁恺哥哥更偏爱第一段。 注意else后面不能跟表达式，即 else (a &gt; b) {} 是不行的，编译器会报错。 if语句再探 虽然C语言要求每一句语句结尾要有一个分号，但if的圆括号后面不是if语句结束的地方，若if的圆括号后面不加{}，则紧跟在if后面的那一句话，是if条件成立时要执行的那句话，但没有大括号时也仅限这一句话。 12if (a&gt;b) c=a+b; //这两行才是一个完整的if语句，第二行后面才跟分号 嵌套的if-else 计算机最不会做的就是一眼看出来结果， 1234567891011121314151617181920212223#include &lt;stdio.h&gt;int main()&#123; int a,b,c; printf(&quot;请输入三个正整数：&quot;); scanf(&quot;%d %d %d&quot;, &amp;a,&amp;b,&amp;c); int max=0; if (a&gt;b)&#123; if (a&gt;c)&#123; max = a; &#125; else&#123; max=c; &#125; &#125; else&#123; if (b&gt;c)&#123; max=b; &#125; else&#123; max=c; &#125; &#125; printf(&quot;%d最大\\n&quot;, max); return 0;&#125; tips: 在if或者else后面总是用{} 即使只有一条语句的时候 为何？ 如果不加{}，那么else总是和距离它最近的那个if匹配，与缩进无关(这一点与python不同)，而且这样很容易看错谁跟谁匹配，加了{}，else就不再遵守总是和距离它最近的那个if匹配这条规则，而是根据{}来判断谁跟它匹配。 级联的if-else 1234567891011121314151617181920212223#include &lt;stdio.h&gt;int main()&#123; //写一个分段函数 double x,f; scanf(&quot;%lf&quot;,&amp;x); if (x&lt;0)&#123; f=-1; &#125; else&#123; if (x==0)&#123; f=0; &#125; else&#123; if ((0&lt;x)&amp;&amp;(x&lt;=5))&#123; f=1; &#125; else&#123; f=3*x; &#125; &#125; &#125; printf(&quot;%d&quot;, f); return 0;&#125; 这样看起来代码会越来越往右边偏，最终会超出屏幕，早年这样很麻烦，所以想出来下面的编排方式，把所有else对齐，这样的编排方式叫做级联的if-else。 123456789101112131415161718#include &lt;stdio.h&gt;int main()&#123; //写一个分段函数 double x,f; scanf(&quot;%lf&quot;,&amp;x); if (x&lt;0)&#123; f=-1; &#125; else if (x==0)&#123; f=0; &#125; else if ((0&lt;x)&amp;&amp;(x&lt;=5))&#123; f=1; &#125; else&#123; f=3*x; &#125; printf(&quot;%f&quot;, f); return 0;&#125; 这一段代码再对比下面一段代码有个明显的优点就是单一出口，下面一段代码是多出口，计算得到的结果不能用作他用只能printf,是写死了的.(出口不一定离开代码,printf给用户看也叫出口) 1234567891011121314151617#include &lt;stdio.h&gt;int main()&#123; //写一个分段函数 double x; scanf(&quot;%lf&quot;,&amp;x); if (x&lt;0)&#123; printf(&quot;%d&quot;, -1); &#125; else if (x==0)&#123; printf(&quot;%d&quot;, 0); &#125; else if ((0&lt;x)&amp;&amp;(x&lt;=5))&#123; printf(&quot;%d&quot;, 1); &#125; else&#123; printf(&quot;%f&quot;, 3*x); &#125; return 0;&#125; 在run上述代码时，我发现整型数据以%f输出时，以及浮点数以%d输出时，会产生unexpected的结果，这个涉及底层类型转换，后面细说。 if-else常见错误 忘了大括号 if的括号加了; 如 if(age&gt;60); z则C的编译器理解为 if(age&gt;60) ; a=b是一个表达式，它也有一个结果就是b，因此，if(a=b)只要b不是0就为真。 编译器在看到你的程序有问题时，会给出两种类型的提示，一种时error，一种是warning。出现error编译器认为你的程序是错的因此不会产生可执行的东西，但warning，编译器不确定你的程序是不是出错了，最后还是做出来了可执行程序。一则笑话“从悬崖边立一块牌子——warning，则程序员都会掉下去。”所以我们要尊重warning。 虽然C语言的编译器它不管缩进，但是我们该加的要加，该规范的规范， 多路分支 级联的if-els一般用来判断在一定范围内我要怎么做，在另一范围内我要怎么做，但有时我们会碰到这样的问题，当我们这个变量等于一个特定值的时候，我们要这样做，等于另一个特定值时我们要那样做，我们用级联可以做到： 123456789101112131415161718192021222324#include &lt;stdio.h&gt;int main()&#123; //写一个分段函数 int type; scanf(&quot;%d&quot;,&amp;type); if (type==1) &#123; printf(&quot;你好&quot;); &#125; else if (type==2) &#123; printf(&quot;早上好&quot;); &#125; else if (type==3) &#123; printf(&quot;晚上好&quot;); &#125; else &#123; printf(&quot;啊对对对对&quot;); &#125; return 0;&#125; 但这样写有一个坏处，比如我输入3，程序先要比较前type是否等于1和2，才轮到和3比较，于是我们可以用switch-case写，当我们需要输入一些按键来做分支结构时，switch-case很实用，比如做电商项目时，需要用户输入数字来决定下一步程序做什么，用switch-case效率很高。 12345678910111213141516171819202122#include &lt;stdio.h&gt;int main()&#123; //写一个分段函数 int type; scanf(&quot;%d&quot;,&amp;type); switch (type) &#123; case 1: printf(&quot;你好&quot;); break; case 2: printf(&quot;早上好&quot;); break; case 3: printf(&quot;晚上好&quot;); break; default: printf(&quot;啊对对对对&quot;); break; &#125; return 0;&#125; 用switch-case比if语句的好处是，比如我输入3，程序会直接跳到case 3，它不会再慢慢比较上面的1和2。 而且，C语言里，switch()后面括号里的只能是整数型结果或枚举型结果，否则会error，比如double就不行。但是JAVA里，switch()括号里面可以不是整数，可以是字符串什么的，只要是具体的值就行。 其中case后面要跟一个常量(也可以是常量表达式 C99支持)，且case 的 constant-expression必须与 switch 中的变量具有相同的数据类型。JAVA里面case后面也是跟常量，比如具体的数字9，比如具体的字符串“hello”。 一个switch语句中只能有一个default语句，而且default语句可以省略。 如果把上面一段代码中的break全部删去，输入1，则会执行下面所有的printf语句，case并没有把代码分成一个个互斥的代码块，它只是从哪开始执行的入口，遇到break或者switch结束才会结束。switch里的break只跳出switch。 case后面的语句不需要加大括号，只要别忘了break就行。不过有的编程规范上会建议用大括号把case后面的语句括起来。“不能通过编译”，可能是下面这个原因。C/C++里规定，不能在case语句里定义局部变量。例如： 1234567891011int a = 2; switch (a) &#123; case 1: int c = 10; break; case 2: break; default: break; &#125; 编译就会出错，原因是在case 1里定义了局部变量c。而C/C++还有一个很有意思的规定，用｛｝包括的语句，认为是一个”语句块“，而在语句块里就能想干什么就干什么。 比如： 123456789101112switch (a) &#123; case 1: &#123; int c = 10; break; &#125; case 2: break; default: break; &#125; 这样就能通过编译了。 Day 5 while 循环 计算机最不擅长的就是一眼看出来，但这是人最擅长的，人对文字的处理能力要优于对数字的处理能力，计算机相反。比如要得到某一个4位数以下数字的位数，人一眼就看出来的事计算机要写一段代码。 123456789101112131415161718#include &lt;stdio.h&gt;int main()&#123; int x, n; printf(&quot;请输入一个4位以下的正整数：&quot;); scanf(&quot;%d&quot;, &amp;x); if (x&gt;999)&#123; n=4; &#125;else if (x&gt;99)&#123; n=3; &#125; else if (x&gt;9)&#123; n=2; &#125; else &#123; n=1; &#125; printf(&quot;%d位数&quot;, n); return 0;&#125; 再比较下面一段代码： 123456789101112131415161718#include &lt;stdio.h&gt;int main()&#123; int x, n; printf(&quot;请输入一个4位以下的正整数：&quot;); scanf(&quot;%d&quot;, &amp;x); if (x&gt;999)&#123; n=4; &#125;if (x&gt;99)&#123; n=3; &#125;if (x&gt;9)&#123; n=2; &#125;if (x&gt;0)&#123; n=1; &#125; printf(&quot;%d位数&quot;, n); return 0;&#125; 这样会发现无论怎么输结果都是1位数，这是因为，我们写程序时写的是步骤，而非说明。 对于上面的程序，判断4位以下的数字位数是没毛病的，但是要判断5位数呢，6位数呢，要一直加分支吗？那多麻烦啊， 1234567891011121314#include &lt;stdio.h&gt;int main()&#123; int x; int n=0; printf(&quot;请输入一个正整数：\\n&quot;); scanf(&quot;%d&quot;, &amp;x); while (x&gt;0)&#123; x/=10; n++; &#125; printf(&quot;%d位数&quot;, n); return 0;&#125; 问题迎刃而解。但整数在计算机里因为要用二进制表达它，所以是有范围的。 1234567if (x&gt;0)&#123; n++;&#125;while (x&gt;0)&#123; n++;&#125; 可见就是把 if 换成 while。循环体里要有改变条件的机会，否则会出现死循环，但这种出现语法上没有任何错误，但逻辑有错， do-while 循环 do-while在进入循环时先不做检查，而是在执行一轮循环体的代码后再来检查循环的条件是否满足，之前那个while在循环体前面，这个在循环体后面，只不过do-while，最后while()后面要跟一个; 猜数游戏 rand()和printf()一样，是一个系统库里面的函数， x%n的结果是[0, n-1]的一个整数， 1234567891011#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;int main()&#123; //随机输出一个0-100的随机数 srand(time(0)); int a=rand(); printf(&quot;%d\\n&quot;, a%100); return 0;&#125; 以下是猜数游戏源代码 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;int main()&#123; //随机输出一个0-100的随机数 srand(time(0)); int number=rand()%100+1; printf(&quot;我已经想好一个1-100之间的数了！\\n&quot;); int count=0; int a=0; do &#123; printf(&quot;请输入你猜的数吧！\\n&quot;); scanf(&quot;%d&quot;, &amp;a); count++; if (a&gt;number)&#123; printf(&quot;你猜大了哈哈哈\\n&quot;); &#125; else if (a&lt;number)&#123; printf(&quot;你猜小了哈哈哈\\n&quot;); &#125; else&#123; printf(&quot;Bingo!\\n&quot;); &#125; &#125; while (a != number); printf(&quot;哈哈哈哈你猜了%d次终于猜对啦！\\n&quot;, count); return 0;&#125; 算平均数 12345678910111213141516#include &lt;stdio.h&gt;int main()&#123; //计算average int sum=0; int x=0; scanf(&quot;%d&quot;, &amp;x); int n=0; while (x != -1)&#123; sum += x; scanf(&quot;%d&quot;, &amp;x); n++; &#125; printf(&quot;average=%f&quot;, (sum*1.0)/n); return 0;&#125; 整数逆序 分解一个多位数： 对一个整数做%10，得到它的个位数； 对一个整数做/10，去掉它的个位数； 再对第2步得到结果做%10，得到其十位数； 在对第2步得到的结果做/10，则去掉它的十位数； 以此类推。 1234567891011121314151617#include &lt;stdio.h&gt;int main()&#123; //整数逆序1 int x; int digit=0; int ret=0; printf(&quot;请输入一个正整数：&quot;); scanf(&quot;%d&quot;, &amp;x); while (x&gt;0)&#123; digit=x%10; x=x/10; ret=ret*10+digit; printf(&quot;x=%d,digit=%d,ret=%d\\n&quot;, x,digit,ret); &#125; return 0;&#125; 123456789101112131415#include &lt;stdio.h&gt;int main()&#123; //整数逆序2 int x; int digit=0; printf(&quot;请输入一个正整数：&quot;); scanf(&quot;%d&quot;, &amp;x); while (x&gt;0)&#123; digit=x%10; printf(&quot;%d&quot;, digit); x=x/10; &#125; return 0;&#125; for 循环 for (expression1; expression2; expression3) expression1:初始化动作 expression2:循环条件 expression3:循环体做完后要做的动作 for后面括号里的三个表达式都是可以省略的。for(;条件;)==while(条件)。 123456789101112#include &lt;stdio.h&gt;int main()&#123; int n; int factor=1; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; factor*=i; &#125; printf(&quot;%d&quot;,factor); return 0;&#125;//不能int i=2,因为n=1时就不对了 Day 6 循环的计算和选择 for循环和while循环是等价的，任何一个for循环和while循环都可以相互转换。 for 循环，while循环，do-while循环，tips: 有固定次数，用for,如算阶乘; 必须至少执行一次循环体，则do-while； otherwise用while循环； 循环控制 遇到break就会离开这一层循环，不管是for、while、do-while；continue是跳过这一轮循环，这一轮循环余下没做的语句就不做了，但没有出这一层循环，下一轮循环还要做， 1234567891011121314151617181920#include &lt;stdio.h&gt;int main()&#123; int x; int isPrime=1; printf(&quot;请您输入一正整数：\\n&quot;); scanf(&quot;%d&quot;, &amp;x); for (int i = 2; i &lt; x; ++i) &#123; if (x%i==0)&#123; isPrime=0; break; &#125; &#125; if (isPrime==0)&#123; printf(&quot;您输入的数是合数。&quot;); &#125; else&#123; printf(&quot;您输入的数是质数。&quot;); &#125; return 0;&#125; 嵌套的循环 循环的嵌套可以是for&amp;for、for&amp;while、也可以是while&amp;while嵌套，一般情况下。嵌套循环每一层循环使用的控制变量应该是不一样的。 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;int main()&#123; int x=2; int cnt=0; int isPrime=1; //只有当有素数出现时，cnt才加1，每个cnt后面都代表有一个素数输出，0-49即有50个素数输出 while (cnt&lt;50)&#123; // for (int j = 2; j &lt; x; ++j) &#123; if (x%j==0)&#123; isPrime=0; break; &#125; &#125; // if (isPrime==1)&#123; printf(&quot;%d\\t&quot;, x); cnt++; if (cnt%5==0)&#123; printf(&quot;\\n&quot;); &#125; &#125; // x++; isPrime=1; &#125; return 0;&#125; 从嵌套的循环中跳出 break和continue只能跳出它所在那一层循环。如果我想让内层循环满足一定条件后，直接跳出所有循环，可以把break和if联用，需要一个变量表达这个条件，在每一层循环的循环体最后用if判断一个条件，当都满足一定条件时，会相继跳出每层循环，叫做接力break。 123456789101112131415161718192021#include &lt;stdio.h&gt;int main()&#123; //用1角、2角、5角硬币凑出2元硬币 int x=2; int exit=0; for (int one = 0; one &lt;= 20; ++one) &#123; for (int two = 0; two &lt;= 10; ++two) &#123; for (int five = 0; five &lt;= 4; ++five) &#123; if (one+two*2+five*5==20)&#123; printf(&quot;可以用%d个1角,%d个2角,%d个5角凑出2元硬币\\n&quot;, one,two,five); exit=1; break; &#125; &#125; if (exit) break; &#125; if (exit) break; &#125; return 0;&#125; 这是其中一种手段，还有另外一种手段，我们还有一个好朋友叫goto，可以在需要离开循环的地方设置一个goto语句，在要跳的地方做一个标记label:，意味着goto跳到label那里去。 123456789101112131415161718#include &lt;stdio.h&gt;int main()&#123; //用1角、2角、5角硬币凑出2元硬币 int x=2; for (int one = 0; one &lt;= 20; ++one) &#123; for (int two = 0; two &lt;= 10; ++two) &#123; for (int five = 0; five &lt;= 4; ++five) &#123; if (one+two*2+five*5==20)&#123; printf(&quot;可以用%d个1角,%d个2角,%d个5角凑出2元硬币\\n&quot;, one,two,five); goto hell; &#125; &#125; &#125; &#125; hell: return 0;&#125; C语言有哪些基础数据类型 C语言是一种有类型的语言。即变量在使用前要先定义而且要确定类型，C语言之后的语言向两个方向发展： C++/Java 这种强类型语言，对类型的检查比C语言还严格； JavaScript、python、PHP 属于弱类型语言，不看重类型，甚至变量不需事先定义， 学界关于这件事情上划分两派 支持强类型语言的认为明确的类型有助于今早发现程序中的简单错误； 支持弱类型的认为，过于强调类型会迫使程序员面都对底层而非事务逻辑； 并没有说以上观点哪个是对的哪个是错的，总的来说，越早期的语言越强调类型，因为早期的语言面向底层，因为我们可能要用非常明确的类型来表达一些计算机内部的东西，但越面向应用的语言越忽视类型。C语言虽然是强类型语言，但对类型的安全检查相比后面的语言并不足够，C语言的基础数据类型可以分为以下几类： 整数 char、short(短整型)、int(整型)、long(长整型)、long long 浮点数 float、double、long double 逻辑(布尔类型) bool(人为定义)C99才出现布尔类型 指针 除了基础数据类型。C语言还有自定义数据类型等等， 不同类型除了类型名称不同外，* 输入输出的格式化也不同如 %d、%ld、%f， 所表达数的范围不同， char&lt; short&lt; int&lt; float&lt; double 在内存中占据的内存大小不同，char是一个字节，long double是16个字节 不同类型变量在内存中的表现形式不一样，整型变量在内存中是自然二进制码或二进制的补码，而对于浮点数，它是一种编码形式，而不是自然二进制数，这就意味着它不能直接拿来做运算，而两个整数可以直接拿它的二进制码在加法器里面做加法， C语言给出了一个运算符 sizeof()，它可以给出某个类型或者某个变量在内存中占据的字节数，eg,sizeof(int), sizeof(i), 123456789#include &lt;stdio.h&gt;int main()&#123; int a; a=6; printf(&quot;sizeof(long double)=%ld\\n&quot;, sizeof (long double)); printf(&quot;sizeof(a)=%ld\\n&quot;, sizeof (a)); return 0;&#125; 但是sizeof()是一个静态运算符，它的结果在编译时就已经决定了，不要在sizeof里做运算，这些运算不会做，比如下面这串代码 12345678910#include &lt;stdio.h&gt;int main()&#123; int a; a=6; printf(&quot;sizeof(long double)=%ld\\n&quot;, sizeof (long double)); printf(&quot;sizeof(a)=%ld\\n&quot;, sizeof (a++)); printf(&quot;a=%d\\n&quot;, a); return 0;&#125; 输出结果仍是a=6，因为a根本没有做，编译器在编译是看到sizeof，就会看sizeof括号里那个表达式结果会是什么类型的，然后根据这个类型就决定了“sizeof(a)”这个整体后面会被替换成一个什么样的数字，所以当程序编译完后这个6就已经确定下来了，a++并没有产生实际要执行的代码，sizeof是静态运算符并不会真的去做运算。 除了int还有多少种整数类型 char:1字节,用于声明单个字符的关键字。C语言没有专门用于存储字符串的变量类型，字符串都被存储在char类型的数组中。数组由连续的存储单元组成，字符串中的字符被存储在相邻的存储单元中，每个单元存储一个字符。C语言中，一个汉字占据两个char类型。十分注意，JAVA里面char类型占2个字节。 在打印汉字时，它的两个char必须紧跟着。 short:2字节 int:取决于编译器和CPU，通常的意义是“1个字”。字:CPU一次性传输，运算或处理的二进制数据。 long:取决于编译器和CPU，通常的意义是“1个字” long long:8字节 都知道计算机内部有一个东西叫CPU，CPU外面还有个东西叫内存，CPU和内存中间有一个叫总线的东西将两者连接，CPU里面有个东西叫寄存器(Reg.)，当我们说计算机字长时，就是在说寄存器多宽，也就是说这个寄存器是几个比特的，比如寄存器每次能处理32bit的数据，也就是说每次总线从内存向CPU传数据每次能传32bit的数据，那么这个字长也就会在C语言中反映为int，也就是int想要表达的是计算机一个寄存器的大小，所以在不同的电脑什么int会变得不一样大。 CPU位数=CPU中寄存器的位数=CPU能够一次并行处理的数据宽度（位数=数据总线宽度=计算机字长 我们平时用的数据类型，默认是signed，只不过signed缺省了，如果要定义无符号数，只需在前面加unsigned。需要注意的是，unsigned int 和int 是2种数据类型，所能表达的最大值也不同，前者是2的32次方-1，后者是2的31次方-1。 C语言除了基本数据类型，还有其它数据类型： 基本数据类型； 枚举类型enum； 空类型void； 派生类型：(类似JAVA的引用类型) 指针类型； 数组类型； 函数类型； 结构体类型； 整数的内部表达 我们怎么用二进制表达负数呢？ 可以仿照十进制，有一个特殊的标志来表示负数； 取中间数为0，如10000000表示0，比它小的是负数，比它大的是正数； 补码 第一种方案有个问题就是，计算机在做加法减法是，需要特别判断符号位，并且符号位不参与运算，但这样不能像正常的二进制一样做运算，会让计算机做运算更加复杂。 如果采用中间数，那么比如10000000本来表示128，我们如果强制规定这个数是0D，那我们想得到其它数就得都减去10000000，比如我们想得到1D，就得用10000001-10000000，还是太麻烦。 我们希望-1+1=0，假设我们现在只占用1个字节，0是00000000，1是00000001，那么如果我们用11111111+00000001，那么结果是100000000，变成9位，但我们目前只能用8位，所以最高位1被丢弃，结果就是00000000。11111111被当作普通的二进制数看待是255，被当作补码看待是-1，即11111111就是1二进制数的2的补码，补码得意义就是拿补码和源码可以加出一个溢出的0，用补码的好处是，需要做正负运算时，直接用最普通的二进制运算就能得到正确的结果， 整数的范围 对于一个8位的二进制数，表达无符号数的范围是0-255，表达有符号数是-128-127。 前面提到char类型占用1个字节，int占用和字长相同的字节。 123456789101112#include &lt;stdio.h&gt;int main()&#123; printf(&quot;%d\\n&quot;, sizeof(int)); printf(&quot;%d\\n&quot;, sizeof(char)); char a=127; char b=255; int c=255; int d=2147483648; printf(&quot;a=%d,b=%d,c=%d,d=%d&quot;, a,b,c,d); return 0;&#125; 这段代码的输出只有理解《Code》13章才能看懂，代码输出是： 12341a=127,b=-1,c=255,d=-2147483648 我的电脑CPU是X64，也就是： CPU位数=CPU中寄存器的位数=CPU能够一次并行处理的数据宽度（位数=数据总线宽度=计算机字长=64) 不是说int反映是计算机字长吗，sizeof出来怎么是4个字节32位，原因是编译器的问题，编译器也会决定int的空间。然后char占用一个字节的内存众所周知，那么我们明明给a赋值是255，怎么输出变成了-1呢？有个前提，C语言中char short int long等在不指定signed或unsigned时都默认为signed，所以我们默认情况下给b赋值255，255存到b那块内存变成255的二进制数11111111，等到输出是，char默认转成int型，变成11111111 11111111 11111111 11111111按照signed输出，就是按照那两个圈的对应关系输出，11111111 11111111 11111111 1111111对应-1，所以输出-1。而char a=127，127的二进制数是01111111，在那两个圈的前半圈，按照对应关系，输出还是127。 到了int这变也是，int默认输出signed，int也是按照那两个圈，但由于int占用4个字节32位，所以int的圈大的多，4个字节的0int表示的范围是-2(31)-2(31)-1即-2147483648-2147483647，我们赋给d的值是2147483648，存到d那块内存上就是2147483648的二进制数00000000 00000000 00000000 01111111，计算机按照那两个圈圈，输出该二级制数的补码，再转化成该补码的十进制数，即-2147483648。赋给c的数255由于在圈的前半圈，所以同样按照对应规则输出为255。 我们想让计算机输出无符号数，需要加个unsigned，代表输出的十进制数是无符号数即，没有负数部分。我们试试看： 123456789101112#include &lt;stdio.h&gt;int main()&#123; printf(&quot;%d\\n&quot;, sizeof(int)); printf(&quot;%d\\n&quot;, sizeof(char)); char a=127; unsigned char b=255; int c=255; unsigned int d=2147483648; printf(&quot;a=%d,b=%d,c=%d,d=%d&quot;, a,b,c,d); return 0;&#125; 输出结果是： 12341a=127,b=255,c=255,d=-2147483648 哎怎么回事，我们明明unsigned了，int d=2147483648的输出怎么还是负数，char类型倒是没啥问题，输出的看上去和无符号数一样。问题出在%d上，%d 输出有符号10进制整数，所以即使我们unsigned了，但是%d输出还是按照有符号数输出，%u输出无符号10进制整数，所以我们将%d改成%u就没问题了。至于为什么b按照%d输出不是-1而是255，看上去输出的是无符号数呢？其实不是，char short int类型会按照int来输出,当小于int的整型变量传给printf时，编译器会把该整型变量自动转为int，即在unsigned char那里的255，会变成00000000 00000000 00000000 11111111，按照int有符号数来输出的话，也是255。所以b其实输出的也是有符号数。 123456789101112#include &lt;stdio.h&gt;int main()&#123; printf(&quot;%d\\n&quot;, sizeof(int)); printf(&quot;%d\\n&quot;, sizeof(char)); char a=127; unsigned char b=255; int c=255; unsigned int d=2147483648; printf(&quot;a=%u,b=%u,c=%u,d=%u&quot;, a,b,c,d); return 0;&#125; 输出是 12341a=127,b=255,c=255,d=2147483648 看，没问题了，对味了。既然%u能输出无符号十进制数，那我们直接unsigned也不要了单靠%u，试试能不能输出无符号数： 123456789101112131415161718192021#include &lt;stdio.h&gt;int main()&#123; printf(&quot;%d\\n&quot;, sizeof(int)); printf(&quot;%d\\n&quot;, sizeof(char)); char a=127; char b=255; char i=-1; char e=128; //按照%u输出 char h=127; char f=255; char j=-1; char g=128; //按照%d输出 int c=255; int d=2147483648; printf(&quot;a=%u,b=%u,i=%u,e=%u; h=%d,f=%d,j=%d,g=%d; c=%u,d=%u&quot;, a,b,i,e, h,f,j,g, c,d); return 0;&#125; 输出： 12341a=127,b=4294967295,i=4294967295,e=4294967168; h=127,f=-1,j=-1,g=-128; c=255,d=2147483648 哎我们发现不行，这时我们发现先辈用unsigned不是摆设，单靠%u不行，从上文我们知道char short int类型会按照int来输出,当小于int的整型变量传给printf时，编译器会把该整型变量自动转为int，也就是上午中unsigned char b=255，按照%u输出时，内存中的11111111靠编译器传给printf时，编译器会把11111111转为00000000 00000000 00000000 11111111，在输出，输出为255，没问题。那么这里为什么变成了b=4294967295，这是什么东西？我们仔细观察发现，4294967295=2的32次方，即11111111 11111111 11111111 11111111，不是说好的转成00000000 00000000 00000000 11111111吗，怎么转成了11111111 11111111 11111111 11111111？原来，加了unsigned的char，就是无符号数，编译器在转换的时候就当无符号数转，多出来的位补0，但若没加unsigned，则在在转成int时，按照有符号数去转，255的二进制有符号数最高位是1，所以多出的位用1补(按位右移:整个位向右移动，左边补符号位对应的内容，正数补0，负数补1，注意，这是针对有符号数)，转成的11111111 11111111 11111111 11111111按照有符号数输出就是-1，f印证了这一点，按照无符号数输出就是4294967295，b印证了这一点。同理，a在定义时也没加unsigned，但a是01111111，在转成int时虽然也按照有符号数转，但最高位为0，多出的位补0所以转成后是00000000 00000000 00000000 01111111，按照有符号数和无符号数输出都是127，a和h印证了这一点。e的遭遇同理，由于没有加unsigned，在char那一个字节上虽然是10000000，但是转int时按照有符号数去转，多出的位补1，最后转成11111111 11111111 11111111 10000000，这个数按照有符号数输出是-128，按照无符号数输出是4294967168，g和e可以印证这一点。最后看char i=-1和char j=-1，输出结果和char b=255和char f=255一样，可见-1和255赋值给char类型时，都是默认按照11111111赋值。 即计算机内存里的二进制数就在那，输出什么取决于我们怎么看它，是把它按照有符号数的对应关系输出还是按照无符号数的对应关系输出，至于unsigned，它决定char这种小于int的整型在输出转成int型时，多出来的位补0还是补1. 看来还是得unsigned 和 %u一块上。但如果定义unsigned char a=255，再输出++a，得到的结果是0，这不是因为输出的结果是有符号数的原因，输出的还是无符号数，只是100000000最高位的1上溢被计算机扔了。 常量和变量都属于变量，只不过常量是赋过值后不能再改变的变量，而普通的变量可以再进行赋值操作； 字面量是指由字母，数字等构成的字符串或者数值，它只能作为右值出现，所谓右值是指等号右边的值，如：int a=123这里的a为左值，123为右值。字面量是一个具体的值，比如变量的值或者常量的值。 在C中，如果一个字面量常量想表达自己是unsigned，可以在后面加u或U，想表示自己是long类型，可以在后面加l或L，设计unsigned的初衷并不是扩展这块内存所能表达的无符号数的范围，而是为了做纯二进制计算，主要是为了移位。 整数的格式化 虽然我们有很多种不同的整数类型，char short int long longlong，但在做scanf和printf输入和输出时，只有int 和 longlong这两种形式。也就是所有小于等于int的，也就是char short int 这三种，都采用int(%d)来输出，所有比int大的整型，用longlong来输出(%ld)，unsigned用%u输出。 printf中的f是format的意思，意思是格式化打印；同理，scanf是格式化扫描的意思。 % 是格式控制符，%d后面的d是Decimal integer的意思，详见该链接 1个以0开头的数字字面量是8进制；1个以0x开头的数字字面量是16进制。想要输出8进制就用%o，想要输出十六进制，数码是大写的ABCDEF,则用%X，想要输出十六进制，数码是小写的abcdef，则用%x。scanf里面用%o和%x都是表示莪们读进来的数当作八进制数和十六进制数。 12345678#include &lt;stdio.h&gt;int main()&#123; char a=012; char b=0x12; printf(&quot;a十进制=%d，b十进制=%d；a八进制=0%o，b十六进制=0x%x或0X%X,&quot;, a,b, a,b,b); return 0;&#125; 输出 1a十进制=10，b十进制=18；a八进制=012，b十六进制=0x12或0X12, 主要，不管我们给变量赋的值是八进制还是十六进制，存在计算机内存上的只有二进制，比如char a=012，a那里存的其实是八进制12的二进制数00001010，输出就根据00001010看是%d还是%u还是%x还是%o。 因为十六进制和二进制转换4位一换很方便，所以我们常常用16进制数表达二进制数。 选择整数类型 为什么C语言里面有这么多整数类型，是因为早期的语言需要准确地表达计算机内部的硬件，比如有一个输入输出的端口，那个端口就是16bit的，用short来表达刚好。 有些教科书可能会说，用short可以省一些内存什么的。但现在的计算机已经不是当年的计算机了，现在CPU起码是32位的，如果用char，那CPU还是得从内存中一次读32bit出来，然后在把那8bit从32bit中剥出来给你，不见得比能直接反映计算机字长得int更省事，所以我们今天没有特别需求就用int，除非要做硬件，平时也不会用unsigned，比如java它就不区分有符号数和无符号数，因为如果不做底层硬件，这些操作都用不上。 浮点类型 类型 大小(bit) 范围 有效数字 scanf printf float 32 -3.40×10^38 — (-1.20×10^-38) &amp; 0 &amp; 1.20×10^-38 — 3.40×10^38，±inf，nan 7 %f %f, %e double 64 -1.79×10^308 — (-2.20×10^-308) &amp; 0 &amp; 2.20×10^-308 — 1.79×10^308，±inf，nan 15 %lf %f, %e %e是输出科学计数法 1234567#include &lt;stdio.h&gt;int main()&#123; double a=1234.56789; printf(&quot;%e,%E,%f&quot;,a,a,a); return 0;&#125; 输出： 11.234568e+03,1.234568E+03,1234.567890 1234567891011#include &lt;stdio.h&gt;int main()&#123; double a=1E-10; printf(&quot;%e,%E,%f,%.16f&quot;,a,a,a,a); //double的范围可以包含1E-10，因为它有15位的有效数字 return 0;&#125;输出```C1.000000e-10,1.000000E-10,0.000000,0.0000000001000000 在%和f之间加上.n可以指定输出小数点后n位，这样的输出是要做4舍5入，但是我们有时感觉不是四舍五入，比如下面的printf(&quot;%.3f\\n&quot;,-0.0045); 我们本以为是-0.005，输出结果却是-0.004，怎么回事，看上去不是四舍五入。其实就是四舍五入，只不过如果5后面全是0 那么有可能是4999999这种情况，因此很可能后面的全部舍去。总而言之，如果第(n+1)位是5，5后面有非0数则进1，5后均为0则不进1，全舍去。 123456789101112#include &lt;stdio.h&gt;int main()&#123; // 负数四舍五入和正数规则一样 printf(&quot;%.3f\\n&quot;,-0.0045); printf(&quot;%.3f\\n&quot;,-0.0055); printf(&quot;%.3f\\n&quot;,-0.0046); printf(&quot;%.3f\\n&quot;,-0.00451); printf(&quot;%.30f\\n&quot;,-0.0049); printf(&quot;%.3f\\n&quot;,-0.00049); return 0;&#125; 输出： 123456-0.004-0.005-0.005-0.005-0.004899999999999999841793218991-0.000 -0.004899999999999999841793218991这是什么？实际上0.0049在计算机内部不能精确地表达为0.0049，我们在数学上数可以是连续的，但是在计算机内部，数只能被离散地表达，比如我们想表达0.0049，但是计算机不能表达0.0049，只能取0.0049最近的能在计算机内部表达的数代替0.0049，这就是浮点数的精度，当然double比float精度高，这是天然的缺陷。 Day 8 浮点数的范围和精度 printf输出±inf表示超过范围的浮点数：±∞ printf输出nan表示不存在的浮点数 12345678#include &lt;stdio.h&gt;int main()&#123; printf(&quot;%f\\n&quot;,12.0/0.0); printf(&quot;%f\\n&quot;,-12.0/0.0); printf(&quot;%f\\n&quot;,0.0/0.0); return 0;&#125; 输出： 123inf-infnan 上面的代码若用%d输出，则会报错，因为inf无法用整数表达，但可以用浮点数表达。虽然浮点数表达的实数范围是有限的，但可以表达0，±inf，nan这几个特殊的值。 1234567891011121314#include &lt;stdio.h&gt;int main()&#123; float a=1.345f; float b=1.123f; //带小数点但不带f的字面量是double float c=a+b; if (c==2.468)&#123; printf(&quot;相等\\n&quot;); &#125; else&#123; printf(&quot;不相等,c=%.10f或c=%f\\n&quot;,c,c); &#125; return 0;&#125; 输出 1不相等,c=2.4679999352或c=2.468000 float只有7位有效数字，即c=2.4679999352只有前7位c=2.467999是准确的，即在计算机内部它不是2.468，这是有误差的。所以如果要用浮点数做精确运算，最后误差会累计起来，不要用浮点数做精确运算，也不要让两个浮点数去直接判断是否相等，可以让两个浮点数差的绝对值小于某个很小的值来判断是否相等。卡西欧计算机是用整数来做小数运算的。 浮点数：N = M × R^(e) 其中，M称为数N的尾数，决定数的精度。E是数N的阶码(指数)，决定数的范围。 比如12.5×2(3)，和12.51×2(4)，尾数分别是12.5和12.51，显然12.51精度更高；阶码分别是3和4，显然4的范围更大。 浮点数在计算机内部和整数不同，整数可以用纯二进制表示，可以直接拿二进制做运算，但浮点数在计算机内部靠编码的形式表达，第一个bit表达正负号，后面几个bit表达以2为底的阶码(指数)，剩下的位数表示尾数。 类型 占用内存(bit) 内存分配 指数范围 float 32 1符号位,8指数位,23尾数位 [-127,128] double 64 1符号位,11指数位,52尾数位 [-1023,1024] 欲详细了解浮点数在内存中的存储方式，click this来点我呀 现在的CPU都带着专门做浮点计算的硬件，浮点数的编码形式会被该硬件解开，然后做浮点运算，得到结果硬件会把它编码再输出。计算double和计算float所用到的硬件是一样的。 没有特殊需求用double,因为现在CPU能直接对double做硬件运算，性能不会比float差，在64位的机器上速度也不比float慢。 字符类型 char不仅表示一种整数类型，还能表示字符类型，是character的前4个字母 我们给char类型赋值时，赋’1’和赋49是等价的。在计算机内部都是00000001，用%d输出就是49，用%c输出就是’1’，它的二进制就在计算机里，取决于你怎么看它。 12345678910111213141516171819#include &lt;stdio.h&gt;int main()&#123; if (&#x27;1&#x27;==49)&#123; printf(&quot;Then，OK&quot;); &#125; return 0;&#125;···果然输出OK，了解了输出的 %c ，看输入时scanf的作用，```C#include &lt;stdio.h&gt;int main()&#123; char a,b; scanf(&quot;%d %c&quot;, &amp;a,&amp;b); printf(&quot;a=%d,b=%d; a=%c,b=%c&quot;,a,b,a,b); return 0;&#125; 我们输入1 1，输出： 1a=1,b=49; a=╔,b=1 这样可以得出结论，scanf中的%c，会把输入当作字符解读，同样是输入1，%d当作整数1，%c当作‘1’，而输出的 ╔ 是因为根据ASCII码，十进制1对应 ╔ 。 如果同时在scanf里做2个输入，要不要加空格呢？看下面的代码 12345678910#include &lt;stdio.h&gt;int main()&#123; int a; char b; scanf(&quot;%d %c&quot;, &amp;a,&amp;b); //有空格 printf(&quot;a=%d,b=%d,b=%c&quot;,a,b,b); return 0;&#125; 我们分别输入 12a ，12 a，12 a， 输出结果都是 a=12,b=97,b=a 12345678910#include &lt;stdio.h&gt;int main()&#123; int a; char b; scanf(&quot;%d%c&quot;, &amp;a,&amp;b); //没空格 printf(&quot;a=%d,b=%d,b=%c&quot;,a,b,b); return 0;&#125; 我们分别输入 12a ，12 a，12 a， 输出结果分别是 a=12,b=97,b=a a=12,b=32,b= a=12,b=32,b= 为什么呢，注意空格的ASCII码就是32，也就是%d后面没有空格，则老老实实读下一个，即使下一个是空格也要读入，若有空格，则读完第一个，要把第一个后面的空格都读完才读下一个输入。 简单讲&quot;%d %c&quot;可以以0个或多个空白字符（空格、tab键、回车等）作为分隔符，同时%c不会读取空白字符，%c读取的一定是一个非空白字符。 scanf中的%d%d%d 是按十进值格式输入三个数值。输入时，在两个数据之间可以用一个或多个空格、tab 键、回车键分隔。 如果3个%d之间是用空格隔开的，像这样 %d %d %d 那么我们在每输入一个整数后必须输入一个分隔符，分隔符可以是空格、tab、回车。 如果使用 , 来分隔输入的 %d, 相应的输入时也需要添加&quot;,&quot;。 在用 %c%c%c 输入时，空格和&quot;转义字符&quot;均作为有效字符，除非%c之间用空格隔开。 scanf()函数使用空白（换行符、制表符和空格）把输入分成多个字段。 在依次把转换说明和字段匹配时跳过空白。只要在每个输入项之间输入至少一个换行符、空格或制表符即可，可以在一行或多行输入。唯一例外的是%c会读取每个字符，包括空隔符。 scanf()函数允许把普通字符放在格式字符串中，除空格字符外的普通字符必须与输入字符串严格匹配。 注意，scanf()中的 %md 和printf()中的 %md 含义是不同的。 键盘缓冲区残余信息问题： 12345678910111213#include &lt;stdio.h&gt;int main()&#123; int a; char c; do &#123; scanf(&quot;%d&quot;,&amp;a); scanf(&quot;%c&quot;,&amp;c); printf(&quot;a=%d c=%c\\n&quot;,a,c); /*printf(&quot;c=%d/n&quot;,c);*/ &#125;while(c!=&#x27;N&#x27;);&#125; scanf(&quot;%c&quot;,&amp;c);这句不能正常接收字符,什么原因呢？我们用printf(“c=%d\\n”,c);将C用int表示出来，启用printf(“c=%d\\n”,c);这一句，看看scanf()函数赋给C到底是什么，结果是 c=10 ,ASCII值为10是什么？换行即\\n.对了，我们每击打一下”Enter”键，向键盘缓冲区发去一个“回车”(\\r),一个“换行”(\\n),在这里\\r被scanf()函数处理掉，而\\n被scanf()函数“错误”地赋给了c. 解决办法：可以在两个scanf()函数之后加个fflush(stdin);，还有加getch(); getchar();也可以，但是要视具体scanf()语句加那个，这里就不分析了，读者自己去摸索吧。但是加fflush(stdin);不管什么情况都可行。 这种残留情况一般存在与上一个scanf()是%d，下一个scanf()是%c的情况，类似一个scanf()里面有%d%c，两个挨着，%c就会直接读下一个字符，即使下一个是回车。如果改成这样的代码： 123456789#include &lt;stdio.h&gt;int main()&#123; int a, b; scanf(&quot;%d&quot;, &amp;a); scanf(&quot;%d&quot;, &amp;b); printf(&quot;%d,%d&quot;, a, b); return 0;&#125; 输入12(回车)13，或者输入12(空格)13，输出就是12,13，不会读入那个回车，这种情况就类似于一个scanf()里面有%d%d,两个挨着，第2个%d就会认为回车是分隔符，直接跳过去读入下一个整数，也不会有缓冲区残余问题。 C语言的编码系统 C语言是 70 年代的产物，那个时候只有ASCII，各个国家的字符编码都还未成熟，所以C语言不可能从底层支持 GB2312、GBK、Big5、Shift-JIS等国家编码，也不可能支持 Unicode 字符集。 在C语言中字符有两种，一种是窄字符，另一种是宽字符。 只有 char 类型的窄字符才使用 ASCII 编码 char 类型的窄字符串、宽字符和宽字符串都不使用 ASCII 编码！wchar_t 类型的宽字符和宽字符串使用 UTF-16 或者 UTF-32 编码对于窄字符串，C语言并没有规定使用哪一种特定的编码，只要选用的编码能够适应当前的环境即可，所以，窄字符串的编码与操作系统和编译器有关。 可以肯定的说，在现代计算机中，窄字符串已经不再使用 ASCII 编码了，因为 ASCII 编码只能显示字母、数字等英文字符，对汉语、日语、韩语等其它地区的字符无能为力。对于窄字符串，C语言并没有规定使用哪一种特定的编码，只要选用的编码能够适应当前的环境即可，所以，窄字符串的编码与操作系统和编译器有关。 逃逸字符 逃逸字符：又叫转义字符，因为\\后面的字符，都不是它本来的ASCII字符意思了，所以叫转义。用来表达无法打印出来的字符，\\和后面一个字符共两个字符组成一个字符，注意逃逸字符是1个字符。 终端本身是一个别人写好的程序，叫shell，我们写的程序由shell执行，我们的程序只和shell打交道，我们在键盘上输入是被shell接收，然后shell再传给我们的程序，我们的程序输出什么东西，传给shell，shell展示给我们看。在shell充当媒介的过程中并不诚实，它要做一些翻译工作，比如程序里面有逃逸字符，shell要把这些逃逸字符翻译出来展示给我们看。不同的shell会对相同的转义字符作出不同的翻译，比如 “\\b” 在一些终端上是不显示的，在一些终端上显示BS(backslash)， 123456#include &lt;stdio.h&gt;int main()&#123; printf(&quot;123\\bA&quot;); return 0;&#125; 输出是 12A，可见\\b是将后面的字符安排在\\b前一个字符位置上并覆盖之，若\\b后面没有字符，则不覆盖。当然也可能找到其它的shell，其对\\b是不同的解释 \\n : 换行符（newline） 源自打字机，打字机上面的车(carriage)，随着打字，车会逐渐左移，打完1行用手把车拉回最右边叫回车，在这个过程中，要把纸往上抬一行，让打字机的写入位置放到下一行，就是换行。这俩字符在打字机上是两个动作，但我们在printf里面只用一个\\n就实现了回车换行，那是因为shell会把我们程序的\\n翻译成\\n和\\r \\r : 回车符（carriage return） 只有\\r，则光标会跳到这一行的开头去，\\r后面的内容会从头开始覆盖。 \\t : 制表符(tab) 相当于按下一个tab键 表格位是说在每一行中有一些特定的位置，用一个\\t可以让下一个输出从下一个表格位开始，比如当前光标在第3个表格位中间，后面加一个\\t，光标就会跳到下一个表格位始端。\\t不代表固定的字符数量而代表输出的位置，比如： abc | ab | 不管前面有几个字符，敲一个tab键光标都会跳到相同的位置。 1234567#include &lt;stdio.h&gt;int main()&#123; printf(&quot;123\\tA\\n&quot;); printf(&quot;12\\tA&quot;); return 0;&#125; 输出： 12123 A12 A Day 9 类型转换 C语言的运算符2边出现不一致类型时会自动转换成较大的类型。 运算中整数型与浮点型的处理 整数型的除法运算是舍位运算，而不是四舍五入，如 int t; t=20/3;这里的结果t=6；浮点型的运算按精度要求四舍五入。 当运算中的两个数分别是浮点型和整数型是以浮点型的规则进行运算，当出现整数常数时，如3，可以写成3.0来表示浮点型格式。当算式中超过三个数时，从左到右分别按如上两位数的规则进行。 以下举例来说明一些情况： 首先说明各个数值的类型，其次举例说明结果。 整数型=浮点型/整数型： 这个是以浮点型来运算的，但是结果是整数型的，例20.0/3=6.66…，但由于结果是整数型的，进行舍位，结果为6； 浮点型（0.1f）=浮点型/整数型：浮点型规则运算，结果等于6.7； 浮点型=整数型/整数型：整数型运算，计算结果舍位，等于6.0； 整数型/整数型×浮点型，同级运算从左到右，这里先进行整数型的除法，再进行浮点型乘法，如11/4×10.0=20；因为整数除法会舍位，故11/4=2，2×10=20. float/float 进行运算，float自动转为double，所以结果是double; int/float 进行运算，float同样会自动转成double，所以int也会转成double，所以结果是double. 给我们的教训是我们在写程序时应注意变量类型的的定义，以及对精度有要求时尽量先计算浮点型，如果表达式最左边是浮点数，那么后面的算术运算都是最起码以浮点的规则进行计算。出现常数时用3.0这个书写形式定于为浮点型。 所有的浮点运算都是以双精度进行的，即使运算中只有 float 类型，也要先转换为 double 类型，才能进行运算。 字符型数据和short型数据在算术表达式中，一律转换为int型数据后，再参与运算。这一点和JAVA一样。 将一个double赋给float，先将双精度转为单精度，即只取6-7位有效数字，存储到float型变量的4个字节中，当double的数值大小不超出float的数值范围时，编译器也不会报错，只是IDE会给警告。比如： 12345678#include &lt;stdio.h&gt;int main()&#123; double a = 1.0; float b = a; printf(&quot;%f&quot;, b); return 0;&#125; 一样能执行 将一个float赋给double，数值不变，在内存中以8个字节存储，有效位数扩展到15位。 将一个占字节多的整型(不是浮点数)赋给一个占字节少的整型变量时，只将低字节(即低地址)原封不动地送到被赋值地变量(即发送截断)。 当表达式中存在有符号类型和无符号类型时所有的操作数都自动转换为无符号类型。因此，从这个意义上讲，无符号数的运算优先级要高于有符号数，这一点对于应当频繁用到无符号数据类型的嵌入式系统来说是丰常重要的。 对于printf，任何小于int的类型都会自动转为int，float会自动转为double，这也是为什么scanf读入double时需要%lf，读入float%f即可；而printf输出double和float都是%f，，因为输出时不管原来是float还是double，都会自动转为double输出，所以printf里面只有%f没有%lf。在有些系统中printf里用%lf也不会出错，但是尽量还是按照标准来。但scanf就不行，想输入short必须%hd，想输入longlong要%ld。 printf的%f说明符的确既可以输出float型又可以输出double型。 根据&quot;默认参数提升&quot;规则(在printf这样的函数的可变参数列表中 ，不论作用域内有没有原型，都适用这一规则)float型会被提升为double型。因此printf()只会看到双精度数。严格地讲，%lf在printf下是未定义的，但是很多系统可能会接受它。要确保可移植性，就要坚持使用%f。 对于scanf，情况就完全不同了，它接受指针，这里没有类似的类型提升。(通过指针)向float存储和向double存储大不一样，因此，scanf区别%f和%lf。 除了C语言的自动类型转换还有强制类型转换，但一般是大的往小的转才用到强制类型转换。比如 (int)10.2//把浮点数转为整数 (short)32//把int转为short 但是大转小有安全隐患，因为小的表达的数的范围比较小，可能存在溢出。 还要注意一点，类型转换只是临时性的，无论是自动类型转换还是强制类型转换，都只是为了本次运算而进行的临时性转换，转换的结果也会保存到临时的内存空间，不会改变数据本来的类型或者值。强制类型转换不是改变原有变量的值和类型，而是将新值赋给一个新的变量。比如 int i=32768; short s=(short) i; i并不改变 1234double a=2.0;double b=2.0;int i=(int)a/b;int j=(int)(a/b); i和j是不同的，i的意思是先把a转成int再去和b运算得到的结果依然是double。因为强制类型转换的优先级高于四则运算。 逻辑类型 又叫bool类型，实际上在C99之前没有bool类型，做关系运算时得到的结果是整数0或1，C89开始有雏形，C99确定一个类型叫bool，但它不是原生类型，需要包含一个头文件&lt;stdbool.h&gt;，才能使用bool，但是它在计算机内部实际上还是整数。比如： bool b =6&gt;5; bool a =2; //a就=2了 //这些都是合法的 逻辑运算 逻辑运算是对逻辑量进行的运算，结果只有0或1，关系运算是大于小于等于这些，但逻辑运算是或与非； 逻辑；量是逻辑运算的结果。 与(逻辑乘)：0&amp;&amp;1=0；0&amp;&amp;0=0；1&amp;&amp;1=1； 或(逻辑加)：0||0=0；0||1=1；1||1=1； 非：!1=0；!0=1； 表达x∈(4,6)不是4 &lt; x &lt; 6，而是4 &lt; x &amp;&amp; x &lt; 6，判断一个字符是否是大写英文字母则，‘A’ &lt;= x &amp;&amp; x &lt;= ‘Z’,X &lt; 0 || X &gt; 99。 赋值运算优先级永远是最低的，()永远是最高的，！由于是单目运算符所以优先级比加减乘除高，&amp;&amp;和||优先级比关系运算低。 短路；逻辑运算是自左向右进行的，如果左边的结果已经能够决定结果，就不会再执行逻辑运算符右边的计算。譬如： a6&amp;&amp;b1，此时如果a6为true，就不会比较b1。 a–6&amp;&amp;b+=1，此时如果a==6为true，就不会做b+=1。 对于&amp;&amp;左边是false就不做右边了 对于||左边是true右边就不做了 条件和逗号运算 条件运算符(还有关系运算符和逻辑运算符呢)：比如下面一段代码： if (count&gt;20) count=10; else count=11; 可以用下面的条件运算符代替 count=(count&gt;20)?count=10:count=11 这又是一个编程语言早期遗漏下来的问题。现在一般不要用，不易读。 逗号在C语言里是一个运算符，用来连接两个表达式，然后用右边表达式的值作为运算的结果。逗号运算符是所有运算符里面优先级最低的，比 = 还低， i=3+4,5+6 输出i=7, 5+6没有赋给任何变量。逗号运算符确保操作数被顺序地处理：先计算左边的操作数，再计算右边的操作数。右操作数的类型和值作为整个表达式的结果。左操作数只是为了副作用需要而被计算，它其值会被丢弃。 逗号运算符就在for循环里有用武之地。如果想在for的括号里放多个计算就可以用,比如： for (i=0,j=10;i &lt; j;i++,j–) Day 10 初见函数 如果一段程序里面出现很多串重复的代码，那么就叫代码复制，出现代码复制是程序不良的表现，因为将来要修改可能要改很多处才改得完。我们拿出重复的部分封装起来，用到时调用它即可。 函数的定义和调用 函数是一块代码，有一个名字，接收0或多个参数，做一件事情，并返回0或1个值。 注意最多只能返回1个值，这一点与python不同，python函数可以返回多个值。 12345678910#include &lt;stdio.h&gt;void sum(int begin, int end) // 函数头&#123; // 函数体 大括号一定要带 int i; int sum; for ( i = begin; i &lt; end; ++i) &#123; sum += i; &#125; printf(&quot;%d&quot;, sum);&#125; if 语句，while语句 后面只有一条语句时可以不加{}，但是函数体必须要用{}括起来。 sum是函数名，void英文单词是空虚的，顾名思义，就是函数不返回任何东西。sum后面跟的()是参数表，参数和参数之间用逗号分隔，即使函数不需要输入任何参数也要带()， 从函数中返回 return停止函数的执行，return有2种写法： return; return 表达式 //单一变量也是1个表达式 1个函数里面可以有多个return语句，也就是多个出口，但是最终只能返回1个值，但多个出口有个问题就是如果以后要修改，很可能要疲于奔命去修改，所以尽量做成单一出口。 函数返回的值， 我们可以把它赋给1个变量， 也可以把它当作另一个函数的参数放到()里 甚至可以直接调用，返回值丢掉，比如：function(a,b)，因为我们有时只是想要函数在执行本身产生的其它东西但不需要返回值。JAVA里的方法如果有return返回值，这个方法也可以直接调用，返回值不赋给任何变量，直接丢掉，也是没问题的 void 函数名(参数表) 这种不返回值得函数不能使用带值的return，可以是不带值的return; 或者直接不要return。但如果函数有返回类型则必须有返回值的return 可以不写return； 调用的时候不能做返回值的赋值； 如果函数名前面有返回类型，比如int double，**那就必须使用带值的return。**这一点和java一样 函数原型 C语言的编译器是自上而下顺序分析代码，看到main()函数里面的函数调用时，编译器需要知道函数需要输入几个参数，返回什么数，这样才能检查函数调用是否正确，所以函数定义要写在main()函数前面。 LLVM是一个检查严格的编译器，如果你把函数定义放在main()函数底下，会有warning和error。编译器在main()里碰见未被提前声明的函数会去猜那个函数长这样：int 函数名(int, int)，但是编译器继续往下执行一旦碰到后面的函数定义就会发现和前面猜的函数不一样，所以会给error。 但是我们又希望我们一打开这个程序就能看到main()函数，就能看到这个程序的大概，具体的函数定义这些细节我们想放在下面去看，怎么办？我们可以把函数头复制粘贴到main()前面并加上分号，这个叫函数的原型声明，函数定义放在main()下面， 1234567891011121314151617181920#include &lt;stdio.h&gt;void sum(int begin, int end); // 函数的原型声明int main()&#123; printf(&quot;123\\tA\\n&quot;); printf(&quot;12\\tA&quot;); return 0;&#125;// 函数定义void sum(int begin, int end) // 函数头&#123; // 函数体 大括号一定要带 int i; int sum; for (i = begin; i &lt; end; ++i) &#123; sum += i; &#125; printf(&quot;%d&quot;, sum);&#125; 声明不是函数，声明只是在编译器碰到main()之前告诉编译器说，这个函数长这样，有几个参数，参数都是什么类型，要返回什么数，编译器再在main()里碰到这个函数调用时就不自己猜了，而是根据函数原型声明。编译器读到下面的函数定义时，还会判断之前的函数声明和它的函数定义对不对得上，所以函数原型的目的有2： 当编译器在main()里碰见函数调用时，函数原型会告诉编译器这个函数的名称，函数的参数，函数返回的类型 碰到函数定义时，还会检查函数原型和定义能不能对得上。 参数传递 调用函数时，给的参数类型和函数定义的参数类型不匹配，则编译器会偷偷进行类型转换再传递给函数，但这可能不是你所期望的，所以这是C语言传统上最大的漏洞，后续的语言，C++/java 再这方面就很严格。 12345678910111213141516171819#include &lt;stdio.h&gt;void swap(int a, int b); // 函数的原型声明int main()&#123; int a=5; int b=6; swap(a,b); printf(&quot;a=%d,b=%d&quot;, a,b); return 0;&#125;// 函数定义void swap(int a, int b) // 函数头&#123; // 函数体 大括号一定要带 int t=a; a=b; b=t;&#125; 输出是 a=5,b=6，我们发现，这样的函数交换不了a和b的值，这是因为C语言在调用函数时，永远只能传值给函数，虽然函数里面的a和b和函数外面的a和b重名但没有任何关系，只是值一样。每个函数有它自己的变量空间，内部的参数也位于这个独立的空间中，和其它函数没有关系。在main()里头，swap()里面的a和b不存在。 有些教科书里面会说，函数原型和定义的参数表里面，叫形式参数，在函数调用里面我们给它的参数叫实际参数，形参和实参的概念来自于人类第一个高级编程语言FORTRAN，但现在我们一般把形参叫参数，实参叫值，因为C语言函数本质是传值而不是传参数。这一点和JAVA一样，JAVA里，全局变量(比如属性)，可以不赋值直接使用，比如属性不初始化，会默认给0或者null；但是局部变量必须赋值后才能使用。因为没有默认值，否则编译器会报错。 本地变量 函数每一次运行就会产生一个独立的变量空间(比如递归，每重复运行一次就开辟一块变量空间)，在这个变量空间的变量是这一次函数运行所独有的，我们称之为本地变量(局部变量)。函数结束运行，变量空间和它的本地变量消失不见。 定义在函数内部的变量都是本地变量，目前为止我们所学过的变量都是定义在函数内部的变量，参数表里的参数也是本地变量。 生存期：变量出现到消亡的一段时间。 作用域：在什么范围内可以访问这个变量。 对于本地变量而言，其生存期和作用域的答案是统一的，即大括号{}内————块。 本地变量是定义在块内的 它可以是定义在函数的块内； 它也可以是定义在语句的块内，譬如 if (a &lt; b){ int i=10; } printf(&quot;%d&quot;,a); 出了if语句的大括号，i就不存在了。 甚至可以随便拉一对大括号来定义变量 { int i=10; } printf(&quot;%d&quot;,a); 出了大括号，i就不存在了。 基于此，可以在一些程序代码中间平白无故地去添加一个{}，并在其中敲一些可以做当前输出的调试代码，来查看代码运行到此处各个变量什么的状态是什么样的，由于{}存在，所以里面都是本地变量，并不会给外面的变量造成影响， 程序进入这个块之前，其中的变量不存在，离开这个块，其中的变量就消失了。 块外面定义的变量在块里面依然有效，譬如： int a=1; { int i=10; } 或 { int a=10; { int i=1; // 外层的变量对内层就是可访问的 } } 如果在块里面定义一个和外面同名的变量，则编译器在块里面时，碰到块里面的同名变量后，同名变量会把外面变量覆盖掉，但碰到之前，即使是在块内也不会覆盖。出了块，块里面的变量就会消失。JAVA里也一样，java里全局变量在某个局部同名变量的作用域内也会被局部同名变量覆盖。需要注意的是，同一个作用域内不能定义两个同名变量，无论C还是JAVA。 本地变量不会被默认初始化，在 main 函数中定义的变量也一样，如果本地变量不初始化就使用它，它的值就是内存里面原来在的那个值，所以安全的做法是在第一次使用本地变量之前要初始化它。 几点说明: 在 main 函数中定义的变量也是局部变量，只能在 main 函数中使用；同时，main 函数中也不能使用其它函数中定义的变量。main 函数也是一个函数，与其它函数地位平等。 在所有函数外部定义的变量称为全局变量（Global Variable），它的作用域默认是整个程序，也就是所有的源文件，包括 .c 和 .h 文件。 123456789101112int a, b; //全局变量void func1()&#123; //TODO:&#125;float x,y; //全局变量int func2()&#123; //TODO:&#125;int main()&#123; //TODO: return 0;&#125; a、b、x、y 都是在函数外部定义的全局变量。C语言代码是从前往后依次执行的，由于 x、y 定义在函数 func1() 之后，所以在 func1() 内无效；而 a、b 定义在源程序的开头，所以在 func1()、func2() 和 main() 内都有效。 全局变量也有自己的作用域，定义在底下的全局变量，上面不能用； extern 关键字可以把变量的作用域扩展到其他文件。加一个static前缀，则其他文件不能用这个全局变量，只能在本文件用，加了extern也不行。 在函数返回类型前面加一个static前缀，也是只能本文件调用该函数，比如本文件的调试函数。 不建议过多地使用全局变量或者静态本地变量，参考丰田汽车的案子， C语言是一个模块化语言，是由各个功能单一的模块组成的，改一个，其他模块就不用跟着改。如果功能不单一。会让模块之间的耦合度增加，修改一个模块势必造成其他模块跟着修改，造成鲁棒性下降。在划分模块时要求模块的内聚性强，与其它的模块耦合性弱。这是一个原则。但是全局变量会造成模块之间的耦合增强，鲁棒性下降。 如果在函数中引入全局变量，并且把函数移动到另一个文件去，还要考虑把全局变量移过去。并且，即使移动过去了，若该全局变量和新文件中的某一个变量重名，会出问题。这就降低程序的可移植性和通用性。 会长期占用内存，内存浪费； 全局变量的值很容易变的不可控，不知哪个地方就给你改个值，最后你不知道它的值是从哪赋来的。会降低程序的清晰度。 CPU结构 运算器ALU 一组寄存器(PC、IR、PSW、DR、通用寄存器等) 控制器CU 中断系统 存储系统(速度依次递减) 寄存器(一级) cache(二级) Memory(三级) I/O(四级) C的存储类别 static 放全局变量，存储在内存中的静态存储区；比如static int i = 0; 加了这个前缀，在内存上的位置就不同；从分配开始，到程序运行结束，都不释放。静态局部变量只初始化一次，不初始化它，会自动初始化为0。 123456789101112#include &lt;stdio.h&gt;int main()&#123; for (int i = 0; i &lt; 3; ++i) &#123; auto int a = 1; static int b = 1; a++; b++; printf(&quot;a = %d\\nb = %d\\n&quot;, a, b);&#125; return 0;&#125; 输出： 123456a = 2b = 2a = 2b = 3a = 2b = 4 只在第一次进入循环时，b被初始化为1，后面的每一次循环，b都不在初始化为1，而是保留上次离开循环的值，但是a每进入一次循环都会被重新初始化为1 auto 一般放局部变量；定义局部变量可以确缺省Auto，比如 auto int i = 0; 一般都默认auto。 寄存器变量，把变量放在寄存器，这样速度就更快了。一组寄存器，有通用寄存器，专用寄存器，专用寄存器我们一般不能用，普通寄存器太少了，不能占多了，会影响整个系统的运行，所以一般不把变量定义在寄存器 全局的，也放在静态存储区；也可以用static声明，但没必要，因为已经放在静态存储区了。有stastic 全局变量，也有stastic 局部变量。静态本地变量就是特殊的全局变量。 函数庶事 当我们的函数定义时就确定不接收参数了，那我们写成 void 函数名(void)，还是写成 void 函数名() 呢？如果写成void 函数名()，则表示参数表要不要接收参数不知道，并不表示一定不接收参数，所以这样的函数原型声明了个寂寞，到了函数调用的时候，如果我们不小心传了参数，编译器会猜参数的类型是int，很可能给出的结果是错的，所以如果确定函数的参数表里没有东西，就用 void 函数名(void)。 另外函数参数表里如果有多个参数，要用逗号隔开，注意，这里的逗号仅仅是标点符号，不是逗号运算符。f(a,b)中的逗号是标点符号，传了2个值；f((a,b))中的逗号因为有()存在，所以是逗号运算符，最后只传了b一个值进去。 C语言不允许函数嵌套定义，允许在一个函数定义里面放另一个函数的声明，但不允许放另一个函数的body。这一点和java也类似，JAVA里的方法体里也不能再嵌套放另一个方法体。 return (表达式) 这么写也不错，表达式加个()也是表达式，但是这么写会有人误解这是一个函数，所以不要这么写。 好了，学了函数，我们突然想起来了一开始学C接触到的int main()，我们一直不知道它是干嘛的，现在越看它越像个函数，其实，它就是个函数。写出int main(void) 也没有问题。 main()函数虽然是我们写的代码当中第一个被执行的代码(C语言从main()函数开始执行)，但不是这个程序第一个运行的代码，在main()之前还运行了其它东西，这些东西为程序能成功运行而做准备，准备完后会来调用main()函数。所以main()结尾的 return 0，是有意义的，它要把这个0返回给调用它的地方，返回给一小段代码，那一小段代码会检查并报告给你的操作系统，报给Windows,报告给Unix。传统上，一个应用程序如果返回0则表示正常的运行结束，如果返回任何非0值则表示这个运行过程中出现错误。如果main 函数的最后没有写return 语句的话，C99 规定编译器要自动在生成的目标文件中(如exe 文件)加入return 0; ，表示程序正常退出。 Day 11 初试数组 我们之前做了这样一个程序，如何写一个程序计算用户输入的数字的平均数。代码见下： 12345678910111213141516#include &lt;stdio.h&gt;int main()&#123; //计算average int sum=0; int x=0; scanf(&quot;%d&quot;, &amp;x); int n=0; while (x != -1)&#123; sum += x; scanf(&quot;%d&quot;, &amp;x); n++; &#125; printf(&quot;average=%f&quot;, (sum*1.0)/n); return 0;&#125; 每输入一个数就加起来，这样我们不需要记录每一个数，但是如果问题改成，写一个程序计算用户输入的数字的平均数，并输出所有大于平均数的数，我们就不得不存下每一个输入的数，但是我们需要定义多少个int变量才能记录下每一个数，是不是觉得太麻烦了？所以引入新的数据类型——数组。数组顾名思义就是很多数的组合。 int number[100]; 定义了一个新的变量，这个变量是一个数组(不是int)，这个变量名字叫做number，这个数组里的每一个单元都是一个int，该数组大小是100即可以放100个int。 123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;int main()&#123; int x; double sum=0; int cnt=0; int number[100]; scanf(&quot;%d&quot;, &amp;x); while (x!=-1)&#123; number[cnt]=x; // &#123; printf(&quot;cnt=%d\\n&quot;, cnt); for (int i = 0; i &lt;= cnt ; ++i) &#123; printf(&quot;%d\\t&quot;, number[i]); &#125; printf(&quot;\\n&quot;); &#125; // sum++; cnt++; scanf(&quot;%d&quot;, &amp;x); &#125; if (cnt&gt;0)&#123; printf(&quot;%f&quot;, sum/cnt); for (int i = 0; i &lt; cnt; ++i) &#123; if (number[i]&gt;sum/cnt)&#123; printf(&quot;%d\\n&quot;, number[i]); &#125; &#125; &#125; return 0;&#125; 字符型数组是数组元素为char类型的一种数组。凡是适合数组的定义和赋值，也都适合于字符数组。由于C语言没有提供字符串类型(JAVA有String类型)，字符串一般用一维字符数组来存放，而二维字符数组可以存放多个字符串。 数组的使用 数组这样定义：&lt;类型&gt; 变量名称[元素数量]，类型是指元素的类型，必须有[]，没有方括号就是普通的变量。元素数量必须是整数。C99之前，元素数量必须是编译时确定的字面量，但C99以后就可以用变量来定义数组大小了，比如 int number[a] 但数组大小一旦确定下来大小就不能再变。 容器是一个放东西的东西，即容器。容器是现代编程语言中非常重要的一个基本概念，现代的编程语言都应该提供某种形式的容器。 数组就是一种容器，其特点是： 其中所有的元素具有相同的数据类型； 数组大小一旦确定就不能改变； 在内存里，数组的元素是紧密连续依次排列的； 数组不是C语言才有的，FORTRAN就有数组了，但是数组的索引从0开始编号是从C语言开始的，之所以这么干是因为希望当年C语言的编译器可以做的很简单，从0开始编译器可以省很多事情，从那以后，C-like语言都是从0开始索引。 C语言的编译器和运行环境都不会检查下标是否越界，无论是对数组单元读还是写。一旦数组越界，可以会导致程序崩溃，也可能无事发生，这也就是有时候在我的电脑上程序运行成功，在你的电脑上就不行了。有效下标就是0-(数组大小-1)，int a[0] 可以存在但无用。 数组和本地变量一样，不会被默认初始化，所以为了安全，一定要在使用它之前初始化它，初始化方法比较麻烦，写循环遍历每一个元素给它赋值。 数组运算 我们在定义数组时有2种方案： int number[a] 我们这种定义不能去初始化它，它也不会被默认初始化，所以后面我们想使用它还得写个循环去初始化它。 int a[]={1,2,2,4,5}; 这是第2种方案，叫数组的集成初始化，我们没有给数组的大小，我们让编译器替我们去数。如果改成：int a[10]={2}; 则数组的第一个元素为2，剩下9个元素均为0，所以我们使用 int a[10]={0}; 来初始化一个数组让其所有元素均为0，就不用再写循环初始化了。 另外我们还可以这样，int a[10]={[0]=2,[2]=3,6}; 这样的意思是创建一个10个元素的数组，索引为0的元素赋2，索引为2的元素赋为3，索引为4的元素赋为6，其余元素均为0，但这种方式仅C99以后才支持. a[0] (a是一个数组) 这就是一个变量，和正常的变量一样去使用它。 运算符 sizeof()，它可以给出某个类型或者某个变量在内存中占据的字节数,这个运算符也适合数组。 int a[10]; 则 sizeof(a)得到的是40，即一个int占4个字节，10个元素共占40个字节。这样的话，我们就可以用 sizeof(a)/sizeof(a[0]) 来表达数组a的元素个数，这么做的好处是一旦我们修改数组中初始的数据，我们不需要修改遍历的代码。 int a[10]={0}; int b[]=a; 数组变量不能直接这样赋值，讲指针的时候再细讲。所以如果想把一个数组的所有元素交给另一个数组则必须采用遍历，a[i]=b[i] 是可行的，这也是唯一一个把一个数组完全赋给另一个数组的方法，别无他法。 程序员在写循环时通常都是从0开始到 &lt; 某个数，很少能够看到 &lt;= ， 特别需要注意的是，数组作为函数参数时，我们往往需要另一个参数来传入数组的大小，为什么呢？因为数组一旦传入参数，我们便不能再用 sizeof() 来计算数组元素的个数了，至于为什么要到指针再扯。 int a[10]={0}; int cnt=0; a[cnt++]=i; 最后一句的意思是，我们把当前的i赋给cnt所在位置的元素，同时cnt本身+1，下一次的 a[cnt] 已经是下一个位置的元素，下一次再赋值自动的就是赋给下一个位置的元素。 二维数组 我们上面讲的都是一维数组，C语言除了做一维数组还能做二维三维更往上的。 二维数组通常理解为一个矩阵，对于二维数组的索引，C语言和线代里面对矩阵的索引是一样的，int a[3][5] 是指第3行第5列的元素。int a[3,5] 此时逗号是个运算符，即等价为 int a[5] ，所以这样写并不是一个正确的索引二维数组的方式。 二维数组也可以做集成初始化，例如： int a[][5]={ {0,1,2,3,4}, {5,6,7,8,9} }; 编译器只能数一维的个数，所以列数不能省，和一维数组一样，如果有省略的则补0。有些人用不带{}的一连串的数字也能定义二维数组，因为内存中就是这样存的，实际存储是一维的，线性的。二维数组是按行连续存放的，第一行存完，接着存下一行。 二维数组初始化： int a[3][3] = {1，2，3，4，5，6，7，9，5}; 编译器会根据列数去自动划分。 int a[][3] = {1，2，3，4，5，6，7，9，5}; 编译器会根据列数去自动划分行。 int a[3][3] ={ {1}, {5}, {9} }; 则等价于 int a[3][3] ={ {1, 0, 0}, {5, 0, 0}, {9, 0, 0} }; int a[3][3] ={ {1}, {5} }; 则等价于 int a[3][3] ={ {1, 0, 0}, {5, 0, 0}, {0, 0, 0} }; int a[3][3] ={ {1}, {}, {5} }; 则等价于 int a[3][3] ={ {1, 0, 0}, {0, 0, 0}, {5, 0, 0} }; int arr1[2][3] = {0}; /* 所有元素都初始化为0 */ int arr1[2][3] = {1}; /* 只有arr1[0][0]为1，其他所有元素都初始化为0 */ char b[10][5] = { //这是一个二维数组,所以第2个[]里的数不能省,编译器不会替我们去数. b[][5]是可以的, 但b[10][]不行 “ling”, “yi”, “er”, “san”, “si”, “wu”, “liu”, “qi”, “ba”, “jiu” &#125;; 二维字符型数组也可以这样初始化, 'ling'后面默认补个'\\0', 'yi'后面补仨这样, 输出的话直接,printf(&quot;%s&quot;, b[0]); 即可 char *b[] = { //这是一个一维数组,所以[]里面不用加数字,编译器会替我们去数. “ling”, “yi”, “er”, “san”, “si”, “wu”, “liu”, “qi”, “ba”, “jiu” &#125;; 这不是二维字符型数组,这是一个一维指针数组, 其中每一个指针指向 常量池的一个字符串.定义字符串有用数组定义和指针定义两种方式, 一个const在 * 号前,一个在 * 号后,上一种定义二维字符型数组,就是把字符串放在这里, 与数组名放在一起, 9这种方式就是把字符串放在常量池,这里只放指针. 输出的话也是直接,printf(&quot;%s&quot;, b[0]); 即可 取地址运算 scanf里面必须要加 &amp; ，否则运行会报错，&amp; 其实是C语言的一个运算符，它运算什么呢？它用来获得变量的地址，因此它的操作数必须是变量。&amp;(i++) &amp;(a+b)，这都会报错，必须是一个确定的变量才行。变量地址是什么？我们对变量的定义是：变量是保存数据的地方，C语言的变量是放在内存里的，比如定义一个 int 变量，它存在内存里并占用4个字节，它存在那个地方，那个地方就有个地址，所以 &amp; 运算符就是把变量的那个地址拿出来告诉你。 我们想看看这个地址长什么样，于是我们用这样的代码： 1234567891011#include &lt;stdio.h&gt;int main()&#123; int i=0; printf(&quot;0x%x\\n&quot;, &amp;i); printf(&quot;%p\\n&quot;, &amp;i); int p; p=(int)&amp;i; printf(&quot;0x%x\\n&quot;, p); return 0;&#125; 输出结果是： 1230xd99ffa98000000c2d99ffa980xd99ffa98 我们发现用 %p 和转成int型再用 %x 输出结果是一样的，这是因为我们用32位架构编译，如果我们换成64位架构再来一遍，则转成int输出和%p输出便不一样了，因为在64位架构下编译，int占4个字节，&amp;i占8个字节。但是在32位架构下编译，int占4个字节，&amp;i也占4个字节。所以这个变量的地址的大小，它的数据类型，和int是否相等，取决于编译器，取决于64位还是32位架构，地址和整数并不是永远相同的，所以我们要用printf输出一个地址，我们要用%p而不是当成int型输出。 scanf里面必须要加 &amp; ，否则运行会报错，但是我们调用scanf时忘记加&amp;，传入int型编译也能过，比如 int i=6; scanf(&quot;%d&quot;,i); 虽然编译不报错但是运行会报错，是因为在32位架构下，int和地址一样，scanf把你传入的int值当作了地址，所以编译不出错，之所以运行会报错是因为，向错误的地址6(i值而不是i的地址)写入了你输入的东西，6那个地方很小，那个地方有很重要的东西，不可能被写入。 123456789#include &lt;stdio.h&gt;int main()&#123; int i=0; int p; printf(&quot;%p\\n&quot;, &amp;i); printf(&quot;%p\\n&quot;, &amp;p); return 0;&#125; 输出是： 000000abc29ff6fc 000000abc29ff6f8 在十六进制中，上面两个地址之间差了4，而我们知道在32位架构下，int就是4个字节，因此我们得知，两个变量i和p在内存中存放的位置是挨着的，所以两个变量的地址之间相差了4个字节，但是我们注意到 i 是fc，p 是f8,也就是说i是先定义的变量但所储存的位置在后定义的p上面，i在更高的地方，这俩变量都是本地变量，它们分配在堆栈里(stack)，在stack里分配变量是自顶向下分配，所以先写的变量地址更高，但它俩是紧挨着的。 1234567891011#include &lt;stdio.h&gt;int main()&#123; int a[10]; printf(&quot;%p\\n&quot;, &amp;a); printf(&quot;%p\\n&quot;, a); printf(&quot;%p\\n&quot;, &amp;a[0]); printf(&quot;%p\\n&quot;, &amp;a[1]); printf(&quot;%p\\n&quot;, &amp;a[2]); return 0;&#125; 输出： 12345000000af869ffb90000000af869ffb90000000af869ffb90000000af869ffb94000000af869ffb98 我们直接拿数组a当作地址输出，编译是过的。我们做了一个数组，里面有10个int，从输出来看 &amp;a=a=&amp;a[0]，而&amp;a[2]和&amp;a[1]和&amp;a[0]之间逐步差4个字节。 指针 我们前面看到取地址符&amp;这么花，可以看到数组里面元素的地址怎么排列的等等，有什么用呢？我们想一想scanf()，它作为一个函数，需要在参数表里传入变量的地址，说明scanf内部有一个东西可以接收外部传入的地址并保存之。我们前面试过，如果你把一个地址交给一个整数，这个方法不靠谱，因为整数和地址不见得永远都是相同类型的，那么什么类型可以接收取地址运算得到的那个地址呢？答案是指针。一个指针类型的变量，就是用来保存地址的变量。我们通常用p来命名指针变量因为，p可以看作pointer的缩写， int* p = &amp;i int*表示后面的变量p是一个指针，且指向一个int变量。我们原本有个int型变量i，然后又定义一个指针变量p，假设i放在0x2000的地方，则通过上面的表达式，p的值就被赋为0x2000，此时我们称这种情况为：p指向i。所以当我们在说p指向i时，我们实际的意思就是p的值是i那个变量的地址。 int* p,q; int *p,q; 这两行是等价的，都表示p是一个指针指向一个int，q是一个普通的int型变量。所以实际上，*是加给p，p才成为指针的，而不是加在int上的。不管 * 靠近p还是靠近int，我们说 *p 是指向一个int于是p成为一个指针，而不是说p是 int * 这种类型。如果想表达p和q都是指向int的指针，则应该按下面表达： int * p,* q 当然，千万别解引用未初始化的指针，否则会引起严重错误。 普通的变量，放的内容就是实际的值，但指针变量里不会放实际的值，我们只会放别的变量的地址，int* p，里面只会有别的int型变量的地址。 当我们想往函数里传入&amp;i的值时，我们在参数表里只能用指针类型接收，而不能用int型接收，因为不同架构下，地址不一定等于int。 当参数表里需要指针作为参数时，e.g. void f(int* p); 当我们调用这个函数时，我们要交给它一个地址，比如&amp;i，而非变量，这就意味着在函数里面我们便可以掌握外层变量的地址，我们如果只往函数里传普通变量，则函数只能掌握外层变量的值，和外层变量没什么关系了，所以通过传外层变量的地址进函数，就使函数拥有访问外层变量的能力了，访问意味着读和写。*时一个单目运算符，用来访问指针的值所表示的地址上的变量， *p可以做左值也可以做右值， 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;void f(int *p);void g(int k);int main()&#123; int i=6; printf(&quot;&amp;i=%p\\n&quot;, &amp;i); //不能调用g()，因为g()不能接收&amp;i f(&amp;i); g(i); return 0;&#125;void f(int *p)&#123; printf(&quot;p=%p\\n&quot;, p); printf(&quot;*p=%p\\n&quot;, *p); *p=26;&#125;void g(int k)&#123; printf(&quot;%d\\n&quot;, k);&#125; 输出： &amp;i=0000001a671ff71c p=0000001a671ff71c *p=0000000000000006 26 C语言函数调用时发生的永远是值的传递，虽然能通过指针改外层的变量，但是依然是传递的地址的值。 赋值号左边的叫左值，之所以不叫变量，那是因为赋值号左边的那一坨，是表达式计算的结果，而不是变量，比如： a[0]=2; *p=3; *是个运算符， *p表示我要取得p上面存的地址所代表的那个变量，所以这是一个表达式运算结果，数组的那个[]，也是一个运算符，取里面元素的一个运算符，所以a [0]不是变量， *p也不是变量，他们是表达式运算的结果，它本质上是值，所以叫左值。同理，出现在赋值号右边的叫右值。 *和&amp;是一对相互反作用的运算符。比如 ： 12345int a, b;int *p, *p1;p = &amp;a;b = *(&amp;a); // 等价于 b = ap1 = &amp;(*p); //等价于 p1 = p 因此我们可以看到这是互逆的一对运算符； 用变量名直接方法叫直接访问；用指针去访问叫间接访问；* 号又叫间接访问运算符。在定义指针的时候加 * 号，并不会间接访问它指向的变量，在后面加 * 号才会表现出间接访问的功能。 指针变量不能直接赋值，比如： int *ptr; ptr = 0x111111 必然是错误的 只有在强制转换右值为指针所声明类型后才能赋值，如ptr = (int *)0x111111 如果是char *ptr，赋值的时候注意用ptr = (char *)0x111111就好了。 指针的使用 讲了那么多指针，有什么用呢？ 指针应用场景一： 还记得之前我们写的swap()函数吗，我们企图写个函数能交换两个变量的值，但是发现函数永远只能传值，不能改变外面的变量的值，所以失败了，但现在我们能用指针去实现。 1234567891011121314151617#include &lt;stdio.h&gt;void swap(int *pa, int *pb);int main()&#123; int a=1; int b=2; swap(&amp;a,&amp;b); printf(&quot;a=%d, b=%d&quot;, a,b); return 0;&#125;void swap(int *pa, int *pb)&#123; int t=*pa; *pa=*pb; *pb=t;&#125; 指针应用场景二： 我们前面学到，C语言函数不像python函数可以返回多个值，C语言函数最多return 1个值或者不返回值。我们如果想用C语言函数返回2个或2个以上的值，可以用指针做到。JAVA里面一个方法也是最多返回一个值，JAVA里面如果想返回多个值，可以返回一个数组，一个List等。其实python函数表面上可以返回多个值，本质上也是最多返回一个值，只不过利用了tuple的自动打包，将多个值打包成单个tuple返回。 指针应用场景三： 函数返回运算的状态，结果通过指针返回。 函数在运算中可能会出错，常用的套路是让函数返回特殊的不属于有效范围内的值来表示出错。在C语言的标准库里，和文件相关的操作我们会看到大量的例子：这些函数要么返回-1，要么返回0，用来表示说这些操作没成功，但是如果你构造的函数，返回任何数值都是有效的结果，都表示函数成功运行下来了，那么就没办法通过返回值来表达运行是否出问题了，此时需要分开返回，往往采用运行状态用return返回，需要返回的值通过指针来返回。在C我们只能用这种方式来做，但是在后续语言比如C++、Java，可以通过异常的机制来解决这样的问题。 指针应用场景四： 需要传入较大数据时，比如向函数传数组，可以传指针节省空间和时间。 指针应用场景五： 需要动态申请内存时。 使用指针最常见的错误是，定义了指针变量，还没有指向任何变量，就开始使用指针。例如： int *p; int k=12; *p=12; 所有的本地变量都不会有默认的初始值，所以p里面现在是一些乱七八糟的值，可能会指向一片莫名其妙的地方，所以再说 *p=12 时是在说向那片莫名其妙的地方写入12，那个地方侥幸可以被写入就不会出错。那个地方如果是个不能被写入的地方，那程序就会崩溃， 指针与数组 数组是具有相同类型的结合。 字符型数组在计算机内部用其对应的ASCII码值进行存储。 一般用&quot;&quot;引起的字符串，不用数组保存时，一般都被直接编译到字符常量区，并且不可被修改，这一点和JAVA的String类一样 int a[5]; 我们前面已经知道，对于数组a，有 &amp;a=a=&amp;a[0] ，数组名 a 一般情况下代表数组首元素的地址(除非是sizeof(a)等特殊情况)，即 &amp;a[0]==a，而整个数组的地址需要取地址运算符&amp;才能得到，为 &amp;a 。数组名和数组首元素地址一般情况下可以视为相同，但是，数组的地址虽然和前面两个数值上相同，但概念不同，代表的不是同一个东西，&amp;a 代表整个数组在内存中的地址。a 与 &amp;a 的步长不一样，a代表的是数组首元素的地址，也是数组的首地址，a加1等价于加一个数组元素类型的长度；&amp;a代表的是整个数组的地址，加1等价于加整个数组的长度。首地址+1得到的是跳过整个数组的地址，首元素地址+1得到的是下一个元素的地址。 下面的几行代码可以清楚地看出数组名就是该数组首元素的地址。 1234567891011121314151617181920212223242526272829303132333435363738394041int main()&#123; int a[5] = &#123;1, 2, 3, 4, 5&#125;; int *p = &amp;a[0]; printf(&quot;%p\\n&quot;, a); printf(&quot;%p\\n&quot;, a + 0); printf(&quot;%p\\n&quot;, a + 1); printf(&quot;%p\\n&quot;, a + 2); printf(&quot;%p\\n&quot;, a + 3); printf(&quot;%p\\n&quot;, a + 4); printf(&quot;\\n&quot;); printf(&quot;%p\\n&quot;, p); printf(&quot;%p\\n&quot;, p + 0); printf(&quot;%p\\n&quot;, p + 1); printf(&quot;%p\\n&quot;, p + 2); printf(&quot;%p\\n&quot;, p + 3); printf(&quot;%p\\n&quot;, p + 4); printf(&quot;\\n&quot;); printf(&quot;%d\\n&quot;, *a); printf(&quot;%d\\n&quot;, *(a + 0)); printf(&quot;%d\\n&quot;, *(a + 1)); printf(&quot;%d\\n&quot;, *(a + 2)); printf(&quot;%d\\n&quot;, *(a + 3)); printf(&quot;%d\\n&quot;, *(a + 4)); printf(&quot;\\n&quot;); printf(&quot;%d\\n&quot;, *p); printf(&quot;%d\\n&quot;, *(p + 0)); printf(&quot;%d\\n&quot;, *(p + 1)); printf(&quot;%d\\n&quot;, *(p + 2)); printf(&quot;%d\\n&quot;, *(p + 3)); printf(&quot;%d\\n&quot;, *(p + 4)); return 0;&#125; 输出： 1234567891011121314151617181920212223242526270000003c957ff7800000003c957ff7800000003c957ff7840000003c957ff7880000003c957ff78c0000003c957ff7900000003c957ff7800000003c957ff7800000003c957ff7840000003c957ff7880000003c957ff78c0000003c957ff790112345112345 但是万万不可做 a++ 或者 a += 1；这种游戏，因为数组名是const指针，不可被改变。 a[n] 本质上就是 *(a + n) 数组名一般可以看作一个常量指针，即决定了在表达式中数组名只能作为右值使用。但数组名始终不是指针。 只有在下面2种场合中数组名不能看作常量指针： 数组名作为sizeof()操作符的参数时，得到的是整个数组在内存中占用的空间。 数组名作为&amp;运算符的参数。 以上两种情况，a 被看作整个数组(整个连续的空间)，而非数组名。 所以我们之前说： int a[10]={0}; int b[]; int p=a; b=a; b=a之所以不行，就是因为数组名 b 是一个const指针，即b创建出来代表这个数组，就不能被改变了。因此赋值号左边永远不可能是已经固定了长度的数组，只能使用int。int *p=a; 正常的指针还是可以被赋予数组名的。 数组名不包含数组的长度信息。 我们都知道，C语言函数永远传的是值，那么我们把一维数组传到函数里，那函数接收到的是什么东西？答案是，函数会接收到一个整型指针。其中的原因多数教科书都有做解释。因为数组占用的空间往往很大，如果要拷贝赋值到形参中，每次调用函数都需要很长时间做传参拷贝，因此C语言做了妥协，只传递数组的首元素地址给形参。可见，func(arr)和func(&amp;arr[0])是等价的。对于形参声明，int a[]和int* a也是等价的，只不过int a[]的写法更容易让人看出是个数组。此外，若写int a[5]，这里的5也没用，哪怕写100也没用，都与int*a等价，因为编译器只传递了首地址，它会无视这里的长度。因此数组作为函数参数时，我们往往需要另一个参数来传入数组的大小，数组一旦传入参数，我们便不能再用 sizeof() 来计算数组元素的个数了，现在我们知道了原因，因为传入数组的是数组名也就是数组首元素的地址也就是一个常量指针，sizeof()出来的是一个地址的大小是一个指针的大小而不是整个数组的大小。 所以如果您想要在函数中传递一个一维数组作为参数，您必须以下面三种方式来声明函数形式参数，这三种声明方式的结果是一样的，因为每种方式都会告诉编译器将要接收一个整型指针。 void function(int *arr) void function(int a[]) // 使用方括号 [] 声明函数数组参数的一个优点就是可读性好，它可以显著地标识出函数将该参数作为指向数组的指针。 void function(int a[5]) // 当使用数组来声明函数参数时，方括号 [] 内的任何常量表达式都会被忽略。就函数而言，数组的长度是无关紧要的，因为 C 不会对形式参数执行边界检查。也就是a[5] 中的5，改成6改成7随便改成其它正整数都可以。这个[]括号仅仅比表明这是一个指针。 我们在函数外定义一个数组： int a[10]; 然后在底下写个函数： void function(int a[]); { a[0]=1000; } 再将a数组传给函数，则我们发现在函数里面改函数的元素的值，对函数外面的a生效，这与我们前面了解到的普通变量不一样，我们很容易想到，数组传给函数，传进去的其实是个地址，接收这个地址的是个指针，就等价于：把 &amp;a 传给： void function(int *a); { a[0]=1000; } 但是我们疑惑的是，根据我们之前学的int型变量的指针传入函数，不应该是这样才能在函数体里操纵指针来改外面的值吗？ void function(int *a); { *a[0]=1000; // 我们想用 *a来表示外面的那个数组，现在为什么不加 * 号就行？ } 原因是 [] 这个运算符可以对数组做也可以对指针做，就是这么规定的，不加 * 就可以这么干。而 *a，是数组 a 的首元素。 int min=1000; int *p= &amp; min; printf(&quot;%d&quot;, *p); printf(&quot;%d&quot;, p[0]); 输出都是1000，因此我们得知，p[0]实际上就是相当于 p[0]，就是(p + 0)，在有[]出现时， * 可以省略，只是把它所指的地方当作一个长度为1的数组。 至于多维数组和指针，看懂下面的判断题就基本搞定了，详见《C Primer Plus (第6版)》第10章10.7，指针和多维数组。 123456789101112131415int arr[5] = &#123;0&#125;;int *p3 = &amp;arr; // 错int (*p2)[5] = arr; // 错int (*p1)[5] = &amp;arr; // 对int zippo[4][2] = &#123;0&#125;;int (*pointer1)[2] = &amp;zippo[0]; // 对int (*pointer7)[2] = zippo; // 对 zippo是个基类型为一维数组的指针，把它赋给另一个指针pointer7，很合理int (*pointer2)[3] = &amp;zippo[0]; // 错int (*pointer3)[2] = &amp;zippo[0][0]; // 错int *pointer4 = &amp;zippo[0][0]; // 对int (*pointer5)[2] = &amp;zippo; // 错int (*pointer6)[4][2] = &amp;zippo; // 对int (*pointer8)[2] = zippo; // 对 指针与const 下面说的仅适用于C99. int * const q = &amp;i ; 意思是q里面的值不能再变，即q指向i的内存那块地，这个关系不能再变， *q = 26 OK q++ 因为q时const，不能变。 const int p = &amp;i ; 此时，i的值可以变，p的值也可以变，不能变的是，不能通过p去改变i的值， i = 26; OK p = &amp;j ; OK *p = 26; 不可以 int i; const int* p1 = &amp;i ; int const* p2 = &amp;i ; int const p3 = &amp;i ; 判断那个被const了的标准是const在的前面还是后面，所以前两个是等价的，即不能通过 *p修改i的值。最后一个表示指针p的值不能被修改。 我们可以借助const指针这个特性，去做一些方便的事情，比如把一个非const得值转成const，比如下面这些代码： 123void f(const int* x);int a = 15;f(&amp;a); 这样的话就可以确保这个函数f不会对外面的a值作出修改。当传递的参数类型比地址大时，这是常用的手段，既能用较少的字节数传递值给参数，又能避免函数对外面的变量进行修改。 既然数组已经是一个const指针了，已经是 *const数组名 了，不能再指向别的内存了，那么 * 号前面再加一个const是什么意思呢？ const int a[] = {1,2,3,4,5}; 意味着这个数组里面所有的元素都是const，都不能再改变了。 指针运算 对于四则运算，a+1就是比a多了1而已，但是对于指针运算不是如此。 12345678910111213#include &lt;stdio.h&gt;int main()&#123; char ac[] = &#123;0, 1, 2, 3, 4, 5, 6, 7,8, 9&#125;; char *p = ac; printf(&quot;p=%p\\n&quot;, p); printf(&quot;p+1=%p\\n&quot;, p + 1); int ai[] = &#123;0, 1, 2, 3, 4, 5, 6, 7,8, 9&#125;; int *q = ai; printf(&quot;q=%p\\n&quot;, q); printf(&quot;q+1=%p\\n&quot;, q + 1); return 0;&#125; 输出： 1234p=0000009ff63ffbe6p+1=0000009ff63ffbe7q=0000009ff63ffbb0q+1=0000009ff63ffbb4 sizeof(char)=1,sizeof(int)=4,可见，指针+1，不是真的加1，而是在地址值上加一个sizeof(该指针所指的类型)，加了4个字节。对指针做一个+1的动作，意味着，指到下一个单元去。如果真的让地址+1，比如让q=0000009ff63ffbb0+1=0000009ff63ffbb1，那对int数组就没有什么意义了。 另外，如果指针不是指向一片连续分配的空间，如数组，那么这种运算也是没有意义的。 在上面的代码中，*p 等价于 ac[0], *(p+1)等价于ac[1], *是单目运算符，优先级高，即， *(p+n)等价于ac[n]。 不仅+可以，-也可以。++或–也行。也可以做比较，就是地址的大小比较。但是没有乘除，指针做乘除没有意义 数组名不能++，因为数组名是一个常量指针，不能变。 在上面那段代码后面加上这段： 12345char *p1 = &amp;ac[5];printf(&quot;p1-p=%d&quot;, p1-p);int *q1=&amp;ai[6];printf(&quot;q1=%p&quot;, q1);printf(&quot;q1-q=%d&quot;, q1-q); 输出： 123p1-p=5q1=0000008b949ffac8q1-q=6 q1-q=6，而q1的值和q的值差24，一个int型又是4字节，因此，指针之间的减法减出来的是中间差几个元素。如果 p 和 q1 不是指向同一个数组，那么这样相减是没有意义的。 *p++ ,的运算符优先级和 * 同级，但是是自右向左，所以后面不用带()，但是加括号更易读。p的结果是以前的结果，先做p，再由 * 取出p++ 的值，也就是说，取出p所指的那个暑数据来，完事顺便把p移到下一个位置去，常用于数组这样连续空间的遍历操作，以前我们想遍历数组，往往使用for循环，现在我们可以用这个技巧来遍历数组。 其实 *p++ ，在最开始的CPU上可以直接被翻译成一条汇编指令，这样跑得快，后续的很多CPU延续了这种，但是现在也有些CPU没有延续这种指令，遇到这种机器， *p++就不会跑得特别快。 使用 *p++ 时特别要注意， 123while (*p != 6)&#123; printf(&quot;%d\\t%.0f\\t%.0f\\t\\n&quot;, *p++, pow(*p++, 2), pow(*p++, 3)); &#125; 我们想让p在下次循环是+1，但在块里p实际上加了3次，不要这么干，很蠢。应该是： 123while (*p != 6)&#123; printf(&quot;%d\\t%.0f\\t%.0f\\t\\n&quot;, *p++, pow(*p, 2), pow(*p, 3)); &#125; 123456789101112131415#include &lt;stdio.h&gt;int main()&#123; int a[10] = &#123;0&#125;; int i, j; for (i = 0; i &lt; 10; ++i) &#123; scanf(&quot;%d&quot;, &amp;a[i]); &#125; int *p = &amp;a[9]; for (i = 0; i &lt; 10; ++i) &#123; printf(&quot;%d &quot;, *p--); // i = 9 这个循环做完以后，p已经减出数组的地址范围了，只不过此时p--还是a[0]的地址。 &#125; return 0;&#125; 0地址： 现代OS都是多进程的OS，基本管理单元都是进程，对于一个进程，OS会给它一个虚拟的地址空间，也就是说所有的程序在运行时都以为自己拥有一片从0地址开始的一片连续的空间，如果是32位的机器，顶就是4G。通常0地址是不能乱碰的，也就是说你的指针不应该具有0值，因此可以借助0地址碰不得这个特性来做一些事情，比如让返回的指针等于0，程序就会崩溃，借此来提示我们程序有错。 NULL大小写敏感，是C语言预定义的一个符号，表示0地址，所以我们以后用到0地址时，用NULL即可，有的编译器不喜欢你用0来表示0地址。 无论指向什么类型，指针的大小都是相同的，因为都是地址。但是指向不同类型的指针是不能相互赋值的，虽然这个值是能放得下去的，如果强行这样做，比如还是上面代码举例，q=p，但是q是指向int型的指针，现在指向了一个char数组，它会把char数组当作int数组，如果我们用 *q = 0; 则char数组前四个元素都会变成0，所以为了规避用错指针，指向不同类型的指针之间不能互相赋值。 我们印象中C语言的指针都有类型，实际上也存在一种例外。这里涉及到通用指针，它可以指向任何类型的变量。通用指针的类型用（void *）表示，因此也称为void 指针。 void* 表示不知道指向什么东西的指针，计算规则与char* 相同，但是不相通，也就是不能混合去用。 指针也能强制类型转换， int* p=%i; void* q=(void*)p; 第二句的意思就是：p还是指向int，但是我们通过q去看向i，q现在不拿i当int了，拿i那片内存上的值当void了，当它什么都不是了。 动态内存分配 数组长度一旦确定下来，就不能变了。C99可以用变量做数组定义的大小，这样我们刚定义数组的时候就没必要搞清它的长度。那C99之前呢？比如C语言二级考试，人们那时必须使用动态内存分配，调用malloc() 必须include &lt;stdlib.h&gt;，返回类型是void*，void* 即我有一个指针，指向一块内存，但是我也不知道那块内存上的类型是什么。 C99可以这么干： 123456789#include &lt;stdio.h&gt;int main()&#123; int number; scanf(&quot;%d&quot;, &amp;number); int a[number]; return 0;&#125; C99以前只能这么干： 12345678910111213#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; int number; int *a; // C99以前定义变量只能去头部定义 scanf(&quot;%d&quot;, &amp;number); a = (int *) malloc(number * sizeof(int)); //number就是数组的大小 // 之所以能将malloc的结果赋给 a，是因为malloc函数本来返回的就是一个void*，强制类型转换一下。 // 剩下的，a就能直接当数组去用了，什么a[10]……因为数组名就是一个常量指针 free(a); return 0;&#125; 在计算机看来，它才不care这片内存上存的是int还是double，它只知道那是一片连续的空间。 如果系统给我们的内存空间用完了，再去mallcoc()的时候，就会返回0或者NULL。 free()是和malloc()配套的一个函数。切记malloc()后，要free()，有借有还，再借不难。在还的时候，只能还申请来的空间的原始首地址，不能申请来了以后做指针运算，比如a++，最后free的时候也不管三七二十一，直接free(a)，这样程序会异常终止。或者不管p的地址是不是malloc得来的，比如让指针去指向一个int变量，然后去free§，也会终止程序。就是人家会记住你借走的原地址，所以还也要还原地址。但是，free(NULL)没问题，因为反正0地址是你不可能malloc()得到的地址，所以在free函数里面先判断，如果传进去的是个NULL，那就不做事情了。可是，有什么必要要去做这样的事情呢？因为有一个良好的习惯，定义一个指针，就初始化它为0，所以为了配合这种好习惯，就做出了这样一个机制，就在free()的函数定义里面，先做判断是不是NULL，即使是NULL，也不让它出错。如果因为一些原因，你没有去malloc§，(此时p因为初始化过，所以是NULL)就free§，这样不会出现问题. 指针初始化为0或NULL，表示其目前还未指向任何对象，就是说：不存放任何变量的内存地址。NULL 是一个在 stdio.h 中定义为零值的宏 double * pd=NULL; /* 等价于 pd=0 */ 空指针是一个特殊的指针值，也是唯一一个对任何指针类型都合法的指针值。指针变量具有空指针值，表示它当时处于闲置状态，没有指向有意义的东西。空指针用 0 表示，C语言保证这个值不会是任何对象的地址。给指针值赋零则使它不再指向任何有意义的东西。为了提高程序的可读性，标准库定义了一个与 0 等价的符号常量NULL。程序里可以写 p = 0; 或者 p = NULL; 两种写法都把p置为空指针值。相对而言，前一种写法更容易使读程序的人意识到这里是一个指针赋值。 如果malloc()以后不free()，就走掉了，就会留下内存漏洞，或者叫内存垃圾。但这不会对任何人造成伤害，因为，程序结束后，OS有机制会保证，曾经用过的内存会全部清楚干净，所以留下没有free的内存对于小程序来说没有问题，因为有OS擦屁股。但是做大程序就会遭殃，比如一个服务器程序，它一直在运行，那么malloc()不free()，就很容易把内存用完。 野指针，也就是指向不可用内存区域的指针。通常对这种指针进行操作的话，将会使程序发生不可预知的错误。 “野指针”不是NULL指针，是指向“垃圾”内存的指针。 如果程序定义了一个指针，就必须要立即让它指向一个我们设定的空间或者把它设为NULL，如果没有这么做，那么这个指针里的内容是不可预知的，即不知道它指向内存中的哪个空间（即野指针），它有可能指向的是一个空白的内存区域，可能指向的是已经受保护的区域，甚至可能指向系统的关键内存，如果是那样就糟了，也许我们后面不小心对指针进行操作就有可能让系统出现紊乱，死机了。所以我们必须设定一个空间让指针指向它，或者把指针设为NULL， 还应该注意的是，free和delete只是把指针所指的内存给释放掉，但并没有把指针本身干掉。指针p被free以后其地址仍然不变（非NULL），只是该地址对应的内存是垃圾，p成了“野指针”。如果此时不把p设置为NULL，会让人误以为p是个合法的指针。用free或delete释放了内存之后，就应立即将指针设置为NULL，防止产生“野指针”。内存被释放了，并不表示指针会消亡或者成了NULL指针（而且指针消亡了，也并不表示它所指的内存会被自动释放） 动态内存分配中， malloc()获得的指针，要判断一下是否为NULL，来检测是否malloc成功，因为malloc可能申请内存失败(内存有可能不够)，比如 if (p = (int *)malloc(4 * 100)){} malloc()获得的指针默认是 void * 类型，如果不强制转成 int * ,则 p++ 一次跳1个字节，如果强制转成 double * 则一次跳8个字节。 函数指针 先问一下,函数是怎么被调用的? 一个C语言程序的执行过程可以认为是多个函数之间的相互调用过程，它们形成了一个或简单或复杂的调用链条。这个链条的起点是 main()，终点也是 main()。当 main() 调用完了所有的函数，它会返回一个值（例如return 0;）来结束自己的生命，从而结束整个程序。 当主调函数遇到被调函数时，主调函数会暂停，CPU 转而执行被调函数的代码；被调函数执行完毕后再返回主调函数，主调函数根据刚才的状态继续往下执行。 函数是一个可以重复使用的代码块，CPU 会一条一条地挨着执行其中的代码，当遇到函数调用时，CPU 首先要记录下当前代码块中下一条代码的地址（假设地址为 0X1000），然后跳转到另外一个代码块，执行完毕后再回来继续执行 0X1000 处的代码。整个过程相当于 CPU 开了一个小差，暂时放下手中的工作去做点别的事情，做完了再继续刚才的工作。 从上面的分析可以推断出，在所有函数之外进行加减乘除运算、使用 if…else 语句、调用一个函数等都是没有意义的，这些代码位于整个函数调用链条之外，永远都不会被执行到。C语言也禁止出现这种情况，会报语法错误. 如果在程序中定义一个函数,在编译时会把函数的源代码转换为可执行代码,并为其分配一段存储空间,这段内存空间有一个起始地址,也称函数的入口地址,每次调用函数时都从该地址入口开始执行此函数代码. 函数名就是函数的指针,它代表函数的起始地址. 可以定义一个指向函数的指针变量，用于存放某一函数的起始地址，这就意味着该指针变量指向该函数，例如： 1int (*p)(int, int); p是一个指向函数的指针变量，它可以指向一个返回类型为整型，且形参是两个int型的函数。因为()的优先级比 * 高，所以必须给 *p 加括号，否则p会先和后面的(int, int)结合，这就变成函数p的声明了。 指向函数的指针，不能随便指，只能指向在定义时指定的类型的函数 在给函数指针赋值时，只需给出函数名即可，因为函数名也是函数指针。 在用函数指针调用函数时，只需将 (* p) 代替函数名即可，p为指针变量名，在 (* p) 后面需要写上实参。注意得加 * 号。 对于指向函数的指针进行自加自减等指针运算是毫无意义的， 函数指针和多维数组的指针定义方式，在于(* p)后面的是[]还是()，int (* p)[4] 和 int (* p)(int); 其实函数指针和PHP里面的可变函数比较像，但是在C里面用的不多。 Day 12 字符串 char word[] = {‘H’,‘e’,‘l’,‘l’,‘o’,’!’}，这不是C语言的字符串，因为不能用字符串的方式去做计算，只是一个字符数组。如果要定义一个C语言的字符串，需要在字符数组的最后一位加上 ‘\\0’，’\\0’就是表示0，就是表示整数值的0，也可也把单引号去掉，把\\去掉，就放一个0，也一样的意思，但是一般还是用’\\0’，因为’\\0’一定只占1个字节，0可能是个int，占4个字节。一定不要用’0’，这是个字符，内部用ASCII码值48。 因为有这个0，也就使得该字符数组变成了可以参与字符串运算的字符串。 这个0标志字符串的结束，但它不是字符串的一部分，计算字符串长度的时候不包括0。为什么要加0，是因为后面很多C语言的字符串函数需要这个0来表示字符串结束。 C语言字符串在内存中存在的形式，就是数组。访问的形式可以是数组也可以是指针。 C语言中用单引号引起的，表示一个char类型，即表示字符类型常量，当在单引号中出现两个及以上字符时或没有字符时，编译出错。双引号引起表示一个字符串常量，可以表示0到多个字符组成的字符串。 字符常量使用单引号，字符串常量使用双引号表示； 两者均支持转义字符表示； ‘A’ 表示单个字符大写字母A，占用1个字节空间 “A” 表示字符串，该字符串只有1个大写字母A组成，占用2个字节空间，每个字符串末尾自动会加上一个空字符 ‘\\0’ 空字符常量使用转义符号 '\\0’表示，空白字符串使用双引号表示 “”，单引号中不能没有东西。 char buffer[] = “”; 这个数组的长度只有1 char buffer[100] = “”;则buffer[] = ‘\\0’ C语言中的单引号和双引号含义迥异，用单引号引起的一个字符实际上代表一个整数，整数值对应于该字符在编译器采用的字符集中的序列值，因此，采用ASCII字符集的编译器而言，‘a’的含义与0141或97严格一致。 而用双引号引起的字符串，代表的却是一个指向无名数组起始字符的指针，该无名数组被双引号之间的字符以及一个额外的二进制值为零的字符‘\\0’初始化。比如“Hello”，这个字符串字面量，编译器看到它，会把它变成一个字符数组(无名数组)，并在末尾替你加上一个’\\0’，并把它放在某个地方。 要定义字符串变量可以有以下3种形式： char* str = “Hello” 这种形式的意思是有个叫str的指针，它指向一个字符数组，字符数组里面放的内容是&quot;Hello&quot;。双引号引起的字符串，代表的本来就是一个指向无名数组起始字符的指针，相当于把这个指向无名字符数组的指针赋给str。 char word[] = “Hello”,这种形式就是我自己就定义了一个字符数组，这个数组就在这，我给它初始化了。 char line[10] = “Helllo”，和第2个差不多，只不过定义这个字符数组时给了10个字节，然后“Hello”在这里占据6个字节，编译器会自动生成一个结尾的’\\0’，并且，剩下的空位都会自动补’\\0’ 注意: char c[] = {“I am”}; 等价于 char c[] = {‘I’, ’ ', ‘a’, ‘m’}; char c[] = “I am”; 等价于 char c[] = {‘I’, ’ ', ‘a’, ‘m’, ‘\\0’}; char b[10][5] = { //这是一个二维字符数组,所以第2个[]里的数字不能省,编译器不会替我们去数. b[][5]是可以的, 但b[10][]不行 “ling”, “yi”, “er”, “san”, “si”, “wu”, “liu”, “qi”, “ba”, “jiu” &#125;; 二维字符型数组也可以这样初始化, 'ling'后面默认补个'\\0', 'yi'后面补仨这样, 输出的话直接,printf(&quot;%s&quot;, b[0]); 即可 char *b[] = { //这是一个一维数组,所以[]里面不用加数字,编译器会替我们去数. “ling”, “yi”, “er”, “san”, “si”, “wu”, “liu”, “qi”, “ba”, “jiu” &#125;; 这不是二维字符型数组,这是一个一维指针数组, 其中每一个指针指向常量池的一个字符串.定义字符串有用数组定义和指针定义两种方式, 一个const在 * 号前,一个在 * 号后,上一种定义二维字符型数组,就是把字符串放在这里, 与数组名放在一起, 这一种方式就是把字符串放在常量池,这里只放指针. 输出的话也是直接,printf(&quot;%s&quot;, b[0]); 即可 C语言中，如果有2个相邻的字符串，中间没有任何其它东西，编译器会自动把两个字符串连接起来成为1个字符串。 C语言的字符串，是以字符数组的形式存在的，所以： 不能用加减乘除这样的运算符对字符串做运算，后来的语言，比如JAVA，比如python,比如php，提供一些简单的运算符处理字符串。C语言出现在上世纪70年代的早期，那时计算机更多的是做数值运算，80 年代才更多地去做信息处理，信息处理和数值运算最大的不同就是前者处理的是文字，后者处理的是数字。所以新的语言会更关注处理文字也就是处理字符串的能力。 字符串唯一特殊的地方就是字符串字面量可以用来初始字符数组。这是C语言唯一表现它懂字符串的地方。 字符串常量 我们定义一个字符串常量。并让指针s指向它，我们有： 123456789#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; char *s = &quot;Hello World&quot;; s[0] = &#x27;B&#x27;; printf(&quot;Here!s[0]=%c\\n&quot;, s[0]); return 0;&#125; 编译能过，但是运行会报错。这是为什么呢？我们想看看这个无名数组存在哪了，于是我们写： 12345678910111213#include &lt;stdio.h&gt;int main()&#123; char *s = &quot;Hello World&quot;; char *s2 = &quot;Hello World&quot;; int i = 0; printf(&quot;&amp;i=%p\\n&quot;, &amp;i); printf(&quot;s=%p\\n&quot;, s); printf(&quot;s2=%p\\n&quot;, s2);// s[0] = &#x27;B&#x27;;// printf(&quot;Here!s[0]=%c\\n&quot;, s[0]); return 0;&#125; 输出： 123&amp;i=00000059247ffa8cs=00007ff6e247a000s2=00007ff6e247a000 我们发现，i这个本地变量和这个无名数组存放位置的地址相差很大，现在的情况就是，i和s和s2都存在一块，但是s和s2所指向的那个无名字符数组存放的很远，它其实存放在程序的代码段，而且是只读的，如果对代码段的东西进行改写，OS会有一个保护机制会让你的程序崩溃掉，因为OS怕你做坏事情，所以实际上char *s在char前面有一个const，即等价于const char *s，由于历史原因，编译器接受缺省const的写法。 代码段这个东西在我们学PHP的时候接触过，讲内存有以下几个分区： 栈区 代码段 数据段 堆区 如果你想定义一个能修改的字符串，那应该用数组去定义，如： char s[] = “Hello World” 区别就是，上一个是指针，指针说它要去指向存在代码段的一个无名字符数组。这个是一个数组，它把存在遥远的代码段的字符数组拷贝过来，存在自己这，和本地变量存在一起。于是我们写： 12345678910111213141516171819#include &lt;stdio.h&gt;int main()&#123; char *s = &quot;Hello World&quot;; char *s2 = &quot;Hello World&quot;; char s3[] = &quot;Hello World&quot;; int i = 0; printf(&quot;s=%p\\n&quot;, s); printf(&quot;s2=%p\\n&quot;, s2); printf(&quot;&amp;i=%p\\n&quot;, &amp;i); printf(&quot;s3=%p\\n&quot;, s3); s3[0] = &#x27;B&#x27;; printf(&quot;s3[0]=%c&quot;, s3[0]);// s[0] = &#x27;B&#x27;;// printf(&quot;Here!s[0]=%c\\n&quot;, s[0]); return 0;&#125; 输出： 12345s=00007ff74d15a000s2=00007ff74d15a000&amp;i=000000a3e25ffcd0s3=000000a3e25ffcd4s3[0]=B 可以看到s3存放的地址和i的地址很近。也能去修改字符串。 那么当我们定义一个字符串时，我们用哪一种形式呢？ 如果要构造一个字符串，用数组； 如果要处理一个字符串，用指针； 有的教科书说C语言的字符串是char*，这个说法不对，字符串可以表达为char*的形式，但是char *不一定是字符串，本意是指向字符类型的指针。只有它指向的字符数组结尾有’\\0’才能说它所指的是字符串。 字符串输入输出 123char *t = &quot;title&quot;;char *s;s = t; 我们是可以这样赋值的，我们之前说过，已经定义好的数组之间不能相互赋值，因为数组名通常是一个常量指针。但是指向字符数组的指针可以这样相互赋值 12345678#include &lt;stdio.h&gt;int main()&#123; char t[] = &quot;title&quot;; char s[10]; s = t; return 0;&#125; 这样编译就会报错，但是下面这样依然是可行的： 123456int main()&#123; char t[] = &quot;title&quot;; char *s; s = t; return 0; 可以见得，用字符数组的方式定义字符串有个坏处，就是不能相互赋值，因为数组名是一个常量指针。同时我们也得知， 用指针去定义字符串，默认是一个const char*s，不能再去修改字符串的值。因为这种方式其实是一个指向常量池中一个字符串的指针。但是不能用指针去定义其他类型的数组，虽然数组名是指针，但是定义数组时还是要老老实实地用 &lt;类型&gt; 变量名称[元素数量] 去定义数组，用指针定义数组的方法仅对字符串适用。 用数组定义字符串，默认是char *const s，不能去更改s上面存放的地址。这个特征不限于字符型数组，别的数据类型的数组也有这个特征。 char b[10][5] = { //这是一个二维字符数组,所以第2个[]里的数字不能省,编译器不会替我们去数. b[][5]是可以的, 但b[10][]不行 “ling”, “yi”, “er”, “san”, “si”, “wu”, “liu”, “qi”, “ba”, “jiu” &#125;; 二维字符型数组也可以这样初始化, 'ling'后面默认补个'\\0', 'yi'后面补仨这样, 输出的话直接,printf(&quot;%s&quot;, b[0]); 即可, b[0]也是个指向一维字符数组的指针. 但这个一维字符数组它就在这,和b[0]在一起,所以我们可以去修改二维数组中元素的值 char *b[] = { //这是一个一维数组,所以[]里面不用加数字,编译器会替我们去数. “ling”, “yi”, “er”, “san”, “si”, “wu”, “liu”, “qi”, “ba”, “jiu” &#125;; 这不是二维字符型数组,这是一个一维指针数组, 其中每一个指针指向常量池的一个字符串.定义字符串有用数组定义和指针定义两种方式, 一个const在 * 号前,一个在 * 号后,上一种定义二维字符型数组,就是把字符串放在这里, 与数组名放在一起, 这一种方式就是把字符串放在常量池,这里只放指针. 输出的话也是直接,printf(&quot;%s&quot;, b[0]); 即可. 用这种方法, 我们不能通过指针去修改常量池中字符串的值 char *a = “0”; gets(a); 这样是不行的, 你在控制台输入一个新字符串比如&quot;China&quot;, a还是会指向&quot;0&quot;, 即不能通过a试图去把&quot;0&quot;改成&quot;China&quot;, 因为是const char *a = “0”; 但是这样是可行的: char a[100] = {&quot;\\0&quot;}; gets(a); 我们可以通过数组定义的方式去定义字符串, 这样就可以通过a去修改a指向的字符串,让其等于我们输入的字符串. 用指针和数组的方式分别定义字符串,还有个差异,比如 char *a = “China”; 我们通过 ++a,再输出, 123456int main()&#123; char *a = &quot;China&quot;; printf(&quot;%s&quot;, ++a); return 0;&#125; 输出 “hina” ,a指针上的值存放的是 “China” 字符串的首地址, ++a指向常量池中&quot;China&quot;第2个元素, 把它的地址当作首地址.虽然不能通过a去修改字符数组的值,但是a自己的值可以换成别的地址. 但是用数组定义的字符串不能通过自加运算符输出,因为那是 * const 指针,比如: 123456int main()&#123; char a[6] = &quot;China&quot;; printf(&quot;%s&quot;, ++a); return 0;&#125; 这样写就会报错,但是可以这么写: 123456int main()&#123; char a[6] = &quot;China&quot;; printf(&quot;%s&quot;, a + 1); return 0;&#125; 输出也是 “hina”, 因为a的值并能没有被改变, a + 1是个表达式 用指针定义字符串(字符型数组)的方法，不能延申到其他类型的数组，比如定义一个double类型的数组，不能写成 double *a = {0, 1, 2}; 这样写是错误的，非字符串的字符数组也不行，如char *a = {‘1’, ‘2’}; 这样写也是错的。char *a = {‘1’, ‘2’, ‘\\0’}; 这样写也是错的，但是！但是！但是！ 这样写是对的：char *a = “12”; 但是用指针定义指针数组的方法可以延申到其他类型，比如，double *a[] = {0, 1, 2}; 这样是定义了一个指针数组，第一个元素是一个指针，存放的值是NULL，即0地址，第二个元素是一个指针，存放的值是0x1，第三个元素是一个指针，存放的值是0x2 printf和scanf也能去输入或输出字符串，用格式控制符%s。 如果printf()用%s去输出一个字符数组且这个字符数组末尾没有’\\0’，也就是想让它输出不是字符串的字符数组，那么它会在结尾处输出乱码。 我们想了解scanf()中%s的问题，那么先看下面的一段代码： 12345678#include &lt;stdio.h&gt;int main()&#123; int a; scanf(&quot;%d&quot;, &amp;a); printf(&quot;%d&quot;, a); return 0;&#125; 我们输入 12 13，中间有一个空格或这一个tab。输出只有12，那是因为scanf()读到空格就不往下读了。那么再看下面这段代码： 123456789#include &lt;stdio.h&gt;int main()&#123; int a, b; scanf(&quot;%d&quot;, &amp;a); scanf(&quot;%d&quot;, &amp;b); printf(&quot;%d,%d&quot;, a, b); return 0;&#125; 我们输入12 13，则输出12,13，并不会读入空格并输出之，那是因为%d自动把空格或者回车当初分隔符不会读入。这种规则对于%s也同样适用。我们看下面的代码： 12345678#include &lt;stdio.h&gt;int main()&#123; char word[8]; scanf(&quot;%s&quot;, word); printf(&quot;%s##\\n&quot;, word); //这个word虽然是个指针，但是指向那个无名字符数组，%s可以把这个字符型指针指向的无名数组打印出来 return 0;&#125; 我们输入Hello World，结果输出： Hello## 可见和%d是一样的，都以空格回车TAB为分隔符，读到这三个字符就不读了。 12345678910#include &lt;stdio.h&gt;int main()&#123; char word[8]; char word2[8]; scanf(&quot;%s&quot;, word); scanf(&quot;%s&quot;, word2); printf(&quot;%s##%s##\\n&quot;, word, word2); return 0;&#125; 我们输入Hello World，结果输出： Hello##World## 和%d一样，也不会读入空格。 scanf()函数使用空白（换行符、制表符和空格）把输入分成多个字段。 在依次把转换说明和字段匹配时跳过空白。只要在每个输入项之间输入至少一个换行符、空格或制表符即可，可以在一行或多行输入。唯一例外的是%c会读取每个字符，包括空隔符。 但是scanf()里面仅仅用%s是不安全的，可能我们输入的字符串长度比那个字符数组长度大，可能会造成数组越界，因此我们可以用%[width]s来控制读入字符的长度，比如%7d， 12345678910#include &lt;stdio.h&gt;int main()&#123; char word[8]; char word2[8]; scanf(&quot;%7s&quot;, word); scanf(&quot;%7s&quot;, word2); printf(&quot;%s##%s##\\n&quot;, word, word2); return 0;&#125; 我们输入12345678，输出： 1234567##8## 我们并没有输入空格TAB或者回车，一旦有width存在，就不是根据空格，回车，TAB作为分隔符了，而是根据width 12char *stringscanf(&quot;%s&quot;, string); 这么写往往都误以为char*是字符串类型，其实是错的，string是一个指向字符类型的指针，由于没有对它初始化，所以string上面存的是那块内存原来遗留的值，我们后面把那个遗留的值当成地址传入scanf()，并输入，因此改写的是其它的内存上的值，如果那块内存上的值可以被改写，没问题，如果不能，就会报错。 12char *string;printf(&quot;%s&quot;, string); 这样写，也不对。string只是一个字符型指针，%s做的是把string指向的字符串打印下来。如果string没有指向任何字符串，那么%s就无能为力。 字符串数组 如果想写一个数组来表达很多个字符串，该怎么写呢？ char **a; 表示a是一个指针，该指针指向另一个指针，那个指针指向一个字符(串)，这显然不是我们想要的。 char a[][n]; 表示a是一个数组，a这里面的每一个单元都是一个char[n]，每一个单元都是一个字符数组。 char *a[] = {“Hello”, “World”, “你好”}； 意思是，a数组里面的每一个元素都是一个指针，比如a[0]指向外面一块内存，那块内存上存放着&quot;Hello&quot;……，注意a并不是一个指向二维数组的指针. char *s = “Hello World”; 这是一个指向一个一维字符串数组的指针. char t[] = “title”; 一个实际长度为6的字符数组, 最后一个元素是’\\0’ 字符串数组，在main()函数的参数表里也有应用，其实main函数参数表里有2个参数，一个是整数，一个是字符串数组，整数来告诉我们后面那个字符串数组里面到底有多少个字符串 int main(int argc, char const *argv[]) 字符串数组里面这些字符串是执行这个程序是，在名字后面所跟上的东西，argv[0]就是执行时所输入的可执行程序的名字，这一点在Unix里面很有用。 单字符输入输出 int putchar(int c); 它接收的参数虽然是int类型，但是它只能接受char范围内的int，它的返回类型也是int，表示这次它写出去了几个字符，正常情况下都是返回1，如果一些问题，它会返回EOF(End Of File)，EOF是C语言里面定义的一个宏，这个宏的值是-1，表示不能再输出东西了。 int getchar(void) 不需要有参数，返回int是因为需要返回EOF(-1)来表示输入结束了，看下面一串代码： 12345678910#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int ch; while ((ch = getchar()) != EOF)&#123; putchar(ch); &#125; printf(&quot;EOF\\n&quot;); return 0;&#125; 我们输入一串数字，按下回车，终端原封不动地输出我们刚刚输入的字符，getchar()只读一个字符，但是为什么我按下回车才给我回答呢？用户键盘显示器和你的程序之间还有一个程序，叫做shell。shell要做的非常基本的一件事情是，你在键盘上按的所有东西，它给你形成一个&quot;行编辑&quot;的工作，也就是说你在键盘上输入1 2 3 4 5 6……，在你按下回车之前，这些东西还没有送到你的程序那里去，都还停留在shell那里，直到你按下回车，这也是为什么我们之前使用scanf的时候，也要按下回车才行。按下回车之后，shell那里会有一个很大的缓冲区，把按下回车后送进去的东西都依次填在缓冲区。比如我们在键盘上输入的是123最后敲回车，那么缓冲区里就是123回车，接下来就是你程序的事了，如果你的程序用的是getchar()，那么getchar会一个字符一个字符地读，先读1再读2再读3。如果你的程序用到scanf(%d)，那么scanf()会把123变成一个整数一次性读入。 函数strlen 所有的字符串函数都是str开头,&quot;Hello&quot;占据6个字节，但是用strlen()得到的长度是5， 函数strcmp 顾名思义，cmp是compare，比较两个字符串。为什么要用函数去比较呢？能不能直接比较两个字符串？比如我们写s1 == s2，编译会给warning，提示数组之间的比较永远是false。为什么，因为这两个字符数组虽然上面存的值一样，但一定不是同一个地址，我们用==去比较的时候其实是在比较地址是否相同。 用大于小于号，比较的是字符串的首地址大小，而不是字符串的大小。 char arr1[] = “abcdef”; char arr2[] = “abc”; 比较的是&quot;abcdef&quot;中a的地址和&quot;abc&quot;中a的地址。 字符串变量比较不能直接用==，但是可以用变量地址和字符串用==比较，如果地址相同，字符串会相等。char *str1 = “hello”;和”hello”的地址是相同的，所以返回结果相等。 但是字符型变量char可以直接拿比较运算符比较大小，因为它本质是整型。 int strcmp(const char *s1, const char *s2) C语言标准并没有具体规定 strcmp() 函数的返回值是多少，大多数编译器选择了以下两种方案： 返回两个字符串的差值，即找到两个字符串中首个不相等的字符，然后返回这两个字符的差值； 返回 -1、0 或者 +1；-1表示s1 &lt; s2；+1表示s1 &gt; s2 返回0表明两个字符串是相等的， 两个字符串自左向右逐个字符相比（按 ASCII 值大小相比较），直到出现不同的字符或遇 \\0 为止 函数strcpy char *strcpy(char *restrict dst, const char *restrict src) 第一个参数是目的，第二个参数是源。 返回一个字符指针，这个返回的字符指针就是dst 在源字符串还未确定下来时，我们想提前在程序里面写好一个复制一个字符串的语句，常见的操作是： char* dst = (char*) malloc(strlen(src)+1) stcpy(dst, src); 这个函数参数表里面有C99新的关键字restrict，意思是两个字符串不能重叠，什么是重叠？比如我想把s1拷贝给s2，重叠的话就是，s1和s2在内存上存储的位置有部分是重合的。原因是现代函数的设计不光要考虑功能实现，还要考虑很多额外因素，strcpy()是处理字符串中使用及其广泛的函数，在这个函数上面如果有一点点性能的小改进，可能对整个程序，整个系统，甚至对整个互联网都有巨大的提升，因此人们在这上面做了很多的努力来使得这个函数效率的提升，其中一个努力就是，当你的计算机是多核的，它可能把这个拷贝工作分成好几段，让每一个核做其中一段，此时必须要求拷贝出来的字符串不能和原来的字符串重叠，否则分段拷贝就会有冲突。 函数strcat char* strcat(char *restrict s1, const char *restict s2); 把s2拷贝到s1的后面去，接成一个长字符串，并返回s1，前提是s1必须要有足够的空间。 strcpy 和 strcat 都有可能出现安全问题，因为我们不知道目标字符串的大小是多少，会不会越界，所以我们要用它俩的升级版本，strncpy和strncat，同时在参数表里多了一个n，这个n表示能够拷贝或连接过去多少个字符，如果多了怎么办？掐掉，越界是不可能越界的。 对于strcmp()也有带n的版本，strncmp()，这个n并不是解决安全问题的，这个n表示，我只想比较前n个字符串是否相等。 字符串搜索函数 char* strchr(const char s, int c); 我要在这个字符串中，从左边寻找c第一次出现的位置。 char strrchr(const char *s, int c); 我要在这个字符串中，从右边寻找c第一次出现的位置。 返回NULL表示没找到，返回非NULL，则返回一个指针，指向你要找的那个字符。 我们如何寻找一个字符串中的第二个字符呢？可以用一个小套路： 1234567891011#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(int argc, char const *argv[])&#123; char s[] = &quot;Hello&quot;; char *p = strchr(s, &#x27;l&#x27;); char *q = strchr(p+1, &#x27;l&#x27;); printf(&quot;%s\\n&quot;, p); printf(&quot;%s\\n&quot;, q); return 0;&#125; 我们运行，输出： 12llolo 我们实现了找到一个字符串其中一个字符第2次出现位置。同时我们也明白了printf()中的%s输出字符串的原理，字符串的输出是通过字符数组名找到其字符数组起始地址,然后逐个输出其中的字符，遇到字符’\\0’就停止输出。字符型指针p指向一个字符数组(字符串)，p的值就是这个字符数组首元素的地址，然后%s根据p的值找到p所指向的字符数组，并输出之。我们在找第2个字符位置时就利用了这个原理，先把p+1，此时通过指针运算，p+1的值就是&quot;llo&quot;第二个’l’的地址，让字符指针q的值等于第2个’l’的地址，那么下一个%s在输出时，就是根据q的值找到q所指向的字符数组&quot;lo&quot;，并输出之。%s是把指针上的地址当作所要输出的字符串的第一个元素的地址。 %s输出字符串是这个原理我们很能理解，因为数组传进函数只能传进它的指针(字符串就是一个数组)，函数再通过指针来找到外面的数组。scanf()也是一个函数，也不能例外。 我们如果想把&quot;Hello&quot;后面的&quot;llo&quot;复制给另一个字符数组，这样干： 12345678910111213#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char const *argv[])&#123; char s[] = &quot;Hello&quot;; char *p = strchr(s, &#x27;l&#x27;); char *t = (char *) malloc(strlen(p)+1); strcpy(t, p); printf(&quot;%s\\n&quot;, t); free(t); return 0;&#125; 还有一个小技巧，就是我们想截取&quot;Hello&quot;前面的&quot;He&quot;，这么干： 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char const *argv[])&#123; char s[] = &quot;Hello&quot;; char *p = strchr(s, &#x27;l&#x27;); char c = *p; *p = &#x27;\\0&#x27;; char *t = (char*) malloc(strlen(s)+1); strcpy(t, s); printf(&quot;%s\\n&quot;, t); free(t); printf(&quot;%s\\n&quot;, s); *p = c; printf(&quot;%s&quot;, s); return 0;&#125; 输出： 123HeHeHello 字符指针p指向&quot;llo&quot;，p的值是该字符串首元素的地址，所以*p即第一个’l’。通过 *p把’l’换成’\\0’，就把字符串s&quot;Hello&quot;从’\\0’那里截断了，所以s现在是&quot;He&quot;，再将s拷贝给t，事成之后，利用 *p将还原。 strstr()是在一个字符串中寻找一个字符串的。 strcasestr()也是在一个字符串中寻找一个字符串，只不过会忽略大小写。 Day13 枚举 如果莪们程序当中出现一些数字，那么我们应该尽量用一些符号来表达这些数字，这样做会增加可读性。 如果常量一多，定义起来就很麻烦可以用枚举，它是一个用户定义的数据类型，它用关键字enum声明： enum 枚举类型名字{名字0，名字1，……}; 有时候也会把枚举类型名字忽略掉，因为有时候名字不重要。我们通常要的是大括号{}里面的名字，他们就是常量符号，他们的类型只能是int。 当我们需要一些可以排列起来的常量值时，比如月份，日期等等，定义枚举的意义就是给了这些常量值的名字。 enum color {red, yellow, green}; 这是在声明一种新的数据类型，这种数据类型叫做color，我们可以把它像int float类型一样去用，当然，用的时候要带上enum(后面的语言有的可以不带enum)，比如： enum color {red, yellow, green}; void f(eum color c); 实际上，C语言内部，enum就是int型，所以每一个枚举变量是可以当作int型输入输出的，比如： enum color {red, yellow, green}; void f(eum color c); enum color t = red; enum color d = 100; scanf(&quot;%d&quot;, &amp;t); f(t); 关于枚举有一个小套路，看看下面代码： 1enum COLOR &#123;RED, YELLOW, GREEN, NumCOLORS&#125;; NumCOLORS 恰好是3，因此我们发现，这个常量可以表达它的前面有多少个常量。可以用这个东西定义数组，可以用来遍历，等等。 声明枚举量时也能指定值。 我们在C语言里面用枚举，主要的需求是需要定义一些排比的常量，比用const方便。而不太会用它去做数据类型的事。 枚举有类型，宏没有类型， C语言之前的语言和C语言之后的语言，都有枚举，但是做的都比C语言好，枚举在C语言里面不是那么成功的东西。 结构类型 一个结构就是一个复合的数据类型，类似JAVA和python中的类。比如： 12345678910#include &lt;stdio.h&gt;int main(void) &#123; struct data&#123; int month; int day; int day; &#125;; return 0;&#125; 和本地变量一样，在函数内部声明的结构类型，只能在函数内部使用。所以通常在函数外部声明结构类型，函数只要在在这个结构体声明下面，就可以使用这个结构体类型。 声明结构的形式： struct date today; 变量名叫today，类型是struct date，struct不可缺省。 1234struct &#123; int x; int y;&#125; p1, p2; 这种情况下，p1和p2并不是结构类型的名字，它们就是前面这种结构类型的2个变量。这个结构类型没有名字。其实这种做法就是想要两个变量，p1和p2，后面不会再用到这种结构类型了、 更常见的是这种形式： 1234 struct point &#123; int x; int y;&#125; p1, p2; 在声明新的结结构类型point的同时，还定义了2个这种类型的变量。 结构类型和结构变量是2个东西，声明一个结构类型后，我们可以定义出很多结构变量来。 类型不分配内存，但是变量分配内存。 结构体的成员名可以与程序中的变量名相同，不会混淆。但不建议。 结构体数组不是一个二维数组。 2个结构体变量不能直接用比较运算符去做比较。 sizeof()是个静态运算符，不是一个函数，它也可以测量结构体类型和结构体变量的大小。 结构的初始化： 有下面一个结构体： 12345678910#include &lt;stdio.h&gt;int main(void) &#123; struct data&#123; int month; int day; int day; &#125;; return 0;&#125; struct date today = {07, 31, 2014}; struct date today = {.month = 07, .year = 2014}; 这种方式和数组初始化一样，没有被初始化的字段day自动填0。这种机制和JAVA也是一样的。 用.访问成员变量，这一点和JAVA也一样。出现在.左边的一定是一个结构变量，而不是一个结构类型，结构类型的虚体，结构变量才是实体。 数组里面有很多的单元，结构里面有很多的成员。数组的单元的必须是相同类型的，结构不必。 也可以直接，date.month = 7; 这样初始化。和JAVA一样。 结构有一点和数组不同，对于整个结构，可以直接做赋值，取地址，也可以传递给函数参数。 1234567struct point&#123; int x; int y; &#125; p1, p2; p1 = (struct point)&#123;5, 10&#125;; p1 = p2; 数组无法做上面2中运算，数组自带const。 如果把p2的字段的值改了，那么p1不会跟着改，这是两个不同的结构变量，这一点和数组也不一样。 另外一个和数组非常不一样的地方就是，结构变量的名字，并不是结构变量的地址。数组的变量名就是数组的地址。对结构变量取地址必须使用&amp;运算符。eg. struct data *pData = &amp;today; 如果把&amp;去掉，则编译报错。 结构与函数 结构体类型和普通的数据类型用法一样，比如： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;int SumEven(const int *a, int len);int SumOdd(const int *a, int len);int SumOverall(const int *a, int len);int main()&#123; int a[1000] = &#123;0&#125;; int n = 0; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt;= n; ++i) &#123; a[i] = i; &#125; printf(&quot;%d\\n%d\\n%d&quot;, SumEven(a, 1000), SumOdd(a, 1000), SumOverall(a, 1000)); return 0;&#125;int SumEven(const int *a, int len)&#123; int sum = 0; for (int i = 0; i &lt; len; i += 2) &#123; sum += a[i]; &#125; return sum;&#125;int SumOdd(const int *a, int len)&#123; int sum = 0; for (int i = 1; i &lt; len; i += 2) &#123; sum += a[i]; &#125; return sum;&#125;int SumOverall(const int *a, int len)&#123; int sum = 0; for (int i = 0; i &lt; len; ++i) &#123; sum += a[i]; &#125; return sum;&#125; 取成员运算符 . 的优先级一定大于取地址运算符 &amp; 的优先级。 结构体变量传入函数传的都是值，一个字段一个字段复制给函数内部，想修改外部的结构体，最好传指针的值。 没有直接的方式可以一次scanf一个结构。函数怎么把函数里面的结构体传出去呢？可以return出去，也就是让函数返回类型是该结构类型。 如果有一个大的结构变量要传进函数，则通常的做法是传结构指针，否则既费空间，又费时间， 12345678910struct date &#123; int month; int day; int year;&#125;;struct date myday;struct date *p = &amp;myday;(*p).month = 12;p-&gt;month = 12; 最后两行是等价的，-&gt; 是一个新的运算符，和 . 的运算符地位一样，在这个运算符的左边一定是个指针，取成员运算符(指针) -&gt; 和取成员运算符(对象) .一样，优先级都高于 &amp; 和 * ,常见到 &amp;p-&gt;month 和 (*p).month 。 * 和 &amp; 运算符是平级的。 结构中的结构 结构里面的变量可以是普通数据类型，比如int float double，也可以是其他结构体类型，比如： 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;struct point&#123; int x; int y;&#125;;struct rectangle&#123; struct point pt1; struct point pt2;&#125;;int main()&#123; struct rectangle r; r.pt1.x = 0; r.pt1.y = 0; r.pt2.x = 1; r.pt2.y = 1; struct rectangle *rp; rp = &amp;r; (*rp).pt1.x = 2; rp-&gt;pt1.x = 2; return 0;&#125; (*rp).pt1.x = 2; rp-&gt;pt1.x = 2; 这两句是等价的，但是注意，间接访问运算符 * 的优先级低于取成员变量运算符 . ，(*rp).pt1.x = 2; 不加()会报错，rp-&gt;pt1.x = 2; 这句话中 -&gt; 和 . 是平级的，自左向右运算的，所以无需加括号。 有结构数组，即数组的元素都是结构，也可以做数组结构，即结构里面有个数组。 类型定义 我们定义一个结构体变量时，总是要加上 struct 很不方便，用 typedef关键字可以摆脱 struct，它可以来声明一个已有数据类型的新名字。比如：typedef int Length; Length a, b, c; 1234 struct point &#123; int x; int y;&#125; p1, p2; 在声明新的结结构类型point的同时，还定义了2个这种类型的变量。 1234 typedef struct point &#123; int x; int y;&#125; p1; 重载已有结构类型 point 的名字，重载为 p1 ,并没有定义新的结构变量出来。 typedef 可以定义数组类型 typedef struct TableEntry Table[ NunVertex ]; 这条语句把含有 NunVertex 个元素的结构体数组类型 重载为 Table。再比如： 12typedef int arr[100];arr a, b, c; 其中第2句相当于a[100],b[100],c[100] ，即 arr就是 int [100] ”类型“的重载。 typedef *char[10] Strings 这句话的意思是将一个字符型指针数组，重载为Strings 联合","categories":[],"tags":[]},{"title":"陈姥姥_数据结构(1)","slug":"Data-Structure-learning","date":"2022-07-24T02:35:10.000Z","updated":"2022-07-25T09:25:10.133Z","comments":true,"path":"2022/07/24/Data-Structure-learning/","link":"","permalink":"http://example.com/2022/07/24/Data-Structure-learning/","excerpt":"","text":"Day 1 关于数据组织 解决问题方法的效率，跟数据的组织方式有关。 比如，存书和查书问题。","categories":[],"tags":[]},{"title":"C语言学习tips","slug":"C_Learn_Tips","date":"2022-07-22T07:42:10.000Z","updated":"2022-12-20T16:43:38.628Z","comments":true,"path":"2022/07/22/C_Learn_Tips/","link":"","permalink":"http://example.com/2022/07/22/C_Learn_Tips/","excerpt":"","text":"2022.9.21 输入长度不小于20的字符串，则定义数组是一定要不小于21，因为有’\\0’； 字符型比较相等时一定要用 == ，千万别用 = 。 冒泡排序，可以只排你想让排序的行数，余下行数可以不排，比如有一个长度为10的一维数组，则我们可以用冒泡排序只去排前2行，前3行，前4行等等。 逗号运算符优先级是C语言所有运算符里面最低的。 1,200 不是一个合法常量； C语言是由函数组成的，函数是C语言的基本单位。所以说C语言主要是借助定义函数来实现程序模块化，函数把程序分成一个个模块。 注意，我们写for循环时，改变条件的语句，比如i++，一般就写在for的括号里面，但是在写while循环时，while 的括号里面没有i++，循环体里面需要加能改变条件的语句，否则是死循环。 C语言中goto语句，不仅可以终止循环，还能跳过你不想执行的语句。 程序从main()函数开始执行，也从main()函数结束。 直接递归:递归函数的函数体中存在显式的自我调用时，被称为直接递归。例如，函数foo中包含自我调用，因此是直接递归。 123456int foo(int x) &#123; if (x &lt;= 0) return x; return foo(x - 1); &#125; 间接递归:函数foo被称为间接递归，如果它包含对另一个函数的调用，而另一个函数最终会调用回函数foo。 1234567891011 int foo(int x) &#123;if (x &lt;= 0) return x;return bar(x); &#125; int bar(int y) &#123; return foo(y - 1); &#125; c语言中小的数对大的数取余，就商0，余数就等于被除数。3%7=3，7%10=7，10%20=10。 运算符：又叫操作符，表示对数据操作的符号，操作的数称为操作数，也称算子； 格式化字符串（Format String）是在编程过程中，允许编码人员通过特殊的占位符，将相关对应的信息整合或提取的规则字符串。格式化字符串包括格式化输入和格式化输出。一般格式：%[标志][输出最小宽度][.精度][长度][格式字符] 当 switch-case 的判断条件是一串连续的正整数时，其实是不用写冗长的switch语句的，写成数组简短很多，比如： 1234567891011121314151617181920212223242526272829303132333435switch (residue) &#123; case 0: outcome = 1; break; case 1: outcome = 0; break; case 2: outcome = 88; break; case 3: outcome = 9; break; case 4: outcome = 8; break; case 5: outcome = 7; break; case 6: outcome = 6; break; case 7: outcome = 5; break; case 8: outcome = 4; break; case 9: outcome = 3; break; case 10: outcome = 2; break; &#125; 我们把outcome写成一个数组，case的值用数组下标好了。 C语言中如何输出指定长度的整数，不够的用0填充。&quot;%0ad&quot;中的a是几就代表输出固定长度为几的整数，0代表的就是不够的位数用0填充，一般为向左填充不够的位数。比如这个%04d的0就是指在前面补0占位，4代表位宽。一般这两个要一起用。当然，当数字本身宽度比位宽大的话，那这就不起作用了，如a=12345;那么输出也是 a=12345 12int a=1;printf(&quot;a=%04d\\n&quot;, a); 输出：a=0001 但是不能补其他符号，比如： 12int a=1;printf(&quot;%*4d\\n&quot;, a); 我想用 * 号来补前面的空位，这样是行不通的，语法过不去。 如果不加0，只有%4d，则不够的只会补空格，比如： 12int a=1;printf(&quot;%4d\\n&quot;, a); 输出： 1，4前面加符号，则左对齐，比如： 12int a=1;printf(&quot;%-4d##\\n&quot;, a); 输出：1 ##，但是超出范围，左对齐也不起作用了，比如 12int a=100000;printf(&quot;%-4d##\\n&quot;, a); 输出100000## printf如果仅仅输出一个字符串，则可以省略转化字符 %s。比如： 123printf(&quot;%s&quot;,&quot;Hello World!&quot;);可简写为：printf(&quot;Hello World!&quot;); 但如果输出与其他数据组合的字符串时，必须用转化字符 %s 1printf(&quot;%s 一斤 %f 元，%s 一斤 %d 元&quot;,&quot;苹果&quot;,2.5,&quot;西瓜&quot;，2); puts()是用来输出字符串的，可以直接输出字符串常/变量，也可以输出指针变量 printf（）的输出格式很多，可以根据不同的需要加转义字符，达到格式化输出。 区别: puts()和printf()都能够用来输出字符串，但是两者有些许不同。puts()在输出字符串后，会自动换行，而printf不会自动换行。 puts(s)等价于printf(“%s\\n”,s); 0 &lt; 余数 &lt; 商 辗转相除法求最大公因数原理1 辗转相除法求最大公因数原理2 由于 m ÷ n = q…r 这个关系式子的存在，我们很容易得到 m 和 n 的公约数集合就等于 n 和 r 的公约数集合。所以 m 和 n 的最大公因数一定也是 n 和 r 的最大公因数，所以我们就可以用递归去求了。求 m 和 n 的最大公因数也就是求 n 和 r 的最大公因数，以此类推，可以开始递归了，直至找到那个最大公约数。 指针的变量命名别和普通变量名一样，否则会报错。 if 和 else if 语句后的判断条件从上到下依次判定，遇到第一个满足条件的则进入执行语句执行 执行完毕后无视其他 else if 和 else 语句判断和其执行语句，往下执行。如果最后一个判断条件才满足，则前面的判断条件肯定都判断过了。 字符数组，在scanf gets时自动加\\0，在用双引号初始化时也自动加\\0 函数名是指向函数的指针,代表函数的起始地址. puts()函数只能输出字符串 如果想从一个字符串的第n个位置往后输出,则可以这样, 比如:123456int main()&#123; char *a = &quot;China&quot;; printf(&quot;%s&quot;, a + n); return 0;&#125; 对于指针来说，p + 1 比 p++ 好，因为 前者不会改变p的值，后面如果要再用到p，还是原值，不容易出错误。 缓冲区（Buffer）又称为缓存（Cache），是内存空间的一部分。 使用 gets() 时，系统会将最后“敲”的换行符从缓冲区中取出来，然后丢弃，所以缓冲区中不会遗留换行符。这就意味着，如果前面使用过 gets()，而后面又要从键盘给字符变量赋值的话就不需要吸收回车清空缓冲区了，因为缓冲区的回车已经被 gets() 取出来扔掉了。 关于指针作为函数返回值的一些思考： 先看下面一段代码引出问题： 12345678910111213141516#include &lt;stdio.h&gt;int * function();int main()&#123; int *b = 0; b = function(); for (int i = 0; i &lt; 2; ++i) &#123; printf(&quot;%d\\n&quot;, b[i]); &#125; return 0;&#125;int * function()&#123; int a[2] = &#123;1, 2&#125;; return a;&#125; 我们运行输出，发现什么都没有输出，调试一下，发现 b 是NULL，哦，我们恍然大悟，a是一个指向一个int数组的指针，该数组名就是a，但是这个数组是一个本地变量，作用域和生存期都是在函数内部。返回的是一个指向这个本地变量的指针，那么到了main()以后，返回的这个指针还在，并且赋给了b，我们想让b指向a数组，但是a数组已经不在了，所以b指向空。所以我们如果想让数组返回一个指向数组的指针，那么该数组最好定义在main()函数里面，并且传入函数内部。 如果函数返回的是普通类型，比如返回int型，看下面这个代码： 1234567891011121314#include &lt;stdio.h&gt;int function();int main()&#123; int b = 0; b = function(); printf(&quot;%d&quot;, b); return 0;&#125;int function()&#123; int a = 2; return a;&#125; 运行输出是2，返回int型就不会出现这种问题，因为 a 确实会被消灭，但是 a 把值及时传给了 b ，上面那个返回指针的直接返回NULL，b 的值就是NULL 再看一组例子: 12345678910111213#include &lt;stdio.h&gt;int *func()&#123; int n = 100; return &amp;n;&#125;int main()&#123; int *p = func(), n; n = *p; printf(&quot;value = %d\\n&quot;, n); return 0;&#125; 运行后也是什么也不输出。返回的是NULL。 2个挨在一起的scanf()，第2个scnaf往往会去读输入第一个scanf留下了的换行符，用两个连续的gets()函数可以解决这个问题。 C语言字符型数组初始化，不够的自动补’\\0’ 我们想连着用scanf()读入字符串，可以这么写： 123char a[20] = &#123;&#x27;\\0&#x27;&#125;;char b[20] = &#123;&#x27;\\0&#x27;&#125;;scanf(&quot;%s %s&quot;, &amp;a, &amp;b); 原因是scanf()中%s读到空格就不往下读了。刚好可以利用这个空格来分割输入的字符。 想让两个变量交换值，可以用 异或 位运算符(两个值相异结果为真，两个值相同结果为假)，比如： 12345a = 10; // 1010b = 11; // 1011a = a ^ b; // 0001b = b ^ a; // 1010a = a ^ b; // 1011 输出 a = 11; b = 10; 这样做比用临时变量来保存的a的值，可以节省一个用来保存临时变量的寄存器。 左移1位，相当于该数乘2，左移比乘法运算快得多，有些编译器会把 * 2自动转为左移1位； 文本文件：这类文件以文本的ASCII码形式存储在计算机中。它是以&quot;行&quot;为基本结构的一种信息组织和存储方式。 二进制文件：这类文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂它们，只有通过相应的软件才能将其显示出来。二进制文件一般是可执行程序、图形、图像、声音等等。 然而，可能与你的想象不同的是，这里的二进制或者文本与文件的格式并没有任何关系，而是文件流操作时对数据的表达方式。因为文本文件与二进制文件的区别仅仅是编码上不同. 大家都知道计算机的存储在物理上是二进制的，所以文本文件与二进制文件的区别并不是物理上的，而是逻辑上的。这两者只是在编码层次上有差异。简单来说，文本文件是基于字符编码的文件，常见的编码有ASCII编码，UNICODE编码等等。二进制文件是基于值编码的文件，你可以根据具体应用，指定某个值是什么意思(这样一个过程，可以看作是自定义编码)。 从上面可以看出文本文件基本上是定长编码的(也有非定长的编码如UTF-8)。而二进制文件可看成是变长编码的，因为是值编码嘛，多少个比特代表一个值，完全由你决定。大家可能对BMP文件比较熟悉，就拿它举例子吧，其头部是较为固定长度的文件头信息，前2字节用来记录文件为BMP格式，接下来的8个字节用来记录文件长度，再接下来的4字节用来记录bmp文件头的长度。 文本工具打开一个文件的过程是怎样的呢？拿记事本来说，它首先读取文件物理上所对应的二进制比特流，然后按照你所选择的解码方式来解释这个流，然后将解释结果显示出来。一般来说，你选取的解码方式会是ASCII码形式（ASCII码的一个字符是８个比特），接下来，它8个比特8个比特地来解释这个文件流。例如对于这么一个文件流&quot;01000000_01000001_01000010_01000011&quot;(下划线’’_’’，为了增强可读性手动添加的)，第一个8比特’‘01000000’‘按ASCII码来解码的话，所对应的字符是字符’‘A’’，同理其它3个8比特可分别解码为’‘BCD’’，即这个文件流可解释成“ABCD”，然后记事本就将这个“ABCD”显示在屏幕上。 事实上，世界上任何东西要与其他东西通信会话，都存在一个既定的协议，既定的编码。人与人之间通过文字联络，汉字“妈”代表生你的那个人，这就是一种既定的编码。但注意到这样一种情况，汉字“妈”在日本文字里有可能是你生下的那个人，所以当一个中国人Ａ与日本Ｂ之间用“妈”这个字进行交流，出现误解就很正常的。用记事本打开二进制文件与上面的情况类似。记事本无论打开什么文件都按既定的字符编码工作（如ASCII码），所以当他打开二进制文件时，出现乱码也是很必然的一件事情了，解码和译码不对应嘛。例如文件流’‘00000000_00000000_00000000_00000001’'可能在二进制文件中对应的是一个四字节的整数int 1，在记事本里解释就变成了&quot;NULL_NULL_NULL_SOH&quot;这四个控制符。 因为文本文件与二进制文件的区别仅仅是编码上不同，所以他们的优缺点就是编码的优缺点，这个找本编码的书来看看就比较清楚了。一般认为，文本文件编码基于字符定长，译码容易些；二进制文件编码是变长的，所以它灵活，存储利用率要高些，译码难一些（不同的二进制文件格式，有不同的译码方式）。关于空间利用率，想想看，二进制文件甚至可以用一个比特来代表一个意思(位操作)，而文本文件任何一个意思至少是一个字符． 在windows下,文本文件不一定是一ASCII来存贮的,因为ASCII码只能表示128的标识,你打开一个txt文档,然后另存为,有个选项是编码,可以选择存贮格式,一般来说UTF-8编码格式兼容性要好一些.而二进制用的计算机原始语言,不存贮兼容性. 很多书上还认为，文本文件的可读性要好些，存储要花费转换时间(读写要编译码)，而二进制文件可读性差，存储不存在转换时间（读写不要编解码，直接写值）．这里的可读性是从软件使用者角度来说的，因为我们用通用的记事本工具就几乎可以浏览所有文本文件，所以说文本文件可读性好；而读写一个具体的二进制文件需要一个具体的文件解码器，所以说二进制文件可读性差，比如读BMP文件，必须用读图软件。 详见 注意在写递归函数时，特别要谨慎使用全局变量或者静态局部部便变量，因为在进入下一层函数时，你不好把控这个全局变量或者静态局部变量的值，看下面两段代码： 1234567891011121314double f(int a, int n)&#123; double this_item = 0; int n2 = n - 1; if (n == 1) &#123; this_item = a; return this_item; &#125; else &#123; while (n2 &gt;= 0) &#123; this_item += (a * pow(10, n2--)); &#125; return this_item + f(a, n - 1); &#125;&#125; 和 1234567891011121314double this_item = 0;double f(int a, int n)&#123; int n2 = n - 1; if (n == 1) &#123; this_item = a; return this_item; &#125; else &#123; while (n2 &gt;= 0) &#123; this_item += (a * pow(10, n2--)); &#125; return this_item + f(a, n - 1); &#125;&#125; 第2段代码，每进入下一次函数，this_item的值积累了外层函数得到的值，所以每一层函数得到的this_item会被重复加。 回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。把一段可执行的代码像参数传递那样传给其他代码，而这段代码会在某个时刻被调用执行，这就叫做回调。如果代码立即被执行就称为同步回调，如果在之后晚点的某个时间再执行，则称之为异步回调。为什么不像普通函数调用那样，在回调的地方直接写函数的名字呢？这样不也可以吗？为什么非得用回调函数呢？有这个想法很好，因为在网上看到解析回调函数的很多例子，其实完全可以用普通函数调用来实现的。要回答这个问题，我们先来了解一下回到函数的好处和作用，那就是解耦，对，就是这么简单的答案，就是因为这个特点，普通函数代替不了回调函数。所以，在我眼里，这才是回调函数最大的特点。(其实普通函数的函数名也是一个函数指针) 关于判断素数的一个技巧：判断一个整数m是否是素数，只需把 m 被 2 ~ m-1 之间的每一个整数去除，如果都不能被整除，那么 m 就是一个素数。m 不必被 2 ~ m-1 之间的每一个整数去除，只需被 2 ~ sqrt(m)之间的每一个整数去除就可以了。如果 m 不能被 2 ~ sqrt(m)间任一整数整除，m 必定是素数。，但是sqrt(m)，如果是小数怎么办？是判断 2 ~ (int)(sqrt(m)) + 1 还是 2 ~ (int)(sqrt(m)) 就行了呢？后者。因为 (int)(sqrt(m)) + 1 比 (sqrt(m)) 大了，如果 m 能被 (int)(sqrt(m)) + 1 整除，那么m也一定能被一个小于(int)(sqrt(m))的整除，我们只需判断那个比(int)(sqrt(m))小的数即可，因此判断 2 ~ (int)(sqrt(m)) 就行了。 编写一个程序，可以编一点，运行一下，看看有没有错误，如果全部写完再来运行，出错了不容易找出在哪个位置。 for (i = 0; s[i] != ‘\\0’; ++i) 这个for循环可以代替 int i = 0; while(s[i] != ‘\\0’) {++i;} while 循环常用于不知道到底要循环多少次的循环，for 循环适合知道循环次数的循环，但也不绝对，比如： for (int i = 0; a[i] != 0; ++i) {} C++能完全兼容C 编码规范不仅能让代码更易读，也可以提高代码的运行效率 面向过程: 就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。典型的C语言，C语言是由函数组成的，函数是C语言的基本单位。所以说C语言主要是借助定义函数来实现程序模块化，函数把程序分成一个个模块，C语言程序执行的过程就是从主函数依次调用函数的过程； 面向对象：是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描述某个事物在整个解决问题的步骤中的行为。解决问题并不是一步一步地写函数去完成的 现在C语言的编译器都是发源于GCC(GNU Compiler Collection) C语言编译过程 C/C++源文件 预处理程序 (头文件) 预处理后文件 编译程序 汇编代码 汇编程序 目标文件/目标代码 连接程序 (库函数文件) 可执行程序 每种机器的汇编语言还不同 CPU内部有指令集，因此可以知道目标代码里的每个01指令该做什么 .lib是静态连接库文件，.dll是动态连接库文件 C是C语言的继承，它既可以进行C语言的过程化程序设计，又可以进行以抽象数据类型为特点的基于对象的程序设计，还可以进行以继承和多态为特点的面向对象的程序设计。C擅长面向对象程序设计的同时，还可以进行基于过程的程序设计，因而C++就适应的问题规模而论，大小由之。 C语言编译过程： 预处理程序（Preprocessor）读取C语言源文件，对其中以“#”开头的指令（伪指令）和特殊符号进行处理。伪指令主要包括文件包含、宏定义和条件编译指令。 生成预处理文件 编译程序（Compiler）对预处理之后的预处理文件进行词法分析和语法分析，试图找出所有不符合语法规则的部分。在确定各成分都符合语法规则后，将其“翻译”为功能等价的中间代码表示或者汇编代码。 生成汇编代码 汇编程序（Assembler）把汇编语言代码翻译成目标机器代码的过程。 生成目标文件 连接程序将一个文件中引用的符号（如变量或函数调用）与该符号在另外一个文件(如函数文件)中的定义连接起来，从而使有关的目标文件连成一个整体，最终成为可被操作系统执行的可执行文件。 生成可执行文件 gcc 与 g++ 分别是 gnu 的 c &amp; c++ 编译器 gcc/g++ 在执行编译工作的时候，总共需要4步：按照gcc的选项作用所对应的编译阶段，可将gcc的选项分为四组：预处理选项、编译选项、优化选项和连接选项。详细见下: 预处理,生成 .i 的文件 将预处理后的文件转换成汇编语言, 生成文件 .s 有汇编变为目标代码(机器代码)生成 .o 的文件 连接目标代码, 生成可执行程序 $ gcc f1.c f2.c （针对C语言源程序）执行完成后，生成默认的可执行文件a.out。-o 可以指定连接程序最后生成的可执行文件名称为file，而不是默认的a.out 一个有趣的事实就是，就本质而言，gcc和g并不是编译器，也不是编译器的集合，它们只是一种驱动器，根据参数中要编译的文件的类型，调用对应的GUN编译器而已，更准确的说法是：gcc调用了C编译器，而g调用了C++编译器。比如，用gcc编译一个c文件的话，会有以下几个步骤： 调用预处理器 调用编译器 调用汇编器 调用连接 进程是已启动的可执行程序的运行实例。进程有以下组成部分： 已分配内存的地址空间； 安全属性，包括所有权凭据和特权； 程序代码的一个或多个执行线程； 进程状态 程序： 二进制文件，静态。进程： 是程序运行的过程， 动态，有生命周期及运行状态。 ps 和 top 的区别： ps看到的是命令执行瞬间的进程信息,而top可以持续的监视 ps只是查看进程,而top还可以监视系统性能,如平均负载,cpu和内存的消耗 top还可以操作进程,如改变优先级(命令r)和关闭进程(命令k) ps主要是查看进程的，关注点在于查看需要查看的进程。top主要看cpu,内存使用情况，及占用资源最多的进程由高到低排序，关注点在于资源占用情况 C/C++包含头文件中&lt;&gt;和&quot;“的区别: 有的程序用&lt;&gt;，有的却用”&quot;，那么二者到底什么区别呢，什么情况下使用呢？&lt;&gt;和&quot;“表示编译器在搜索头文件时的顺序不同，&lt;&gt;表示从系统目录下开始搜索，然后再搜索PATH环境变量所列出的目录，不搜索当前目录，”“是表示从当前目录开始搜索，然后是系统目录和PATH环境变量所列出的目录。所以，系统头文件一般用&lt;&gt;，用户自己定义的则可以使用”&quot;，加快搜索速度。两者之间是没有多大差别的，只是为了提高查找效率而区分的.但有的编译器比较严格，因此会作严格区分 -Ldir 制定编译的时候，搜索库的路径。比如你自己的库，可以用它制定目录，不然编译器将只在标准库的目录找。这个dir就是目录的名称。 -Idir 在你是用 #include “file” 的时候, gcc/g++ 会先在当前目录查找你所制定的头文件, 如果没有找到, 他回到默认的头文件目录找, 如果使用 -I 制定了目录,他会先在你所制定的目录查找, 然后再按常规的顺序去找。对于 #include, gcc/g++ 会到 -I 制定的目录查找, 查找不到, 然后将到系统的默认的头文件目录查找 。 动态库和静态库一样也是函数的二进制的集合，但动态库在程序运行的时候动态加载到内存，而静态库在编译时期就整合到最后的可执行文件中","categories":[],"tags":[]},{"title":"贾老师的离散数学","slug":"Discrete_mathematics","date":"2022-07-22T07:42:10.000Z","updated":"2022-11-04T05:26:23.513Z","comments":true,"path":"2022/07/22/Discrete_mathematics/","link":"","permalink":"http://example.com/2022/07/22/Discrete_mathematics/","excerpt":"","text":"微信是无向图；微博是有向图 初级通路一定是简单通路； 简单通路不一定是初级通路；比如带环的简单通路 最大连通分支和极大连通分支不一样； 只有K2才有桥，其他的完全图都没有桥。 只要存在一个点出度或者入度为0，就一定不是强连通 关于邻接矩阵中 (aij) ^l 为有向图D中长度为l的通路的理解： 首先l=1时，表示行顶点到列顶点有没有长度为1的路到达，没有则为0，有一条则为1，有2条则为2.那么l=2的话，矩阵相乘，举例，n=3，(a13) ^2，根据矩阵乘法规则，其实际意义就是找顶点1到3之间长度为2的通路数，长度为1不行，因为 (a13) ^2 = a11 * a13 + a12 * a23 + a13 * a33 ，a11为0，代表它没有连自己的路，a13为1，代表1到3之间长度为1的路有1条。a13=2代表1到3之间长度为1的路有2条，(一个l=1的邻接矩阵里面的路长度只能为1)，那么a11 * a13 的意义在于，1到3之间长度为2的路为 0 * 1 = 0 个。 同理，a12 * a23 的实际意义就是，先看1到2的长度为1的路有几条，再看2到3的长度为1的路有几条，相乘即为1到2再到3之间长度为2的路的个数。 a13 * a33 同理，这样把 1到3之间所有可能连接的情况列出来，然后再找每种情况下长度为2的路再找出来即可。 长度为1的回路一定是环。 完全图一定是简单图，无向完全图中任意两个顶点之间都一定有且仅有一条边连接 欧拉图中可以有割点，只要这个割点不是奇度顶点即可，但是欧拉图中不能有桥，因为欧拉回路要求不能有重边； 如果这个哈密顿图是无向简单连通图，那么它一定没有割点或桥 n阶极大平面图，n &gt;= 3，则该图不可能存在割点和桥 Kn都没有点割集，Kn有且仅有K2有桥，但是其他Kn可以有边割集 Kn，当n &gt;= 3, Kn 一定是哈密顿图；当n为奇数时，Kn一定为欧拉图，当 n &gt;= 5, 则Kn是非平面图，n &lt;= 4 则Kn一定是极大平面图 Kr,s 当s != r 时，一定不是哈密顿图，特别地，当 s = r+1 时，是半哈密顿图 Kr,r 当r &gt;= 2时，一定是哈密顿图，r = 1 则是K2 Kr,s 当r = s时，一定存在完美匹配，否则不存在，用定义证明就行 Kr,s 当r. s &gt;= 3时，一定是非平面图 Kr,s 当r. s 均为偶数时，一定是欧拉图，否则一定不是欧拉图 在平面嵌入中可以把任何面当作外部面 同构图的对偶图不一定同构 连通图的对偶图的对偶图和该连通图也不一定同构 任何平面图都是可以4着色的 欧拉图：避桥法、逐步插入回路算法 生成树：破圈法 最小生成树：避圈法","categories":[],"tags":[]},{"title":"初尝Git","slug":"Git_Learn","date":"2022-07-22T07:42:10.000Z","updated":"2022-11-16T13:39:16.563Z","comments":true,"path":"2022/07/22/Git_Learn/","link":"","permalink":"http://example.com/2022/07/22/Git_Learn/","excerpt":"","text":"在idea上Git push 提示hint: not have locally. This is usually caused by another repository push原因： 在 GitHub上创建一个仓库A，并且初始化了readme.md这个文档. 在本地用 Git Bash初始化仓库A(一开始没有从GitHub上拉下来). 本地仓库跟远程仓库的版本不一样导致的,因为执行在 步骤1的时候，远程的版本库会有个 “commit readme.md”这个操作记录,本地仓库是不知道你有这个提交的，也就是说这个记录没在本地仓库是不存在的，所以俩个版本是不一致的. 两个不同的本地仓是可以提交到同一个远程仓的，这也是git可以多人协作开发的原因，但是切记，push前一定要pull远程仓到本地仓，防止远程仓和本地仓不一致导致push被rejected 即使仓库是public，也只有被邀请的成员可以commit，随便来个人是不能push过去的 总之一句话，基于A分支创建B分支，在B分支会将A分支里面所有内容都都带过来来，如果你在B分支里面，不需要维护A分支过来的文件，就不要对这些你不要维护的文件进行任何操作，否则合并的时候就会改变A里面你不该改动的文件，可以把B看作A的一个子类 如果在本地仓删除或增加一个文件，那么push后，远程仓也会删除或增加相应文件 远程仓增加或删除一个文件，那么pull到本地，会把那个增加或删除的文件pull下来 如果远程仓增加或者删除一个文件或者增加删除一个分支，但是我本地仓没有及时pull下来，我本地仓在想push时，会报错，这时需要先pull,再push，所以在开发的时候，需要及时pull，再push 在本地仓用 git switch -c dev 新建dev分支后，一定要用 git push --set-upstream origin dev 或者 git push origin dev 把本地分支push到远程仓，远程仓才能出现新建的分支，修改分支内容并push到远程仓的分支才不会报错 如果本地文件夹新增的文件没有commit到本地仓，那么push过去的还是老文件夹 本地仓选择不同的分支，本地文件夹的内容会随着本地仓分支的不同而改变 本地分支合并后，一定要push到远程才能让远程分支也合并 不合并之前，分支的任何增删操作不会影响到主分支，但是合并后就会 一个本地仓可以对应两个或者多个远程仓操作 远程仓删除一个文件，本地仓pull之后，本地仓对应的文件也会被删除 本地新建一个dev分支后，推送到远程仓1，那么远程仓1就多一个dev分支，推送到远程仓2，远程仓2就多一个dev分支 idea上修改文件以后不能直接push，要先commit再push，或者commit&amp;push一起，否则push的还是老文件 IDEA上上分支有书签代表是当前分支，只有处于当前分支，才能把其他分支合并到当前分支，比如A处于当前分支，那么B分支此时可以合并到A分支，不能A分支合并到B分支，除非B分支处在当前分支 git 命令行有所动作，idea也会跟着变，比如切换分支","categories":[],"tags":[]},{"title":"速通JSP","slug":"JSP_Learn","date":"2022-07-22T07:42:10.000Z","updated":"2022-11-27T06:35:46.839Z","comments":true,"path":"2022/07/22/JSP_Learn/","link":"","permalink":"http://example.com/2022/07/22/JSP_Learn/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"握手定理推论证明","slug":"Handshake lemma_Deduction","date":"2022-07-22T07:42:10.000Z","updated":"2022-10-17T08:48:06.350Z","comments":true,"path":"2022/07/22/Handshake lemma_Deduction/","link":"","permalink":"http://example.com/2022/07/22/Handshake%20lemma_Deduction/","excerpt":"","text":"握手定理推论：任意无向图或有向图的奇度顶点个数必为偶数 pf. 首先握手定理有：无论是有向图还是无向图，其所有顶点度数之和必为偶数(所有边数的2倍) 然后我们有n个奇数， 当n为偶数时，这n个奇数相加结果必为偶数，eg.3+9=12； 当n为奇数时，这n个奇数相加结果必然为奇数，eg.3+9+11=23； 其次我们有： 任意个偶数相加，其结果必为偶数； 偶数+奇数，其结果必为奇数，eg.9+4=13； 有了上面这三个结论，我们假设任意有向图或者无向图的奇度顶点个数为偶数个，则：n为奇数时，这n个奇数相加结果必然为奇数。 因此我们得出这 奇数个 奇度顶点 的 总度数 一定是奇数。 我们又知道：图的总度数一定为偶数； 我们还知道，剩下的顶点都是偶度顶点，所有偶度顶点的总度数一定是偶数； 最后我们得到这样的结果：所有偶度顶点的总度数是偶数， 奇数个 奇度顶点 的 总度数 是奇数，而奇数+偶数=奇数，因此我们得出所有顶点总度数是奇数。 这与握手定理相悖，故假设不成立。 故奇度顶点的个数一定为偶数，即证出。","categories":[],"tags":[]},{"title":"Linux操作系统","slug":"Linux_Learn","date":"2022-07-22T07:42:10.000Z","updated":"2022-12-21T02:46:24.189Z","comments":true,"path":"2022/07/22/Linux_Learn/","link":"","permalink":"http://example.com/2022/07/22/Linux_Learn/","excerpt":"","text":"win系统上cmd是DOS系统的影子 OS是裸机之上的第一层软件，与硬件关系极为密切 从技术上来说，Linus Benedict Torvalds开发的 Linux 只是一个内核。内核指的是一个提供设备驱动、文件系统、进程管理、网络通信等功能的系统软件，内核并不是一套完整的操作系统，它只是操作系统的核心。一些组织或厂商将 Linux 内核与各种软件和文档包装起来，并提供系统安装界面和系统配置、设定与管理工具，就构成了 Linux 的发行版本。 X Windows 和 Windows 很像，但是不是一个结构 $ 代表普通用户， # 号代表超级用户 unix是一个多用户多任务的操作系统。早期电脑昂贵，所以当时使用便宜的设备连接到电脑上(当时还没有键盘和显示器，使用纸带和卡片来输入输出)来使用操作系统，这个便宜的设备就是终端，也可以认为终端是一种控制台。所以可以认为电脑本身是console终端，便宜的连接设备是物理终端pty。 Linux是类unix系统，所以也继承了终端的特性。但是后来电脑逐渐便宜，也出现了显示器和键盘，所以可以使用键盘当作输入终端，显示器当作输出终端，这些终端就是虚拟终端，虚拟终端其实就是虚拟控制台，或者说是一个虚拟设备。 clear命令清除屏幕上的信息，它类似于DOS中的CLS命令 一般命令格式的命令名、选项、参数之间用空格或者制表符隔开，否则会被认为是一坨 bash是终端的名字 文件是被命名的相关信息的集合体 文件的成分： 索引节点 数据：文件的实际内容 Linux的文件名和Windows的文件名命名规则一样 Linux只有目录，没有硬盘的分区 和Windows一样，Linux所有的目录都是从根目录开始，&quot;/&quot; 利用扩展名可以区分文件的属性 以圆点 . 开头的文件名是隐含文件 文件名通配符 :0-inf 个字符，匹配当前目录下所有文件，除了.文件 ？:1个字符 [] :与[]中的任意一个匹配，比如 letter[123], 可以是letter1、letter2…… “&gt;” 是重定向，是覆盖原有文件的内容，&gt;&gt;是追加，不会删除源文件的内容 root下面的子目录 root的父目录是自己，/ 代表根目录 home 文件夹是所有用户的主目录，里面每个用户有自己的文件夹 bin放可以执行的二进制文件 sbin放的管理系统命令的文件 boot存放启动系统时引导的文件 etc文件放配置文件，子文件有password 、 root超级用户的工作目录 lib 存放共享库 dev 存放标识设备的目录 lost+found 系统非正常关闭的目录 mnt 存放安装系统的安装点 tmp存放临时文件 usr可供所有用户共享 var系统运行时要改变的数据 绝对路径名总是以 / 开头，它代表根目录 rmdir 只能删除空目录，有东西的目录不能删 链接：一个文件起多个名字的功能 硬链接：如果一个文件有硬链接，那么在其中一个目录中删除该文件，但是别的地方还有文件名指向该文件，那么在别的地方还能通过另一个文件名访问到该文件，类似程序设计中的引用机制和垃圾回收机制，只要该变量还被指针指着，那么就不会被回收。 软链接(符号链接)：建立一个快捷方式，是一个新的文件。 进程来反映程序在计算机里面动态执行的过程，一个程序可以对应几个进程 现代OS都是多任务OS，即同一时刻，里面有多个程序在执行 CPU的运算非常快，但是程序运行中，可能出现很多等待资源加载，等待输入，等待输出的状态(比如要输入密码才能继续执行，此时应该放弃对CPU的占用)，此时CPU会空转，这样CPU利用效率不高，因此人们设置多道程序。比如A程序运行，A在等待输入，那么CPU就会跑过去执行B程序。等到A输入完了，CPU再回来执行A程序。 多道程序设计：内存中同时存放多道程序，交替地在CPU中运行 程序写完保存下来是静态的，但是并发执行时，由于要和其他程序共用内存，CPU等，所以会处于一种执行、暂停执行、执行的状态。此时需要一个新的动态概念来描述这种动态的状态。为了描述程序地动态执行过程，就引入了进程的概念。 进程的特征 动态性 并发性： 调度性：调度的基本单位就是进程 异步性：各个进程向前推进的速度是不可预知的 结构性：程序段，数据段，控制结构组成 进程的基本状态： 运行态：在CPU上执行的状态 就绪态 阻塞态：程序执行着，突然要等待一个输入停下来了。 进程可以作为资源分配的单位，资源包括硬件(CPU,GPU,内存……)、软件。最紧张的资源是CPU，有专门的调度算法用来调度进程。 PID是进程的编号，在OS里面是唯一的，用PID识别进程 OS会先调度优先级高的进程，现代OS一般只允许普通用户降低进程优先级，而不允许升高进程优先级。除非root用户 shell是包裹linux内核的壳，用户可以通过shell和linux内核交互 ubuntu 安装日历 sudo apt install ncal ubuntu 修改系统时间无效，参见 ubuntu 修改系统时间无效 info命令是Linux下info格式的帮助指令。阅读 info 格式的文档，和help命令具有相同的功能 在linux中，“ll”命令指的是“ls -l”命令，它是“ls -l”命令的一个别名，但也不完全相同。ll会列出该文件下的所有文件信息，包括隐藏的文件，而ls -l只列出显式文件，说明这两个命令还是不等同的！ Cat命令(concatenate的缩写)是Linux操作系统中使用最广泛的命令行实用工具之一。它是一个标准的Linux实用程序，用于查看文件的内容，而不需要在任何文本编辑器中打开它。cat命令的另一个主要用法是将多个文件串联到一个文件中。 在LINUX中如何把2个文件中的内容合到另一个文件中 使用cat命令从文件中读入两个文件，然后将重定向到一个新的文件。这种方法可以一次性合并任意多个文件。 12将file1.txt和file2.txt合并到file.txt$ cat file1.txt file2.txt &gt; file.txt 只使用cat命令读入一个文件，然后使用&gt;&gt;将文本流追加到另一个文件的末位。 12将file1.txt追加到file2.txt的末尾$ cat file1.txt &gt;&gt; file2.txt Linux head 命令, -n&lt;行数&gt; 显示的行数。head [-n num] | [-num] [-v] filename 当 -n 后面跟正数时，会打印正数行，若跟负数，则则显示除了最后|num|(绝对值)行的其余所有行，即显示前“总行数-|num|”。例如-100，打印除最后100行外所有行 tail命令类似head，但是num前面加+号时，表示前面num-1行都不打印，然后打印剩下的 Linux 中同时使用 head 和 tail 命令。由于tail和head命令打印文件的不同部分，我们可以将这两者结合起来打印一些文件内容的高级过滤。例如，如果要从任何文件的中间读取内容，则必须同时使用这两个命令。假设我们想要读文件的第 5 行到第 10 行/etc/passwd。首先， head command 将检索前 10 行， tail command 再从 head command 检索的前 10 行中检索最后 5 行 head 。 head -n 10 /etc/passwd | tail -n 5 ‘&gt;’ 是覆盖原有内容, ‘&gt;&gt;’ 是追加内容。二者均表示 将一条命令执行结果（标准输出，或者错误输出，本来都要打印到屏幕上面的）重定向其它输出设备（文件，打开文件操作符，或打印机等等）。就是这个输出本来是要输出到屏幕上的，现在重定向输出到某个文件等 &lt;和&lt;&lt;：命令默认从键盘获得的输入，改成从文件，或者其它打开文件以及设备输入 rgrep命令用于递归查找文件里符合条件的字符串。rgrep指令的功能和grep指令类似。类似 grep -r 当重复的行并不相邻时，uniq 命令是不起作用的。这时我们就可以使用 sort cat命令法向文件添加内容的几种方法, 结尾的EOF要顶格，成对出现，可以其它字符代替。否则会报错 comm 命令用于比较两个已排过序的文件。 diff可以直接输出比较结果，不要求事先对文件进行排序。对第一个文件提出修改建议使得第一个文件与第二个文件一致。 将文件排序结果保存到原文件 不能只 sort 文件名 还得加上 -o 例如 sort testfile3 -o testfile3 cd 若目录名称省略，则变换至使用者的 home 目录 (也就是刚 login 时所在的目录) ~ 也表示为 home 目录 的意思， . 则是表示目前所在的目录， … 则表示目前目录位置的上一层目录。 ln（英文全拼：link files）命令是一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个同步的链接。当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在 其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。 Linux文件系统中，有所谓的链接(link)，我们可以将其视为档案的别名，而链接又可分为两种 : 硬链接(hard link)与软链接(symbolic link)，硬链接的意思是一个档案可以有多个名称，而软链接的方式则是产生一个特殊的档案，该档案的内容是指向另一个档案的位置。硬链接是存在同一个文件系统中，而软链接却可以跨越不同的文件系统。不论是硬链接或软链接都不会将原本的档案复制一份，只会占用非常少量的磁碟空间。 软链接： 软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式 软链接可以 跨文件系统 ，硬链接不可以 软链接可以对一个不存在的文件名进行链接 软链接可以对目录进行链接 给文件创建软链接，为log2013.log文件创建软链接link2013，如果log2013.log丢失，link2013将失效： 硬链接： 硬链接，以文件副本的形式存在。但不占用实际空间。 不允许给目录创建硬链接 硬链接只有在同一个文件系统中才能创建 硬链接，ln 源文件名 符号链接文件名，源文件名和符号链接文件名是并列关系，源被删了，符号链接依然有效。硬链接实际上和源文件在硬盘中是同一个东西，效果类似于硬盘上的一个文件，在文件系统上，在我们看来有好多个文件一样。每次删除一个文件时，只要他还有其他的硬链接存在，这个文件就不会被真正删除。只有等所有的链接文件都删除掉了，这个文件才会被真正从硬盘上删除 chmod（英文全拼：change mode）命令是控制用户对文件的权限的命令 chmod命令可以使用八进制数来指定权限。文件或目录的权限位是由9个权限位来控制，每三位为一组，它们分别是文件所有者（User）的读、写、执行，用户组（Group）的读、写、执行以及其它用户（Other）的读、写、执行。历史上，文件权限被放在一个比特掩码中，掩码中指定的比特位设为1，用来说明一个类具有相应的优先级。这样的操作与[ugoa…][[±=][rwxX]的效果等价，比如 chmod a=rwx file 和 chmod 777 file 效果相同 [权限掩码]是由3个八进制的数字所组成，比如721，721并不是一个数字，而是3个八进制数字组成的一串数字。 umask可用来设定[权限掩码]。[权限掩码]是由3个八进制的数字所组成，将现有的存取权限减掉权限掩码后，即可产生建立文件时预设的权限。比如新建一个目录，其预设权限就是 777-022=755 等价于 drwxr-xr-x 。 drwxr-xr-x 这样读：d rwx r-x r-x d:表示文件类型； rwx：表示文件所有者的对该文件所拥有的权限； r-x：表示文件所属组对该文件所拥有的权限； umask -S u=rwx,g=rx,o=rx 和 umask 0022 等价 sudo命令以系统管理者的身份执行指令，也就是说，经由 sudo 所执行的指令就好像是 root 亲自执行。 chown 需要超级用户 root 的权限才能执行此命令。 ps 命令有些与众不同，它的部分选项不能加入&quot;-&quot;，比如命令&quot;ps aux&quot;，其中&quot;aux&quot;是选项，但是前面不能带“-”。出现这样的情况，还要归咎于 UNIX 悠久的历史和庞大的派系。在不同的 Linux 发行版上，ps 命令的语法各不相同，为此，Linux 采取了一个折中的方法，即融合各种不同的风格，兼顾那些已经习惯了其它系统上使用 ps 命令的用户。 当 Linux 内核尝试决定哪些运行中的进程可以访问 CPU 时，其中一个需要考虑的因素就是进程优先级的值（也称为 nice 值）。每个进程都有一个介于 -20 到 19 之间的 nice 值。默认情况下，进程的 nice 值为 0。-20（最高优先序）到 19（最低优先序）。进程的 nice 值，可以通过 nice 命令和 renice 命令修改，进而调整进程的运行顺序。nice 命令可以给要启动的进程赋予 NI 值，但是不能修改已运行进程的 NI 值。同 nice 命令恰恰相反，renice 命令可以在进程运行时修改其 NI 值，从而调整优先级。 使用 nice 命令为一个进程设置 nice 值。记住一个普通用户可以给他拥有的进程设置 0 到 20 的 nice 值。只有 root 用户可以使用负的 nice 值。 Linux 命令是使用终端与系统交互的好方法。但是，有时可能需要一段时间才能完成手头的任务。这迫使用户等待相当长的时间。这时可以让当前事务在后台运行。运行 Linux 后台命令的最简单方法是在命令后添加与号 (&amp;)。例如，如果从终端启动 gedit 文本编辑器，则在关闭编辑器之前无法使用 shell。但是，当您在命令中添加额外的 &amp; 时，您将能够立即使用 shell。比如：$ gedit &amp; 对于需要长时间执行的任务，&amp;符号可以使当前终端窗口不被占用，这样就能继续在同一个终端上工作，甚至关闭终端窗口也不会影响任务的正常执行。不过需要注意的是，如果要求这个任务输出内容到标准输出中（例如 echo 或 ls），即便使用了 &amp;，也会等待这些输出任务在前台运行完毕；当使用 &amp;将一个进程放置到后台运行的时候，Bash 会提示这个进程的进程 ID。在 Linux 系统中运行的每一个进程都有一个唯一的进程 ID，我们可以使用进程 ID 来暂停、恢复或者终止对应的进程。 nohup 英文全称 no hang up（不挂起）。用于在系统后台不挂断地运行命令，退出终端不会影响程序的运行。如果要停止运行，你需要使用以下命令查找到 nohup 运行脚本到 PID，然后使用 kill 命令来删除：ps -aux jobs命令：查看当前终端放入后台的工作 wait是一个shell命令，它能保持等待状态， 直到指定进程运行完成，而且返回进程的退出状态值。 而且Wait命令还可以用于等待特定的进程ID和作业ID并返回其终止状态。在什么情况下需要使用Wait命令呢？​ 在执行较大的自动化脚本时，某些命令或者模块的运行依赖于其它命令或者模块的运行结果， 这时我们需要使这些依赖别的模块结果的模块一直等待， 直到被依赖的模块完成并返回， 然后执行后续的模块或命令，在这种情况下，我们可以使用Wait命令保持等待状态直到上一个模块结束。​ Wait命令可以用于监视先前的过程，根据被等待的命令的运行结果，它将返回Exit状态。例如，如果我们要等待进程ID是13245，我们可以使用“ wait 13245”， 当此进程（PID 13245）完成， wait命令将返回此进程（PID 13245）退出时的返回值。 gzip命令用于压缩文件。文件经它压缩过后，其名称后面会多出&quot;.gz&quot;的扩展名。 zip和gzip的区别 zip是将文件打包为zip格式的压缩文件 gzip是将文件打包为tar.gz格式的压缩文件 unzip是从zip包中解压出某个文件 gunzip从tar.gz包中解压出某个文件 gzip压缩后原来的文件则没有了，解压缩也一样 zip压缩完会保留原文件 控制台的概念与终端含义非常相近，其实现在我们经常用它们表示相同的东西，但是在计算机的早期时代，它们确实是不同的东西。我们在平时的使用中压根就不区分 Linux 中的终端与控制台。 根目录：每一个文件和目录从根目录开始，只有root用户具有该目录下的写权限。 apt 命令执行需要超级管理员权限(root)，也就是前面必须加 sudo命令 对于文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户,即文件所有者。文件所有者以外的用户又可以分为文件所有者的同组用户和其他用户。因此，Linux系统按文件所有者user、文件所有者同组用户group和其他用户other来规定了不同的文件访问权限。 chown命令用来更改文件属主，也可以同时更改文件属组：sudo chown root.root ceshi.txt Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。 rm -rf命令十分危险，删除之前一定要三思。尤其以下命令 Linux中根目录用/表示。而windows表示目录的方式与Linux有所不同，Windows下有磁盘分区的概念，而Linux下只有目录的概念，所以‘/’所表示的意义在两个系统中有所不同。 ‘/’在linux中表示根目录。在Linux系统中，除根目录(root)以外，所有文件和目录都包含在相应的目录文件中。Linux文件系统采用带链接的树形目录结构，即只有一个根目录（通常用“/”表示），其中含有下级子目录或文件的信息；子目录中又可含有更下级的子目录或者文件的信息。这样一层一层地延伸下去，构成一棵倒置的树。 ‘/’在windows中也表示根目录，但此跟目录非彼根目录。windows对磁盘分区后会有多个磁盘，通常系统会装在C盘。windows有多个磁盘所以就会有‘多个根目录’，在dos命令模式下，在D盘的某文件夹中输入‘cd/’命令回车后会直接回到D盘的根目录。其它磁盘下也会回到该磁盘的目录。在哪个磁盘下使用‘/’，它就表示哪个磁盘的根目录。 服务器上的 Linux 是不安装图形界面的，只能在控制台模式下使用，以尽量节省服务器资源。而我们在学习过程中使用的 Linux 是带图形界面的，以满足初学者的需求，降低学习成本。 Linux Unix win 的宿主语言都是C语言 每种机器的汇编语言还不同 CPU内部有指令集，因此可以知道目标代码里的每个01指令该做什么 .lib是静态连接库文件，.dll是动态连接库文件 gcc hello.c -o hello 会将 hello.c 文件预处理成 hello 文件，若不加 -o 即 gcc hello.c，则自动会生成 a.out 文件 vim :%!xdd 查看程序在磁盘上的十六进制存储状态，显示出来的第一列是内存上的地址。回到文本格式按下:%!xdd -r :%!xdd -b 查看程序在磁盘上的二进制存储状态， 进入gbd后，用 shell+ 的命令可以运行普通的linux命令 shell也是一个软件，包裹着Linux内核的壳，用户可以通过shell与内核交互，不同发行版本的linux的shell还不同 shell不需要编译，是解释执行的方式，JAVA也是解释执行 shell是一种用户界面，它也是一个命令解释器，也是一种编程语言 安全性、稳定性比较高的环境，要求更稳定的shell，图形界面容易崩溃 常用shell类型(Ubuntu用的是第4种) 1. Bourne shell (sh) 2. C-shell (csh) 3. Korn shell (ksh) 4. Bourne Again shell (bash) ./ [文件名]，表示执行该文件(chmod 中改的 rwx 中的 x 就是可执行权限，如果不添加 x 权限，执行该文件时可能会提示权限不够) shell变量在赋值时 = 两边不能有空格 $变量名 才能使用变量 若字面量里面有空格 制表符 换行符，则必须用引号括起来 shell脚本的注释是 # shell脚本的第一行写 #!/bin/bash 代表该shell脚本只能在bash类型的shell解释器下执行， #! 告诉系统其后路径所指定的程序即是解释此脚本文件的 Shell 程序。 位置参数在脚本执行的时候自动赋值的，脚本名会自动赋给 $0 位置参数和shift会和循环结构配合使用 if [ $leap -eq 0 ] if语句要加[]， 且[]里面要加空格 Linux 3类引号 双引号 &quot; 单引号 ’ 倒引号 ` 除了3类引号和转义字符 \\ 之外，其余字符都为普通字符 后台进程的调度优先级都低于前台进程的优先级 “|”是Linux管道命令操作符，简称管道符。使用此管道符“|”可以将两个命令分隔开，“|”左边命令的输出就会作为“|”右边命令的输入，此命令可连续使用，第一个命令的输出会作为第二个命令的输入，第二个命令的输出又会作为第三个命令的输入，依此类推。比如 1ls | grep m?.c | wc -l {} 不会新建进程，()会新建进程 {}里面的值要和{}空格隔开，但是()不需要 位置参数可以用来向shell脚本传值 Shell 支持任意数目的分支，当分支比较多时，可以使用 if elif else 结构，此时分支结束时可以只有个 fi 但是若用 if else if 这种级联结构，则有多少if，结尾跟多少fi ps （英文全拼：process status）命令用于显示当前进程的状态，类似于 windows 的任务管理器。 shell测试命令test、[ ]、[[ ]] test可用于测试表达式。在shell中，几乎所有的判断都使用test实现。 条件测试时，在 [[ 中使用 &amp;&amp; 和 || , 在 [ 中使用 -a 和 -o 表示逻辑与和逻辑或。 [] 完全等价于test，只是写法不同。双中括号[ [] ]基本等价于[] ，它支持更多的条件表达式，还允许在双中括号内使用逻辑运算符&quot;&amp;&amp;&quot;、&quot;||&quot;、&quot;!“和”()&quot;，但这些使用单中括号都能实现，只不过多写几个单中括号而已。单中括号[] 无法实现的功能是正则表达式匹配，而[ [] ]可以实现。因此，在能使用单中括号的情况下，无需考虑使用双中括号。 shift命令用于对参数的移动(左移)，通常用于在不知道传入参数个数的情况下依次遍历每个参数然后进行相应处理，有一个shift 就向左移一位 shell中的缩进与C语言中的缩进一样，没有实际意义 break n 。n 表示跳出循环的层数，如果省略 n，则表示跳出当前的循环。 echo &quot;today is date &quot; 后面用倒引号括住，date就变成了一个命令。同样的还有 c=pwd。另一种方式是 c=$(pwd) 也是把pwd变成命令，不加()括住就是变量。 即倒引号括住 和 $() 的效果是一样的。 文件系统：OS来管理使用文件所用的规范 Linux每个文件都有一个inode号(索引节点)，是唯一的，用来区别别的文件。 ip地址与域名的关系是一对多的关系，同一个ip地址可以对应多个域名，一个域名只能对应一个ip地址 源本质是个服务器 .lib是静态连接库文件，.dll是动态连接库文件 C是C语言的继承，它既可以进行C语言的过程化程序设计，又可以进行以抽象数据类型为特点的基于对象的程序设计，还可以进行以继承和多态为特点的面向对象的程序设计。C擅长面向对象程序设计的同时，还可以进行基于过程的程序设计，因而C++就适应的问题规模而论，大小由之。 C语言编译过程： 预处理程序（Preprocessor）读取C语言源文件，对其中以“#”开头的指令（伪指令）和特殊符号进行处理。伪指令主要包括文件包含、宏定义和条件编译指令。 生成预处理文件 编译程序（Compiler）对预处理之后的预处理文件进行词法分析和语法分析，试图找出所有不符合语法规则的部分。在确定各成分都符合语法规则后，将其“翻译”为功能等价的中间代码表示或者汇编代码。 生成汇编代码 汇编程序（Assembler）把汇编语言代码翻译成目标机器代码的过程。 生成目标文件 连接程序将一个文件中引用的符号（如变量或函数调用）与该符号在另外一个文件(如函数文件)中的定义连接起来，从而使有关的目标文件连成一个整体，最终成为可被操作系统执行的可执行文件。 生成可执行文件 gcc 与 g++ 分别是 gnu 的 c &amp; c++ 编译器 gcc/g++ 在执行编译工作的时候，总共需要4步：按照gcc的选项作用所对应的编译阶段，可将gcc的选项分为四组：预处理选项、编译选项、优化选项和连接选项。详细见下: 预处理,生成 .i 的文件 将预处理后的文件转换成汇编语言, 生成文件 .s 有汇编变为目标代码(机器代码)生成 .o 的文件 连接目标代码, 生成可执行程序 $ gcc f1.c f2.c （针对C语言源程序）执行完成后，生成默认的可执行文件a.out。-o 可以指定连接程序最后生成的可执行文件名称为file(可不带.out后缀)，而不是默认的a.out 不像 Windows，Linux 不以文件后缀来区分可执行文件，Linux 下的可执行文件后缀理论上可以是任意的，这里的.out只是用来表明它是 GCC 的输出文件。不管源文件的名字是什么，GCC 生成的可执行文件的默认名字始终是a.out 虽然Linux 不以后缀名区分文件，但是最好带上正确的后缀名，一来容易区分，而来vim这种文编编辑器可以对不同后缀的文件采用不同的功能和高亮 一个有趣的事实就是，就本质而言，gcc和g并不是编译器，也不是编译器的集合，它们只是一种驱动器，根据参数中要编译的文件的类型，调用对应的GUN编译器而已，更准确的说法是：gcc调用了C编译器，而g调用了C++编译器。比如，用gcc编译一个c文件的话，会有以下几个步骤： 调用预处理器 调用编译器 调用汇编器 调用连接 进程是已启动的可执行程序的运行实例。进程有以下组成部分： 已分配内存的地址空间； 安全属性，包括所有权凭据和特权； 程序代码的一个或多个执行线程； 进程状态 程序： 二进制文件，静态。进程： 是程序运行的过程， 动态，有生命周期及运行状态。 ps 和 top 的区别： ps看到的是命令执行瞬间的进程信息,而top可以持续的监视，默认状态显示的是cpu密集型的进程，并且每5秒钟更新一次。 ps只是查看进程,而top还可以监视系统性能,如平均负载,cpu和内存的消耗 top还可以操作进程,如改变优先级(命令r)和关闭进程(命令k) ps主要是查看进程的，关注点在于查看需要查看的进程。top主要看cpu,内存使用情况，及占用资源最多的进程由高到低排序，关注点在于资源占用情况 Ctrl-l 等价于 clear 控制字符(ctrl z ctrl c ctrl d 等等)都是可以通过stty命令更改的，可在终端中输入命令&quot;stty -a&quot;查看终端配置。 ctrl + z 挂起键，给前台进程组中所有进程发送SIGTSTP信号, 并挂起进程。被挂起的进程并没有真正结束，可以使用fg或bg命令恢复被挂起的进程。 fg将后台中的命令调至前台继续运行, bg将一个在后台暂停的命令，变成继续执行 [1]+ 已停止 yes ok 其中 [1] 代表 工作号 一个终端上的程序在另一个终端上用 ps 命令看不到，但是用 top 或者 glances 可以看到 C/C++包含头文件中&lt;&gt;和&quot;“的区别: 有的程序用&lt;&gt;，有的却用”&quot;，那么二者到底什么区别呢，什么情况下使用呢？&lt;&gt;和&quot;“表示编译器在搜索头文件时的顺序不同，&lt;&gt;表示从系统目录下开始搜索，然后再搜索PATH环境变量所列出的目录，不搜索当前目录，”“是表示从当前目录开始搜索，然后是系统目录和PATH环境变量所列出的目录。所以，系统头文件一般用&lt;&gt;，用户自己定义的则可以使用”&quot;，加快搜索速度。 对于类似let x+y这样的写法，Shell 虽然计算了 x+y 的值，但却将结果丢弃；若不想这样，可以使用let sum=x+y将 x+y 的结果保存在变量 sum 中。这种情况下 (( )) 显然更加灵活，可以使用$((x+y))来获取 x+y 的结果 只有使用$((算术表达式))形式才能返回表达式的值，比如 1234$ echo &quot;((12*9))&quot; ((12*9))$ echo &quot;$((12*9))&quot; 108","categories":[],"tags":[]},{"title":"关于php学习中setcookie的疑惑","slug":"PHP_SetCookie_Problem","date":"2022-07-22T07:42:10.000Z","updated":"2022-11-26T14:04:26.554Z","comments":true,"path":"2022/07/22/PHP_SetCookie_Problem/","link":"","permalink":"http://example.com/2022/07/22/PHP_SetCookie_Problem/","excerpt":"","text":"疑惑1 我们在web程序设计书上看到了一串奇怪的代码，令人费解，见下： 12345678910&lt;?php if (!isset($_COOKIE[&quot;visit_time&quot;])) &#123; setcookie(&quot;visit_time&quot;, date(&quot;y-m-d H:i:s&quot;)); echo &quot;欢迎您的第一次！&quot;.&quot;&lt;br&gt;&quot;; &#125;else &#123; setcookie(&quot;visit_time&quot;, date(&quot;y-m-d H:i:s&quot;), time() + 60); echo &quot;您上次访问网站的时间为&quot;.$_COOKIE[&quot;visit_time&quot;].&quot;&lt;br&gt;&quot;; &#125; echo &quot;&lt;br&gt;&quot;.&quot;您本次访问网站的时间为&quot;.date(&quot;y-m-d, H:i:s&quot;).&quot;&lt;br&gt;&quot;;?&gt; 我们原以为书上写错了，因为 else 后面先是又设置了一次 setcookie(“visit_time”, date(“y-m-d H:i:s”), time() + 60); 再输出上次的 $_COOKIE[“visit_time”]值，我们奇怪，既然又设置了一次 setcookie(“visit_time”, date(“y-m-d H:i:s”), time() + 60); 那么后面echo出来的不应该是本次访问时间吗？怎么能够输出上次访问的时间？我们疑惑地打了一遍代码，发现书上没写错，就是输出的上次的访问时间。怎么回事呢？先看看下面的这个博客： PHP setcookie()首次存储不上值 好了，我们按照这篇博客说的验证一下： 还是那串代码，我们在if条件后面加一个输出 $_COOKIE[“visit_time”] 的值： 1234567891011&lt;?php if (!isset($_COOKIE[&quot;visit_time&quot;])) &#123; setcookie(&quot;visit_time&quot;, date(&quot;y-m-d H:i:s&quot;)); echo &quot;欢迎您的第一次！&quot;.&quot;&lt;br&gt;&quot;; echo &quot;您第1次访问网站的时间为&quot;.$_COOKIE[&quot;visit_time&quot;].&quot;&lt;br&gt;&quot;; &#125;else &#123; setcookie(&quot;visit_time&quot;, date(&quot;y-m-d H:i:s&quot;), time() + 60); echo &quot;您上次访问网站的时间为&quot;.$_COOKIE[&quot;visit_time&quot;].&quot;&lt;br&gt;&quot;; &#125; echo &quot;&lt;br&gt;&quot;.&quot;您本次访问网站的时间为&quot;.date(&quot;y-m-d, H:i:s&quot;).&quot;&lt;br&gt;&quot;;?&gt; 我们在浏览器中第一次看到： 123456欢迎您的第一次！Notice: Undefined index: visit_time in D:\\XAMPP\\XAMPPInstall\\htdocs\\Project\\table4.php on line 13您本次访问网站的时间为您本次访问网站的时间为22-10-12, 11:40:18 没有echo出 $_COOKIE[“visit_time”] 的值，说明第一次确实像博客上说的，“前面第一步设置cookie的头信息，也还没有返回给客户端（因为php是服务器端的脚本文件，必须发给浏览器，，浏览器下次访问服务器时，藏在header里的setcookie才能起作用，php要从上到下把语句执行完才会返回给客户端）” 我们点击第2次 123您上次访问网站的时间为22-10-12 11:40:18您本次访问网站的时间为22-10-12, 11:44:16 第2次能输出 $_COOKIE[“visit_time”] 的值了，而且我们发现 $_COOKIE[“visit_time”] 的值，是上一次我们访问浏览器的时间，这就说明我们每次设置一次setcookie，其值得待到下一次访问时才接受得到。 $_COOKIE[“visit_time”] 存放的都是上次的值。 疑惑2 还有一个疑惑 123456789101112&lt;?php setcookie(&quot;visit_time&quot;, 2, time() + 5); echo &quot;您1次访问网站的时间为&quot;.$_COOKIE[&quot;visit_time&quot;].&quot;&lt;br&gt;&quot;; setcookie(&quot;visit_time&quot;, 3, time() + 5); echo &quot;您2次访问网站的时间为&quot;.$_COOKIE[&quot;visit_time&quot;].&quot;&lt;br&gt;&quot;; setcookie(&quot;visit_time&quot;, 4, time() + 5); echo &quot;您3次访问网站的时间为&quot;.$_COOKIE[&quot;visit_time&quot;].&quot;&lt;br&gt;&quot;; setcookie(&quot;visit_time&quot;, 5, time() + 5); echo &quot;您4次访问网站的时间为&quot;.$_COOKIE[&quot;visit_time&quot;].&quot;&lt;br&gt;&quot;; setcookie(&quot;visit_time&quot;, 6, time() + 5); echo &quot;您5次访问网站的时间为&quot;.$_COOKIE[&quot;visit_time&quot;].&quot;&lt;br&gt;&quot;;?&gt; 第一次点击，输出 123456789101112131415Notice: Undefined index: visit_time in D:\\XAMPP\\XAMPPInstall\\htdocs\\Project\\table4.php on line 21您1次访问网站的时间为Notice: Undefined index: visit_time in D:\\XAMPP\\XAMPPInstall\\htdocs\\Project\\table4.php on line 23您2次访问网站的时间为Notice: Undefined index: visit_time in D:\\XAMPP\\XAMPPInstall\\htdocs\\Project\\table4.php on line 25您3次访问网站的时间为Notice: Undefined index: visit_time in D:\\XAMPP\\XAMPPInstall\\htdocs\\Project\\table4.php on line 27您4次访问网站的时间为Notice: Undefined index: visit_time in D:\\XAMPP\\XAMPPInstall\\htdocs\\Project\\table4.php on line 29您5次访问网站的时间为 输出不了，在5s内再次访问，输出： 12345您1次访问网站的时间为6您2次访问网站的时间为6您3次访问网站的时间为6您4次访问网站的时间为6您5次访问网站的时间为6 5s之后再次访问，输出： 123456789101112131415Notice: Undefined index: visit_time in D:\\XAMPP\\XAMPPInstall\\htdocs\\Project\\table4.php on line 21您1次访问网站的时间为Notice: Undefined index: visit_time in D:\\XAMPP\\XAMPPInstall\\htdocs\\Project\\table4.php on line 23您2次访问网站的时间为Notice: Undefined index: visit_time in D:\\XAMPP\\XAMPPInstall\\htdocs\\Project\\table4.php on line 25您3次访问网站的时间为Notice: Undefined index: visit_time in D:\\XAMPP\\XAMPPInstall\\htdocs\\Project\\table4.php on line 27您4次访问网站的时间为Notice: Undefined index: visit_time in D:\\XAMPP\\XAMPPInstall\\htdocs\\Project\\table4.php on line 29您5次访问网站的时间为 又输出不了了，这一点我们上面已经弄明白了，cookie存在的情况下，第2次访问才能访问得到。但是为什么输出得全是6呢？ 因为 cookie可以重名，但同名同path的cookie视为相同cookie，后面的会覆盖前面的 所以最后一个6覆盖了前面所有的值。 疑惑3 再来说 1234setcookie(&quot;visit_time&quot;, 2, time() + 5); echo &quot;您1次访问网站的时间为&quot;.$_COOKIE[&quot;visit_time&quot;].&quot;&lt;br&gt;&quot;; setcookie(&quot;visit_time&quot;, 3, time() + 5); echo &quot;您2次访问网站的时间为&quot;.$_COOKIE[&quot;visit_time&quot;].&quot;&lt;br&gt;&quot;; 第1次点击，输出： 123456Notice: Undefined index: visit_time in D:\\XAMPP\\XAMPPInstall\\htdocs\\Project\\table4.php on line 21您1次访问网站的时间为Notice: Undefined index: visit_time in D:\\XAMPP\\XAMPPInstall\\htdocs\\Project\\table4.php on line 23您2次访问网站的时间为 5s内点第2次，输出： 12您1次访问网站的时间为3您2次访问网站的时间为3 5s后点，输出： 123456Notice: Undefined index: visit_time in D:\\XAMPP\\XAMPPInstall\\htdocs\\Project\\table4.php on line 21您1次访问网站的时间为Notice: Undefined index: visit_time in D:\\XAMPP\\XAMPPInstall\\htdocs\\Project\\table4.php on line 23您2次访问网站的时间为 这些我们都知道什么原因了，但是看下面2串代码： 1234setcookie(&quot;visit_time&quot;, 2); echo &quot;您1次访问网站的时间为&quot;.$_COOKIE[&quot;visit_time&quot;].&quot;&lt;br&gt;&quot;; setcookie(&quot;visit_time&quot;, 3, time() + 5); echo &quot;您2次访问网站的时间为&quot;.$_COOKIE[&quot;visit_time&quot;].&quot;&lt;br&gt;&quot;; 第一次点击，输出： 123456Notice: Undefined index: visit_time in D:\\XAMPP\\XAMPPInstall\\htdocs\\Project\\table4.php on line 21您1次访问网站的时间为Notice: Undefined index: visit_time in D:\\XAMPP\\XAMPPInstall\\htdocs\\Project\\table4.php on line 23您2次访问网站的时间为 5s内点第2次，输出： 12您1次访问网站的时间为3您2次访问网站的时间为3 5s后点，输出： 123456Notice: Undefined index: visit_time in D:\\XAMPP\\XAMPPInstall\\htdocs\\Project\\table4.php on line 21您1次访问网站的时间为Notice: Undefined index: visit_time in D:\\XAMPP\\XAMPPInstall\\htdocs\\Project\\table4.php on line 23您2次访问网站的时间为 我们第1个setcookie时没有设置失效时间的，第2个setcookie设置了，我们根据结果推断出，第2个同名同path cookie不仅把上一个value覆盖了，还把失效时间更新了。为了验证我们的推断，我们看下面一串代码： 123456&lt;?php setcookie(&quot;visit_time&quot;, 2, time() + 5); echo &quot;您1次访问网站的时间为&quot;.$_COOKIE[&quot;visit_time&quot;].&quot;&lt;br&gt;&quot;; setcookie(&quot;visit_time&quot;, 3); echo &quot;您2次访问网站的时间为&quot;.$_COOKIE[&quot;visit_time&quot;].&quot;&lt;br&gt;&quot;;?&gt; 第一次点击，输出： 12345Notice: Undefined index: visit_time in D:\\XAMPP\\XAMPPInstall\\htdocs\\Project\\table4.php on line 21您1次访问网站的时间为Notice: Undefined index: visit_time in D:\\XAMPP\\XAMPPInstall\\htdocs\\Project\\table4.php on line 23您2次访问网站的时间为 5s内点第2次，输出： 12您1次访问网站的时间为3您2次访问网站的时间为3 5s后点，输出： 12您1次访问网站的时间为3您2次访问网站的时间为3 说明第2个同名同path cookie不仅把上一个value覆盖了，还把失效时间更新了，从5秒后失效更新为当前会话时间内有效。","categories":[],"tags":[]},{"title":"python学习技巧","slug":"Python_Learn_Tips","date":"2022-07-22T07:42:10.000Z","updated":"2022-12-04T12:29:40.338Z","comments":true,"path":"2022/07/22/Python_Learn_Tips/","link":"","permalink":"http://example.com/2022/07/22/Python_Learn_Tips/","excerpt":"","text":"Python字符串是不可变的。这意味着一旦创建了字符串，便无法对其进行修改，如果您进行了修改，则它将创建一个新的python字符串。 对于eval()括号中的的字符串(非数字)，如果字符串带的是单引号或者是双引号都会引起NameError,这是因为eval()函数在处理字符串时会去掉其两个引号。正确应该使用一个单引号包含一个双引号组成的三引号来包含字符串。 python 如果使用一个未被定义的变量,解释器会报错.关键是括号中粉底的那三个词,用来解释python中怎么才叫定义一个变量,也就是说你想定义一个变量必须要给它赋值,只有给一个名称赋了值,才叫定义了一个变量.//有的语言中,可以使用某个关键字先声明一个变量,而赋值的操作可以后面做;还有的语言,你可以只声明变量而不赋值,后面使用该未赋值的变量时,解释器会根据你声明的类型赋一个默认值,等等;也就是说不同语言对变量的处理逻辑可能不同.而python对变量的处理逻辑就是:定义和赋值二者绑在一块了,即赋值的过程同时完成了&quot;定义+赋值&quot;,不存在&quot;只定义&quot;这个过程。python还是一个强类型语言，每个变量的类型必须在编译时确定，而只有赋值才能确定类型。 Python的布尔类型有两个值True和False（注意大小写要区分） python 的方法一定要加括号 字符串切片后返回字符串 有个切片得小技巧，可以看到python切片功能的强大，在做古风排版时：123456n = int(input())str1 = input()if len(str1)%n != 0: str1 = str1 + (n - (len(str1)%n)) * &#x27; &#x27;#用空格补齐字符串for i in range(n): print(str1[i::n]) 123456n = int(input())str1 = input()if len(str1)%n != 0: str1 = str1 + (n - (len(str1)%n)) * &#x27; &#x27;#用空格补齐字符串for i in range(n): print(str1[i::n][::-1]) #str1先和第一个括号结合切片返回一个切片后的字符串，再与第2个[]结合逆序输出 对于python的print(), 字符串和数值类型，可以直接输出; 对于变量，无论什么类型，数值、字符、列表、字典… 可以直接输出 len()方法返回对象（字符、列表、元组等）长度或项目个数，不像C只能用于字符串 python如何判断一个列表中的数值是否全部小于某个数：all(map(lambda x: x &lt; num, list1)) 想把字符数组转为数字型数组，可以用 1234numbers = [‘1’, ‘5’, ‘10’, ‘8’] numbers = list(map(int, numbers))// 或者[int(i) for i in numbers] 如果numbers是纯数字的字符串也能用这种方法转为纯数字的列表 把num=123这个整数转为列表：可以print(list(str(num)))，但不能print(list(num))，因为num不可迭代，list必须用于可迭代对象 字符串切片后返回字符串，列表切片后返回列表 try except和if-else一样，都是分支结构，但是try-except更高阶，因为try-except给了我们试错的机会，如果try那个分支出现错误，不会立马报错，而是跳到except去执行下面的代码，但是if如果出现错误，会立马报错，并程序停止执行。多用try-except，就像我们的生活。 如果您有一个文件a.py，并且在其中有一些功能： 1234567def b():# Somethingreturn 1def c():# Somethingreturn 2 你想把它们导入到另一个.py文件里并调用其中的函数，你得写 1from a import b, c python中 is, is not 对比的是两个变量的内存地址，==,!= 对比的是两个变量的值 python 中没有 || ，和 &amp;&amp;，但是有 == 和 != python isdigit()和isalpha()都是在判断字符串，而非真的数字和字母 python eval(str(n)[::-1]) 整数逆序的方法，利用可迭代对象的切片，这在C语言里很难操作 字符串变列表可以用list() 当for循环有两个需要迭代的对象时，要用zip对这多个变量封装，否则会报错。比如： 1234starts = [0,1,2,3,4]ends = [5,6,7,8,9]for start, end in starts, ends: print((start, end)) 这样会报错 1234starts = [0,1,2,3,4]ends = [5,6,7,8,9]for start, end in zip(starts, ends): print((start, end)) 这样才是对的 python 中 单个字符不能和整数直接运算，不像C语言 注意， python 可以这样写 65 &lt;= ord(i) &lt;= 90 ，这是和C语言很不同的地方 import 模块：导入一个模块；注：相当于导入的是一个文件夹，是个相对路径。 from…import：导入了一个模块中的一个函数；注：相当于导入的是一个文件夹中的文件，是个绝对路径。 from…import *：是把一个模块中所有函数都导入进来; 注：相当于导入的是一个文件夹中所有文件，所有函数都是绝对路径。 from…import *语句与import区别在于： import 导入模块，每次使用模块中的函数都要是定是哪个模块。 from…import * 导入模块，每次使用模块中的函数，直接使用函数就可以了；注因为已经知道该函数是那个模块中的了。 一般来说，推荐使用 import 语句，避免使用 from … import，因为这样可以使你的程序更加易读，也可以避免名称冲突。 python用来计算微积分的库主要用的是sympy库 二分法求解方程的条件是，初始范围必须包含根 列表是个筐，什么都能往里装，甚至可以往里装语句，比如列表推导式：[expression for item in iterable], a = [i for i in range(0, 10)], 更有甚者，可以这样写 [表达式 for 变量 in 列表 if 条件]，a = [i for i in range(0, 10) if i % 2 == 0]，更有甚者，可以这样写 [表达式 for 变量 in 列表 if 条件 if 条件]， 还能这样用： group_labels = [’{}月’.format(i) for i in range(1, 13)]，显示1-12月的字符串列表 相应的，字典也有字典推导式 匿名函数只能写一个表达式，多了不行，不用写return，表达式的值会自动返回 map(function, iterable, …)，后面的iterable参数可以不止有1个。 map()函数，当有多个可迭代对象时，最短的可迭代对象耗尽则整个迭代就将结束。比如 min = map(min, L1, L2), 其中L1和L2是两个长度不同的列表，这个表达式的作用是依次取出L1和L2对应的元素并拿出小的那一个，当L1遍历完了，就会结束。 map(function, iterable,…)还可用于数据清洗 (i for i in range(0, 10) if i % 2 == 0) 这是生成器表达式，和列表推导式的区别就是把[]换成(),生成器遵循迭代器的协议，有惰性，需要的时候才去取数据，这样减少占用内存消耗，生成器对象也是可迭代的，需要取数据的时候，就用循环打印出来，比如： 123456a = (i for i in range(0, 10) if i % 2 == 0)print(a)# 打印不出来，因为我们还没写出需要用到生成器的句子for i in a: print(i)# 能打印出来，因为我们已经写出了需要生成器的句子 生成器用于数据量比较大的情况，否则就没必要 类是对象的模板或蓝图，类是对象的抽象化，对象是类的实例化。类不代表具体的事物，而对象表示具体的事物 创建函数的关键字是def，创建类的关键字是class， 构造器，迭代器，生成器，别搞混了，python中的构造器必须有，不同于java init()方法的self参数指向创建的实例本身，第一个参数，永远都是self，并且实例化的时候不用传入self的实参，解释器会自动传入 在类里面定义的方法，和普通的函数的唯一区别是，第一个参数是self，其他没有什么区别 文件写完一定要close，否则会占用内存，或者程序突然崩溃，那么文件就白写了 文件路径，win用\\，Unix用/ 文件对象不仅是一个可迭代的，它是一个迭代器，这就是为什么它只能遍历文件一次(读完后光标在文本最末位)。您可以使用.seek(0)重置文件光标，但在大多数情况下，您应该只迭代一次文件。 由于读写文件可能产生error，一旦出错，后面的f.close()可能不会被调用，可靠的方法是用with，不仅会自动关闭文件，而且出错了也能关闭 类里面的方法可以返回值 在 Python 中，有一个特殊的常量 None（N 必须大写）。和 False 不同，它不表示 0，也不表示空字符串，而表示没有值，也就是空值。 这里的空值并不代表空对象，即 None 和 []、“” 不同 None 有自己的数据类型，我们可以在 IDLE 中使用 type() 函数查看它的类型，执行代码如下：type(None) &lt;class ‘NoneType’&gt; 它属于 NoneType 类型。需要注意的是，None 是 NoneType 数据类型的唯一值（其他编程语言可能称这个值为 null、nil 或 undefined），也就是说，我们不能再创建其它 NoneType 类型的变量，但是可以将 None 赋值给任何变量。如果希望变量中存储的东西不与任何其它值混淆，就可以使用 None。除此之外，None 常用于 assert、判断以及函数无返回值的情况。举个例子，在前面章节中我们一直使用 print() 函数输出数据，其实该函数的返回值就是 None。因为它的功能是在屏幕上显示文本，根本不需要返回任何值，所以 print() 就返回 None。 spam = print(‘Hello!’) Hello! None == spam True 对于所有没有 return 语句的函数定义，Python 都会在末尾加上 return None，使用不带值的 return 语句（也就是只有 return 关键字本身），那么就返回 None。 Python中print函数中中逗号和加号的区别： print(“hello” + “world”) 输出：helloworld print(“hello”, “world”) 输出：hello world 这里发现加号的作用是连接字符串 而逗号相当于用空格连接字符串。 print(“hello” + 123)： 输出：TypeError: must be str, not int print(“hello”, 123) 输出：hello 123、 这里发现加号在Str类型与Num类型相加的出现了类型错误 逗号连接正常并返回字符串结果。 加号 + ：两边只能是相同数据类型，在Python中主要是运算符的存在，而字符串等类型相加只是Python中的内置方法。 逗号 , : 在这里逗号更多的代表用空格的连接。 当 + 号两边都是列表时，可以将两个列表拼起来 upper()方法遇到大写字母和其他字符时，都不做动作，只有碰见小写字母时才会做动作 str.upper()，返回原字符串的副本，这个方法会return一个新的字符串，但不会改动原来字符串的内容，如果单纯 str.upper() 再输出str, 发现str没有变化，但是str2 = str.upper()，就可以把改动后的新字符串保存在str2中 print() 输出单个换行符 二维数组的切片： 12345a = np.random.rand(3, 3)print(a)a[0:3, 0:3] = 3print()print(a) JAVA中构造方法，实例方法，类方法，有什么区别？ 构造方法：构造方法是用来构造类的对象的，方法名和类名相同没有返回值。一般用 new 构造方法名() 来创建该类的对象。在不写构造方法的情况下会有一个默认的无参构造方法，当然你也可以重写和重载构造方法。 实例方法：即：成员方法。简单地说就是可以通过类的实例（某个对象）调用的方法，也就是我们正常情况下使用的方法。 类方法：简单地说就是直接可以用类名调用的方法，也就是被关键字static修饰的方法，它不需要创建类的对象来调用该方法。 看到这里，我们明白了，python中的实例方法不是构造器，和java中的实例方法一样，但是java/C++中的静态方法、类方法和python中的静态方法、类方法可不一样， python 可以函数嵌套定义，但是C/C++语言不行 decorator的作用:在保证原本函数不改变的前提下，直接给这个函数增加一些功能 实例方法可以用实例对象调用，也可以用类去调用，当使用类去调用时注意要传入第一个参数 类方法可以用实例对象去调用，此时decorator会忽略实例对象而自动传入实例对象所属的类，也可以用类去调用 静态方法可以用实例对象调用也可以用类去调用 python类属性和实例属性不一样，举个例子 12class Person: age = 18 123class Person: def __init__(self): self.age = 18 前者的age是类属性，每一个Person对象都能访问到age这个类属性，但在Person的实例化对象中没法修改age的值，也就是说每个实例化对象的age都是18且只能是18， 但是后者那个age是实例属性，每一个Person对象自带age这个属性，但这个属性属于这个实例对象，修改其中一个实例对象的age不会影响其他实例对象的age值 这一点和java不一样 python set方法去修改私有属性，很多人觉得多此一举，本来把属性设置成私有就是为了不能随便改动它，又定义一个set方法去修改私有属性的值，那不是脱了裤子放屁吗？其实我们有时候设置成私有属性不是让它变得不可修改，而是让它变得不能被随意修改，因为修改它必须调用set方法，所以，我们可以在set方法里面加一些条件，让传进set方法里面的参数做一些限制，使得私有属性修改后的值是恰当的合理的。如果不用私有属性+set方法，直接在类外面就可以修改这个属性，那么我们想在模块的什么地方修改就能在模块的什么地方修改，这样的话麻烦就来了，在修改的那个地方必须做判定，即修改后的新值合不合理，在每个修改属性的地方都要做一个这样的判定，很麻烦，而且容易漏，(如果这个属性恰好是银行存款额，又忘记判定，就容易出事)所以属性修改，采用私有属性+set方法的形式，减少代码重复度，也不会有忘记的情况。这一点python和java是一样的 输入一个整形列表： 1n = list(map(int, input().split(&#x27;,&#x27;))) 切片有一个强大功能是给切片赋值，如果把切片放在赋值语句的左边，或把它作为del操作的对象，我们就可以对序列进行嫁接、切除或就地修改操作。能切片赋值是因为切片是对原iterable的视窗，是引用关系 python切片：超出索引范围的切片参数，可以看成把list以空元素延长，进行切片操作后，去掉空元素后得到结果，例如： 12345678910&gt;&gt;&gt; a[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]&gt;&gt;&gt; a[-100:5][0, 1, 2, 3, 4]&gt;&gt;&gt; a[5:100][5, 6, 7, 8, 9]&gt;&gt;&gt; a[-100:100][0, 1, 2, 3, 4, 5, 6, 7, 8, 9]&gt;&gt;&gt; a[100:1000][] 若start比stop大，则得到空list, 列表切片很有用，比如切片赋值操作： 12345678910111213141516171819202122232425&gt;&gt;&gt; l = list(&quot;0123456789&quot;)&gt;&gt;&gt; l[&#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;]&gt;&gt;&gt; l[6:] = list(&quot;abcdef&quot;) //类似append,add,extends等&gt;&gt;&gt; l [&#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;]&gt;&gt;&gt; l[5:8] = [&quot;g&quot;]&gt;&gt;&gt; l [&#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;g&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;]# 也可以不替换原有元素情况下加入新元素&gt;&gt;&gt; l = list(&quot;abcd&quot;)&gt;&gt;&gt; l [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]&gt;&gt;&gt; l[2:2] = list(&quot;12&quot;)&gt;&gt;&gt; l [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]# 再或者可以这样插入s = list(range(10))s[3:2] = [11, 12]print(s) # 输出[0, 1, 2, 11, 12, 3, 4, 5, 6, 7, 8, 9]# 删除元素&gt;&gt;&gt; l = list(range(10))&gt;&gt;&gt; l[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]&gt;&gt;&gt; del l[5:7] 当然，切片赋值，步长也可以不等于1，举例，给列表索引为偶数的元素排序 12n = list(map(int, input().strip(&#x27;[]&#x27;).split(&#x27;,&#x27;)))n[::2] = sorted(n[::2], reverse=True) 但是，切片赋值，给序列的切片部分新的赋值必须是可迭代类型，直接给列表切片赋一个整型会报错 遍历字典键值对最pythonic的方法就是是使用.items()方法。items() 方法把字典中每对 key 和 value 组成一个元组，并把这些元组放在列表中返回。 12for k,v in dict_1.items(): print(k,&quot;&gt;&gt;&quot;,v) 给字典按值排序： 1234s2 = sorted(s.items(), key=operator.itemgetter(1))# s是一个字典，sorted返回一个新列表，但是列表的元素是一个个包含键值对的元组# 或者用下面的匿名函数sorted(L, key=lambda x:x[1]) python 中 List.count 和 str.count 不一样，Python str.count() 方法用于统计字符串里某个字符或子字符串出现的次数。List.count(obj) 方法用于统计某个元素在列表中出现的次数。obj – 列表中统计的对象 找出列表中出现次数最多的元素： 12a = [1,2,3,4,2,3,2]maxlabel = max(a,key=a.count) Pandas保持了Numpy对关键字axis的用法 bool类型: 12345678&gt;&gt;&gt; bool(0)False&gt;&gt;&gt; bool(1)True&gt;&gt;&gt; bool(2)True&gt;&gt;&gt; issubclass(bool, int) # bool 是 int 子类True operator.eq(48, ‘0’) 用来比较两个对象是否相等，既会检查类型也会检查值 enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。 普通的for循环需要单独设置一个控制变量： 12345i = 0a = [&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;]for j in a: print(i, j) i += 1 但是用了enumerate就不需要了 123a = [&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;]for i, element in enumerate(a): print(i, element) filter() 函数用于过滤序列，过滤掉不符合条件的元素，返回一个迭代器对象，如果要转换为列表，可以使用 list() 来转换。该接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判断，然后返回 True 或 False，最后将返回 True 的元素放到新列表中。 12345def is_odd(n): return divmod(n, 2)[1] == 0b = range(10)print(list(filter(is_odd, b))) 输出： 1[0, 2, 4, 6, 8] python divmod() 函数把除数和余数运算结果结合起来，返回一个包含商和余数的元组(a // b, a % b) id()返回对象的内存地址 split() 通过指定分隔符对字符串进行切片，如果参数 num 有指定值，则分隔 num+1 个子字符串。 123str.split(str=&quot;&quot;, num=string.count(str))str -- 分隔符，默认为所有的空字符，包括空格、换行(\\n)、制表符(\\t)等。num -- 分割次数。默认为 -1, 即分隔所有。 input() 接收多个值: 1a,b,c = (input(&quot;请输入三角形三边的长：&quot;).split()) isinstance() 函数来判断一个对象是否是一个已知的类型，类似 type()。但是与type()又有不同：type() 不会认为子类是一种父类类型，不考虑继承关系。isinstance() 会认为子类是一种父类类型，考虑继承关系。如果要判断两个类型是否相同推荐使用 isinstance()。 len() 方法返回对象（字符、列表、元组等）长度或项目个数。 max() 方法返回给定参数的最大值，参数可以为序列。即参数可以不是数字 Python3 range() 函数返回的是一个可迭代对象（类型是对象），而不是列表类型， 所以打印的时候不会打印列表。 repr() 方法可以将读取到的格式字符，比如换行符、制表符，转化为其相应的转义字符。 123s = &quot;物品\\t单价\\t数量\\n包子\\t1\\t2&quot;print(s)print(repr(s)) 输出: 123物品 单价 数量包子 1 2&#x27;物品\\t单价\\t数量\\n包子\\t1\\t2&#x27; reversed 函数参数是一个iterable，返回一个返回一个反转的迭代器。list.reverse() 函数用于反向列表中元素。 join() 方法用于将序列中的元素以指定的字符连接生成一个新的字符串。str.join(sequence)，sequence – 要连接的元素序列。 12seqString = &#x27;Runoob&#x27;print(&quot;&quot;.join(list(reversed(seqString)))) round() 方法返回浮点数 x 的四舍五入值，准确的说保留值将保留到离上一位更近的一端（四舍六入）。 dict和set都是{}包裹，但是创建一个空{}代表空dict，因为dict更常用 12print(type(&#123;1, 2, 3&#125;))print(type(&#123;1: a, 2: b&#125;)) 输出: 12&lt;class &#x27;set&#x27;&gt;&lt;class &#x27;dict&#x27;&gt; slice 对象用于指定如何对序列进行裁切。您可以指定在哪里开始裁切以及在哪里结束裁切。您还可以指定步进，slice(start, end, step)。返回 slice 对象 sorted() 函数对所有可迭代的对象进行排序操作。sorted(iterable, cmp=None, key=None, reverse=False)，返回一个新的重新排序的列表。该函数可以将字典按照键或者值排序 iterable – 可迭代对象。 key – 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。 reverse – 排序规则，reverse = True 降序 ， reverse = False 升序（默认）。 sort 与 sorted 区别： sort 是应用在 list 上的方法，sorted 可以对所有可迭代的对象进行排序操作。 list函数和list方法的区别: list 的 sort 方法返回的是对已经存在的列表进行操作，而内建函数 sorted 方法返回的是一个新的 list，而不是在原来的基础上进行的操作。 123&gt;&gt;&gt; students = [(&#x27;john&#x27;, &#x27;A&#x27;, 15), (&#x27;jane&#x27;, &#x27;B&#x27;, 12), (&#x27;dave&#x27;, &#x27;B&#x27;, 10)]&gt;&gt;&gt; sorted(students, key=lambda s: s[2]) # 按年龄排序[(&#x27;dave&#x27;, &#x27;B&#x27;, 10), (&#x27;jane&#x27;, &#x27;B&#x27;, 12), (&#x27;john&#x27;, &#x27;A&#x27;, 15)] sum() 方法对序列进行求和计算:sum(iterable[, start]): iterable – 可迭代对象，如：列表、元组、集合。 start – 指定相加的参数，如果没有设置这个值，默认为0 12&gt;&gt;&gt; sum([0,1,2,3,4], 2) # 列表计算总和后再加 212 zip() 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的对象，这样做的好处是节约了不少的内存。我们可以使用 list() 转换来输出列表。如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同，利用 * 号操作符，可以将元组解压为列表。 原始字符串 - 原始字符串：所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。 原始字符串除在字符串的第一个引号前加上字母 r（可以大小写）以外，与普通字符串有着几乎完全相同的语法。 12print( r&#x27;\\n&#x27; )print( R&#x27;\\n&#x27; ) endswith() 方法用于判断字符串是否以指定后缀结尾，如果以指定后缀结尾返回 True，否则返回 False。可选参数 “start” 与 “end” 为检索字符串的开始与结束位置。str.endswith(suffix[, start[, end]]) suffix – 该参数可以是一个字符串或者是一个元素。 start – 字符串中的开始位置。 end – 字符中结束位置。 find()方法和index()一样，只不过find()方法检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回-1； index()方法str不在字符串中会报一个异常。 rfind() 返回字符串最后一次出现的位置，如果没有匹配项则返回-1。rindex() 返回子字符串 str 在字符串中最后出现的位置，如果没有匹配的字符串会报异常，你可以指定可选参数[beg:end]设置查找的区间。 rjust() 返回一个原字符串右对齐,并使用空格填充至长度 width 的新字符串。如果指定的长度小于字符串的长度则返回原字符串。ljust() 方法返回一个原字符串左对齐,并使用空格填充至指定长度的新字符串。如果指定的长度小于原字符串的长度则返回原字符串。 isdigit() 方法只对正整数有效，负数及小数均返回不正确。 isdigit() True: Unicode数字，byte数字（单字节），全角数字（双字节），罗马数字 False: 汉字数字 Error: 无 isdecimal() True: Unicode数字，，全角数字（双字节） False: 罗马数字，汉字数字 Error: byte数字（单字节） isnumeric() True: Unicode数字，全角数字（双字节），罗马数字，汉字数字 False: 无 Error: byte数字（单字节） str.maketrans 返回一个可以用于 str.translate 函数中的翻译表，就是返回一个对照表table，这个对照表可以被translate利用。 str.translate(table) 函数使用 table 作为翻译表，对原字符串中的内容进行替换， 123456789101112# 字母 R 替换为 Ntxt = &quot;Runoob!&quot;mytable = txt.maketrans(&quot;R&quot;, &quot;N&quot;)print(txt.translate(mytable))# 使用字符串设置要替换的字符，一一对应intab = &quot;aeiou&quot;outtab = &quot;12345&quot;trantab = str.maketrans(intab, outtab)str = &quot;this is string example....wow!!!&quot;print (str.translate(trantab)) 输出: 12Nunoob!th3s 3s str3ng 2x1mpl2....w4w!!! max() 也可以返回字符串中最大的字母。min()同理 str.splitlines([keepends]) 按照行(’\\r’, ‘\\r\\n’, \\n’)分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。 1234&gt;&gt;&gt; &#x27;ab c\\n\\nde fg\\rkl\\r\\n&#x27;.splitlines()[&#x27;ab c&#x27;, &#x27;&#x27;, &#x27;de fg&#x27;, &#x27;kl&#x27;]&gt;&gt;&gt; &#x27;ab c\\n\\nde fg\\rkl\\r\\n&#x27;.splitlines(True)[&#x27;ab c\\n&#x27;, &#x27;\\n&#x27;, &#x27;de fg\\r&#x27;, &#x27;kl\\r\\n&#x27;] startswith() 方法用于检查字符串是否是以指定子字符串开头，如果是则返回 True，否则返回 False。startswith() 方法用于检查字符串是否是以指定子字符串开头，如果是则返回 True，否则返回 False。 swapcase() 方法用于对字符串的大小写字母进行转换，即将大写字母转换为小写字母，小写字母会转换为大写字母。lower() 方法转换字符串中所有大写字符为小写。upper() 方法将字符串中的小写字母转为大写字母。 title() 方法返回&quot;标题化&quot;的字符串,就是说所有单词的首个字母转化为大写，其余字母均为小写.istitle() 方法检测字符串中所有的单词拼写首字母是否为大写，且其他字母为小写。 可以使用 del 语句来删除列表的的元素 list.remove(obj) 函数用于移除列表中某个值的第一个匹配项。obj – 列表中要移除的对象。 列表对 + 和 * 的操作符与字符串相似。+ 号用于组合列表，* 号用于重复列表。元组同理 index() 函数用于从列表中找出某个值第一个匹配项的索引位置.与字符串的index()方法类似 list.insert(index, obj) 函数用于将指定对象插入列表的指定位置。 list.remove(obj) 函数用于移除列表中某个值的第一个匹配项。obj – 列表中要移除的对象。 list.copy()返回复制后的新列表。 元组只有一个元素时，后面往往跟个逗号，这是为什么呢？消除歧义，比如tup1=(50，) del tinydict[‘Name’] # 删除键 ‘Name’ tinydict.clear() # 清空字典 del tinydict # 删除字典 dict的键不可变，所以键所以可以用数字，字符串或元组充当，而用列表就不行 dict.fromkeys(seq[, value]) 函数用于创建一个新字典，以序列 seq 中元素做字典的键，value 为字典所有键对应的初始值。这种方式可以把列表利用起来用来创造字典，比一个一个输方便，比如： 1234567seq = (&#x27;name&#x27;, &#x27;age&#x27;, &#x27;sex&#x27;) tinydict = dict.fromkeys(seq)print (&quot;新的字典为 : %s&quot; % str(tinydict)) tinydict = dict.fromkeys(seq, 10)print (&quot;新的字典为 : %s&quot; % str(tinydict)) 输出: 12新的字典为 : &#123;&#x27;age&#x27;: None, &#x27;name&#x27;: None, &#x27;sex&#x27;: None&#125;新的字典为 : &#123;&#x27;age&#x27;: 10, &#x27;name&#x27;: 10, &#x27;sex&#x27;: 10&#125; 下面这种利用 zip()的方法也可以快速创造字典: 123a = list(range(1, 6))b = [&#x27;手机&#x27;, &#x27;电脑&#x27;, &#x27;平板&#x27;, &#x27;数据线&#x27;, &#x27;充电宝&#x27;]s = dict(zip(a, b)) dict.keys()、dict.values() 和 dict.items() 返回的都是视图对象（ view objects），提供了字典实体的动态视图，这就意味着字典改变，视图也会跟着变化。视图对象不是列表，不支持索引，可以使用 list() 来转换为列表。我们不能对视图对象进行任何的修改，因为字典的视图对象都是只读的。 1234dishes = &#123;&#x27;eggs&#x27;: 2, &#x27;sausage&#x27;: 1, &#x27;bacon&#x27;: 1, &#x27;spam&#x27;: 500&#125;print(dishes.items())print(dishes.keys())print(dishes.values()) 输出: 123dict_items([(&#x27;eggs&#x27;, 2), (&#x27;sausage&#x27;, 1), (&#x27;bacon&#x27;, 1), (&#x27;spam&#x27;, 500)])dict_keys([&#x27;eggs&#x27;, &#x27;sausage&#x27;, &#x27;bacon&#x27;, &#x27;spam&#x27;])dict_values([2, 1, 1, 500]) dict.get(key[, value]) 返回指定键的值，如果键不在字典中返回默认值 None 或者设置的默认值。dict.setdefault(key, default=None) 方法和 get()方法 类似, 如果键不存在于字典中，将会添加键并将值设为默认值。 dict.update(dict2)用来合并两个字典 列表、元组、字典中都没有add()方法，只有集合中有 set1.difference_update(set2) 方法与 difference() 方法的区别在于 difference() 方法返回一个移除相同元素的新集合，而 difference_update() 方法是直接在原来的集合中移除元素，没有返回值。 集合中set.pop()随机移除一个元素，因为集合是无序的，这与其他iterable不同，其他pop一般是移除最后一个元素或移除指定的元素 set.isdisjoint(set)方法用于判断两个集合是否包含相同的元素，如果没有返回 True，否则返回 False。 symmetric_difference(), 此时再体会一下symmetric的含义就清楚了，对称的，所以返回的新set的元素：包含在a中，并且不包含在集合b中 + 包含在b中，并且不包含在集合a中。这么解释反而复杂了，其实简单来说就是去重。类似合并 demo[1::2] 切片步长的理解:步长为2即，从当前元素的下一个元素起，向下数 步长 个数字对应的元素 与列表一样，元组中的元素类型也可以不相同. Python 3.6 改写了 dict 的内部算法，因此 3.6 的 dict 是有序的，在此版本之前皆是无序。而恰好《Python 编程从入门到实践》这本书就是用 Python 3.5 版本 for _ in range(n)仅将循环运行n次，等效于for i in range(n)，只不过_在后面不会用到，只是占位符，这里的_可以替换成任何符合规定的字符串。标识符可以由字母、数字、下画线（_）组成，其中数字不能打头。这里 _ 和 i 是一样的 bj_PM_mean = pursue_mean.df_bj.loc[pursue_mean.df_bj[‘PM_mean’].notnull(), [‘PM_mean’]].meam() // loc[]里面括住的，左边代表行标签，右边还有个 [],里面是列标签 bj_PM_mean = pursue_mean.df_bj.loc[pursue_mean.df_bj[‘PM_mean’].notnull(), [‘PM_mean’]].mean() 返回的是一个对象，想取值则 bj_PM_mean.PM_mean 若只想从别的py文件导入某个变量，则可以这样写: from 文件名 import 变量名 from pyecharts import options as opts 使用 from …… import …… 的形式也能 as 别名 pyecharts要求int类型的数据，若是浮点数，则画的柱状图无法显示数据 DataFrame 合并索引的方法之一，可以把要合并的列的数据类型转为字符串，然后用 + 号连接成一个新的列索引","categories":[],"tags":[]},{"title":"尝试一下Markdown","slug":"markdown-learn","date":"2022-07-22T07:42:10.000Z","updated":"2022-08-02T02:24:28.964Z","comments":true,"path":"2022/07/22/markdown-learn/","link":"","permalink":"http://example.com/2022/07/22/markdown-learn/","excerpt":"","text":"尝试一下Markdown （很久没有写作了看起来像小学生作文😂） Markdown是什么 Markdown是一种非常简单的轻量级标记语言，并不是一门编程语言。 我们平时在用word时经常会关注formatting，也就是它的各种格式，但在写一些注重语义的文章时，比如博文，纷杂的格式显得没那么重要，而markdown可以让我们专注于semantics。 Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。 当前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、简书、reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge等。 John Gruber在2004年创造了Markdown语言，在语法上有很大一部分是跟亚伦·斯沃茨（Aaron Swartz）共同合作的。这个语言的目的是希望大家使用“易于阅读、易于撰写的纯文字格式，并选择性的转换成有效的XHTML（或是HTML）”。 其中最重要的设计是可读性，也就是说这个语言应该要能直接在字面上的被阅读，而不用被一些格式化指令标记（像是RTF与HTML）。 因此，它是现行电子邮件标记格式的惯例，虽然它也借鉴了很多早期的标记语言，如：Setext、Texile、reStructuredText。 使用VSCode开始Markdown写作 VSCode（全称：Visual Studio Code）是一款由微软开发且跨平台的免费源代码编辑器。VSCode 是当下非常流行的代码编辑器，它的界面看起来高级且拥有丰富的拓展。而且，VSC天然支持Markdown，所以用起来非常丝滑。 一些编辑器 Windows Typora、Simplenote、Laverna、Boostnote、Inkdrop、Cmd Markdown、Github、马克飞象、Yu Writer、看云、有道云笔记、为知笔记、蚂蚁笔记 MacOS Typora、Typed、Ulysses、Falcon Linux Typora、Atom、GNU Emacs、Remarkable、Haroopad、ReText、UberWriter、Mark My Words Android Draft、JotterPad X、坚果云Markdown iOS Byword、simplenote、坚果云Markdown 写一些 LaTeX 公式 在这写一段公式 ∫dxa2−x2=12aln⁡a+xa−x+C\\int \\frac{d x}{a^{2}-x^{2}}=\\frac{1}{2 a} \\ln \\frac{a+x}{a-x}+C∫a2−x2dx​=2a1​lna−xa+x​+C 哈哈哈哈哈哈哈 再来一个！ f(t)=a0+∑n=1∞[ancos⁡(nωt)+bnsin⁡(nωt)]a0=1T∫t0t0+Tf(t)dtan=2T∫t0t0+Tf(t)cos⁡(nωt)dt,bn=2T∫t0t0+Tf(t)sin⁡(nωt)dtf(t)=c0+∑n=1∞cncos⁡(nωt+ϕn)an=cncos⁡ϕn,bn=−cnsin⁡ϕntan⁡ϕn=−bnan\\begin{gathered} f(t)=a_{0}+\\sum_{n=1}^{\\infty}\\left[a_{n} \\cos (n \\omega t)+b_{n} \\sin (n \\omega t)\\right] \\\\ a_{0}=\\frac{1}{T} \\int_{t_{0}}^{t_{0}+T} f(t) \\mathrm{d} t \\\\ a_{n}=\\frac{2}{T} \\int_{t_{0}}^{t_{0}+T} f(t) \\cos (n \\omega t) \\mathrm{d} t, b_{n}=\\frac{2}{T} \\int_{t_{0}}^{t_{0}+T} f(t) \\sin (n \\omega t) \\mathrm{d} t \\\\ f(t)=c_{0}+\\sum_{n=1}^{\\infty} c_{n} \\cos \\left(n \\omega t+\\phi_{n}\\right) \\\\ a_{n}=c_{n} \\cos \\phi_{n}, b_{n}=-c_{n} \\sin \\phi_{n} \\\\ \\tan \\phi_{n}=-\\frac{b_{n}}{a_{n}} \\end{gathered} f(t)=a0​+n=1∑∞​[an​cos(nωt)+bn​sin(nωt)]a0​=T1​∫t0​t0​+T​f(t)dtan​=T2​∫t0​t0​+T​f(t)cos(nωt)dt,bn​=T2​∫t0​t0​+T​f(t)sin(nωt)dtf(t)=c0​+n=1∑∞​cn​cos(nωt+ϕn​)an​=cn​cosϕn​,bn​=−cn​sinϕn​tanϕn​=−an​bn​​​ (偷偷用了Mathpix Snipping Tool) 来个表格 Markdown语法 详解 效果 斜体 无 斜体 粗体 无 粗体 插入链接 此处是一个链接 一串code 1234def check_anagram(first_word, second_word): return sorted(first_word) == sorted(second_word)print(check_anagram(&quot;silent&quot;, &quot;listen&quot;)) # Trueprint(check_anagram(&quot;ginger&quot;, &quot;danger&quot;)) # False See u again !","categories":[],"tags":[]},{"title":"HTML中表单的input标签 name属性有无[]的区别","slug":"form_name_Problem","date":"2022-07-22T07:42:10.000Z","updated":"2022-10-13T07:26:24.154Z","comments":true,"path":"2022/07/22/form_name_Problem/","link":"","permalink":"http://example.com/2022/07/22/form_name_Problem/","excerpt":"","text":"先看链接 我们来看这段代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;大卖场&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;#&quot; method=&quot;post&quot;&gt; &lt;center&gt;注册账号&lt;/center&gt; &lt;table align=&quot;center&quot; border=&quot;1&quot;&gt; &lt;tr&gt; &lt;td&gt;用户名:&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;content[username]&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;email:&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;content[email]&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码:&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;content[pwd]&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;确认密码:&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;content[confirm_pwd]&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;性别:&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;radio&quot; name=&quot;content[sex]&quot; value=&quot;男&quot;&gt;男 &lt;input type=&quot;radio&quot; name=&quot;content[sex]&quot; value=&quot;女&quot; checked&gt;女 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;手机号码:&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;content[phone]&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;喜欢的编程技术:&lt;/td&gt; &lt;td&gt; &lt;select name=&quot;content[loveLanguage]&quot;&gt; &lt;option selected&gt;PHP&lt;/option&gt; &lt;option &gt;Python&lt;/option&gt; &lt;option&gt;Java&lt;/option&gt; &lt;option&gt;C&lt;/option&gt; &lt;option&gt;C++&lt;/option&gt; &lt;option&gt;Go&lt;/option&gt; &lt;option&gt;Rust&lt;/option&gt; &lt;option&gt;C#&lt;/option&gt; &lt;/select&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td COLSPAN=&quot;2&quot;&gt; &lt;input type=&quot;checkbox&quot; checked name=&quot;content[check]&quot;&gt;我已经看过并接受&lt;a href=&quot;https://www.bilibili.com/&quot; target=&quot;_blank&quot;&gt; &lt;b&gt;用户协议&lt;/b&gt;&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;立即注册&quot; name=&quot;bnt&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/form&gt; &lt;?php if (isset($_POST[&quot;bnt&quot;])) &#123; if (isset($_POST[&quot;content&quot;][&quot;check&quot;])) &#123; if ($_POST[&quot;content&quot;][&quot;username&quot;] == &quot;&quot; || $_POST[&quot;content&quot;][&quot;email&quot;] == &quot;&quot; || $_POST[&quot;content&quot;][&quot;pwd&quot;] == &quot;&quot; || $_POST[&quot;content&quot;][&quot;confirm_pwd&quot;] == &quot;&quot; || $_POST[&quot;content&quot;][&quot;sex&quot;] == &quot;&quot; || $_POST[&quot;content&quot;][&quot;phone&quot;] == &quot;&quot; || $_POST[&quot;content&quot;][&quot;loveLanguage&quot;] == &quot;&quot;) &#123; echo &quot;不能有不填的！&quot; or exit(&quot;回去填&quot;); &#125;else &#123; echo &quot;你好&quot;; echo &quot;用户名:&quot;.$_POST[&quot;content&quot;][&quot;username&quot;].&quot;&lt;br&gt;&quot;; echo &quot;邮箱:&quot;.$_POST[&quot;content&quot;][&quot;email&quot;].&quot;&lt;br&gt;&quot;; echo &quot;密码:&quot;.$_POST[&quot;content&quot;][&quot;pwd&quot;].&quot;&lt;br&gt;&quot;; echo &quot;确认密码:&quot;.$_POST[&quot;content&quot;][&quot;confirm_pwd&quot;].&quot;&lt;br&gt;&quot;; echo &quot;性别:&quot;.$_POST[&quot;content&quot;][&quot;sex&quot;].&quot;&lt;br&gt;&quot;; echo &quot;手机号:&quot;.$_POST[&quot;content&quot;][&quot;phone&quot;].&quot;&lt;br&gt;&quot;; echo &quot;你喜欢的编程预言:&quot;.$_POST[&quot;content&quot;][&quot;loveLanguage&quot;].&quot;&lt;br&gt;&quot;; &#125; &#125; &#125; ?&gt;&lt;/body&gt;&lt;/html&gt; 如果写成 $_POST[“content[check]”] 就是错误的，因为这种索引形式没法索引二维数组。","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2022-07-20T03:19:50.706Z","updated":"2022-07-20T09:09:11.232Z","comments":true,"path":"2022/07/20/hello-world/","link":"","permalink":"http://example.com/2022/07/20/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}